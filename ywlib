/// @file ywlib
/// C++20 library for DirectX 12.

#pragma once
// clang-format off

#define nat size_t
static_assert(sizeof(nat) == 8, "ywlib requires 64-bit platform");
#define ywlib_wrapper(...) noexcept(noexcept(__VA_ARGS__)) requires requires { __VA_ARGS__; } { return __VA_ARGS__; }

#include <bit>
#include <chrono>
#include <compare>
#include <limits>
#include <filesystem>
#include <format>
#include <fstream>
#include <iostream>
#include <numbers>
#include <ranges>
#include <string>
#include <string_view>
#include <utility>
#include <vector>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef max
#undef min

namespace yw { // Core Definitions

using cat1 = char;
using cat2 = wchar_t;
using uct1 = char8_t;
using uct2 = char16_t;
using uct4 = char32_t;
using int1 = signed char;
using int2 = signed short;
using int4 = signed int;
using int8 = signed long long;
using nat1 = unsigned char;
using nat2 = unsigned short;
using nat4 = unsigned int;
using nat8 = unsigned long long;
using fat4 = float;
using fat8 = double;

using sl_t = long;
using ul_t = unsigned long;
using ld_t = long double;
using po_t = std::partial_ordering;
using wo_t = std::weak_ordering;
using so_t = std::strong_ordering;

inline constexpr nat npos = nat(-1);
inline constexpr po_t unordered = std::partial_ordering::unordered;

consteval cat1 operator""_c1(nat n) { return static_cast<cat1>(n); }
consteval cat2 operator""_c2(nat n) { return static_cast<cat2>(n); }
consteval uct1 operator""_u1(nat n) { return static_cast<uct1>(n); }
consteval uct2 operator""_u2(nat n) { return static_cast<uct2>(n); }
consteval uct4 operator""_u4(nat n) { return static_cast<uct4>(n); }
consteval int1 operator""_i1(nat n) { return static_cast<int1>(n); }
consteval int2 operator""_i2(nat n) { return static_cast<int2>(n); }
consteval int4 operator""_i4(nat n) { return static_cast<int4>(n); }
consteval int8 operator""_i8(nat n) { return static_cast<int8>(n); }
consteval nat1 operator""_n1(nat n) { return static_cast<nat1>(n); }
consteval nat2 operator""_n2(nat n) { return static_cast<nat2>(n); }
consteval nat4 operator""_n4(nat n) { return static_cast<nat4>(n); }
consteval nat8 operator""_n8(nat n) { return static_cast<nat8>(n); }
consteval fat4 operator""_f4(nat n) { return static_cast<fat4>(n); }
consteval fat8 operator""_f8(nat n) { return static_cast<fat8>(n); }
consteval fat4 operator""_f4(ld_t n) { return static_cast<fat4>(n); }
consteval fat8 operator""_f8(ld_t n) { return static_cast<fat8>(n); }

template<typename T> struct t_type { using type = T; };
template<typename T> using type = typename t_type<T>::type;
template<typename T> concept valid = requires { typename type<T>; };
template<typename T, typename... Ts> concept same_as = requires { requires (std::same_as<T, Ts> && ...); };
template<typename T, typename... Ts> concept included_in = requires { requires (std::same_as<T, Ts> || ...); };
template<typename T, typename... Ts> concept derived_from = requires { requires (std::derived_from<T, Ts> && ...); };
template<typename T, typename... Ts> concept castable_to = requires(T (&f)()) { ((static_cast<Ts>(f())), ...); };
template<typename T, typename... Ts> concept nt_castable_to = castable_to<T, Ts...> && requires(T (&f)() noexcept) { { ((static_cast<Ts>(f())), ...) } noexcept; };
template<typename T, typename... Ts> concept convertible_to = requires { requires (std::convertible_to<T, Ts> && ...); };
template<typename T, typename... Ts> concept nt_convertible_to = convertible_to<T, Ts...> && requires { requires (std::is_nothrow_convertible_v<T, Ts> && ...); };

/// checks if the type can be explicitly converted to signed/unsigned integer and floating point types
template<typename T> concept numerical = nt_castable_to<T, int4, int8, nat4, nat8, fat4, fat8>;

/// struct to represent a constant value
template<auto V, typename T = decltype(V)> requires convertible_to<decltype(V), T> struct constant {
  using type = T;
  static constexpr type value = V;
  consteval operator type() const noexcept { return value; }
  consteval type operator()() const noexcept { return value; }
};

/// struct to represent a null value
struct none {
  constexpr none() noexcept = default;
  constexpr none(auto&&...) noexcept {}
  constexpr none& operator=(auto&&) noexcept { return *this; }
  explicit constexpr operator bool() const noexcept { return false; }
  constexpr none operator()(auto&&...) const noexcept { return {}; }
  [[nodiscard]] constexpr friend bool operator==(none, none) noexcept { return false; }
  [[nodiscard]] constexpr friend auto operator<=>(none, none) noexcept { return unordered; }
  [[nodiscard]] constexpr friend none operator+(none) noexcept { return {}; }
  [[nodiscard]] constexpr friend none operator-(none) noexcept { return {}; }
  [[nodiscard]] constexpr friend none operator+(none, none) noexcept { return {}; }
  [[nodiscard]] constexpr friend none operator-(none, none) noexcept { return {}; }
  [[nodiscard]] constexpr friend none operator*(none, none) noexcept { return {}; }
  [[nodiscard]] constexpr friend none operator/(none, none) noexcept { return {}; }
  constexpr none& operator+=(none) noexcept { return *this; }
  constexpr none& operator-=(none) noexcept { return *this; }
  constexpr none& operator*=(none) noexcept { return *this; }
  constexpr none& operator/=(none) noexcept { return *this; }
};

/// struct to represent a generic value
struct value {
  fat8 _{};
  constexpr value() noexcept = default;
  constexpr value(none) noexcept : _(std::numeric_limits<fat8>::quiet_NaN()) {}
  template<numerical T> requires(!same_as<T, value>) constexpr value(T&& Value) noexcept : _(fat8(static_cast<T&&>(Value))) {}
  constexpr operator fat8&() & noexcept { return _; }
  constexpr operator const fat8&() const& noexcept { return _; }
  constexpr operator fat8&&() && noexcept { return static_cast<fat8&&>(_); }
  constexpr operator const fat8&&() const&& noexcept { return static_cast<const fat8&&>(_); }
  template<typename T> requires castable_to<fat8, T> explicit constexpr operator T() const noexcept(nt_castable_to<fat8, T>) { return T(_); }
  template<numerical T> constexpr value& operator+=(T&& Value) noexcept { return _ += double(static_cast<T&&>(Value)), *this; }
  template<numerical T> constexpr value& operator-=(T&& Value) noexcept { return _ -= double(static_cast<T&&>(Value)), *this; }
  template<numerical T> constexpr value& operator*=(T&& Value) noexcept { return _ *= double(static_cast<T&&>(Value)), *this; }
  template<numerical T> constexpr value& operator/=(T&& Value) noexcept { return _ /= double(static_cast<T&&>(Value)), *this; }
};

inline constexpr value e = std::numbers::e_v<fat8>;                  // Euler's number
inline constexpr value pi = std::numbers::pi_v<fat8>;                // Pi
inline constexpr value phi = std::numbers::phi_v<fat8>;              // Golden ratio
inline constexpr value gamma = std::numbers::egamma_v<fat8>;         // Euler-Mascheroni constant
inline constexpr value ln2 = std::numbers::ln2_v<fat8>;              // Natural logarithm of 2
inline constexpr value ln10 = std::numbers::ln10_v<fat8>;            // Natural logarithm of 10
inline constexpr value sqrt2 = std::numbers::sqrt2_v<fat8>;          // Square root of 2
inline constexpr value sqrt3 = std::numbers::sqrt3_v<fat8>;          // Square root of 3
inline constexpr value inf = std::numeric_limits<fat8>::infinity();  // Positive infinity
inline constexpr value nan = std::numeric_limits<fat8>::quiet_NaN(); // Quiet NaN

template<typename T> concept is_const = std::is_const_v<T>;
template<typename T> concept is_volatile = std::is_volatile_v<T>;
template<typename T> concept is_cv = is_const<T> && is_volatile<T>;
template<typename T> concept is_lvref = std::is_lvalue_reference_v<T>;
template<typename T> concept is_rvref = std::is_rvalue_reference_v<T>;
template<typename T> concept is_reference = is_lvref<T> || is_rvref<T>;
template<typename T> concept is_pointer = std::is_pointer_v<T>;
template<typename T> concept is_bounded_array = std::is_bounded_array_v<T>;
template<typename T> concept is_unbounded_array = std::is_unbounded_array_v<T>;
template<typename T> concept is_array = is_bounded_array<T> || is_unbounded_array<T>;
template<typename T> concept is_function = std::is_function_v<T>;

template<typename T> using remove_cv = std::remove_cv_t<T>;
template<typename T> using remove_const = std::remove_const_t<T>;
template<typename T> using remove_volatile = std::remove_volatile_t<T>;
template<typename T> using remove_ref = std::remove_reference_t<T>;
template<typename T> using remove_cvref = std::remove_cvref_t<T>;
template<typename T> using remove_extent = std::remove_extent_t<T>;
template<typename T> using remove_all_extents = std::remove_all_extents_t<T>;
template<typename T> using remove_pointer = std::remove_pointer_t<T>;
namespace _ { template<typename T> struct _remove_all_pointers : t_type<T> {}; }
template<typename T> using remove_all_pointers = typename _::_remove_all_pointers<T>::type;

template<typename T> concept is_memptr = is_pointer<T> && std::is_member_pointer_v<T>;
namespace _ { template<typename T> struct _member_type;}
template<is_memptr Mp> using member_type = typename _::_member_type<remove_cv<Mp>>::m;
template<is_memptr Mp> using class_type = typename _::_member_type<remove_cv<Mp>>::c;
template<typename T> concept is_member_function_pointer = is_memptr<T> && is_function<member_type<T>>;
template<typename T> concept is_member_object_pointer = is_memptr<T> && !is_member_function_pointer<T>;

template<typename T> concept is_enum = std::is_enum_v<T>;
template<typename T> concept is_class = std::is_class_v<T>;
template<typename T> concept is_union = std::is_union_v<T>;
template<typename T> concept is_abstract = is_class<T> && std::is_abstract_v<T>;
template<typename T> concept is_aggregate = is_class<T> && std::is_aggregate_v<T>;
template<typename T> concept is_empty = is_class<T> && std::is_empty_v<T>;
template<typename T> concept is_final = is_class<T> && std::is_final_v<T>;
template<typename T> concept is_polymorphic = is_class<T> && std::is_polymorphic_v<T>;
template<typename T> concept has_virtual_destructor = is_class<T> && std::has_virtual_destructor_v<T>;
template<typename T> concept is_standard_layout = std::is_standard_layout_v<T>;
template<typename T> concept trivial = std::is_trivially_copyable_v<T>;

template<typename T> concept is_void = same_as<remove_cv<T>, void>;
template<typename T> concept is_bool = same_as<remove_cv<T>, bool>;
template<typename T> concept is_none = same_as<remove_cv<T>, none>;
template<typename T> concept character = included_in<remove_cv<T>, cat1, cat2, uct1, uct2, uct4>;
template<typename T> concept integral = std::integral<remove_cv<T>>;
template<typename T> concept arithmetic = integral<T> || std::floating_point<T>;

namespace _ { template<typename T> struct _add_cv; }
template<typename T> using add_cv = typename _::_add_cv<T>::cv;
template<typename T> using add_const = typename _::_add_cv<T>::c;
template<typename T> using add_volatile = typename _::_add_cv<T>::v;
template<typename T> using add_lvref = std::add_lvalue_reference_t<T>;
template<typename T> using add_rvref = std::add_rvalue_reference_t<remove_ref<T>>;
template<typename T> using add_fwref = std::add_rvalue_reference_t<T>;
namespace _ { template<typename T> struct _add_pointer : t_type<T> {}; }
template<typename T> using add_pointer = typename _::_add_pointer<T>::type;
namespace _ { template<typename T, nat N> struct _add_extent : t_type<T> {}; }
template<typename T, nat N> using add_extent = typename _::_add_extent<T, N>::type;

inline consteval auto cev(auto a) noexcept { return a; }
inline consteval auto arraysize(const is_bounded_array auto& Array) noexcept { return std::extent_v<remove_ref<decltype(Array)>>; }

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreturn-type"
template<typename T> inline constexpr auto declval = []() noexcept -> add_fwref<T> {};
#pragma clang diagnostic pop

template<typename T> concept destructible = requires { requires std::is_destructible_v<T>; };
template<typename T> concept nt_destructible = destructible<T> && std::destructible<T>;
template<typename T, typename A> concept assignable = requires { requires std::is_assignable_v<T, A>; };
template<typename T, typename A> concept nt_assignable = assignable<T, A> && requires { requires std::is_nothrow_assignable_v<T, A>; };
template<typename T, typename... As> concept constructible = requires { T{declval<As>()...}; };
template<typename T, typename... As> concept nt_constructible = constructible<T, As...> && requires { { T{declval<As>()...} } noexcept; };
template<typename T, typename U = T> concept exchangeable = constructible<remove_cvref<T>, add_rvref<T>> && assignable<T, U>;
template<typename T, typename U = T> concept nt_exchangeable = nt_constructible<remove_cvref<T>, add_rvref<T>> && nt_assignable<T, U>;

/// returns the address of `Ref`.
inline constexpr auto addressof = []<is_lvref T>(T&& Ref)
  noexcept { return __builtin_addressof(Ref); };
/// returns `Ref` as const reference.
inline constexpr auto asconst = []<typename T>(T&& Ref)
  noexcept -> add_const<T&&> { return Ref; };
/// moves `Ref`.
inline constexpr auto mv = []<typename T>(T&& Ref) noexcept
  -> decltype(auto) { return static_cast<add_rvref<T>>(Ref); };
/// forwards `Ref` as `T`.
template<typename T> inline constexpr auto fwd = [](auto&& Ref) noexcept
  -> decltype(auto) { return static_cast<T&&>(Ref); };
/// constructs an object of type `T` with `Args`.
template<typename T> inline constexpr auto construct =
  []<typename... Ts>(Ts&&... Args) noexcept(nt_constructible<T, Ts...>)
  -> T requires constructible<T, Ts...> { return T{fwd<Ts>(Args)...}; };
/// assigns `Rhs` to `Lhs`.
inline constexpr auto assign = []<typename L, typename R>(L&& Lhs, R&& Rhs)
  noexcept(nt_assignable<L, R>) -> decltype(auto)
  requires assignable<L, R> { return fwd<L>(Lhs) = fwd<R>(Rhs); };
/// sets `Ref` to `Value` and returns the original value of `Ref`.
inline constexpr auto exchange = []<typename T, typename U = T>(T& Ref, U&& Value)
  noexcept(nt_exchangeable<T&, U>) -> T
  requires exchangeable<T&, U> { auto a = mv(Ref); Ref = fwd<U>(Value); return a; };

/// checks `I` is less than `N` if `decltype(I)` is not `bool`; otherwise, checks `N` is 2.
template<convertible_to<nat> auto I, nat N> inline constexpr bool selectable =
  (is_bool<decltype(I)> && N == 2) || (!is_bool<decltype(I)> && static_cast<nat>(I) < N);
namespace _ { template<typename T, T I, typename... Ts> struct _select_type; }
/// selects a type from `Ts...` by `I`.
template<convertible_to<nat> auto I, typename... Ts> requires selectable<I, sizeof...(Ts)>
using select_type = typename _::_select_type<decltype(I), I, Ts...>::type;
/// selects a value from `Vs...` by `I`.
template<convertible_to<nat> auto I, auto... Vs> requires selectable<I, sizeof...(Vs)>
inline constexpr auto select_value = select_type<I, constant<Vs>...>::value;
/// selects a parameter from `Refrg` and `Refrgs...` by `I`.
template<convertible_to<nat> auto I> inline constexpr auto select_parameter =
  []<typename A, typename... As>(A&& Arg, As&&... Args) noexcept
  -> decltype(auto) requires selectable<I, 1 + sizeof...(As)> {
  if constexpr (is_bool<decltype(I)>) return select_parameter<nat(!I)>(fwd<A>(Arg), fwd<As>(Args)...);
  else if constexpr (same_as<decltype(I), nat>) {
    if constexpr (I == 0) return fwd<A>(Arg);
    else return select_parameter<I - 1>(fwd<As>(Args)...);
  } else return select_parameter<nat(I)>(fwd<A>(Arg), fwd<As>(Args)...);
};

/// function object type to pass a value as is.
struct pass { template<typename T> constexpr T&& operator()(T&& a) const noexcept { return static_cast<T&&>(a); } };
/// function object type which can be overloaded.
template<typename... Fs> struct overload : public Fs... { using Fs::operator()...; };
/// returns the number of `true` in `Bs...`.
template<bool... Bs> inline constexpr nat counts = (nat(0) + ... + Bs);
/// returns the index of the first `true` in `Bs...`.
template<bool... Bs> inline constexpr nat inspects = 0;
template<bool B, bool... Bs> inline constexpr nat inspects<B, Bs...> = B ? 0 : 1 + inspects<Bs...>;

template<typename T, typename Src> using copy_const = select_type<is_const<Src>, add_const<T>, T>;
template<typename T, typename Src> using copy_volatile = select_type<is_volatile<Src>, add_volatile<T>, T>;
template<typename T, typename Src> using copy_cv = copy_const<copy_volatile<T, Src>, Src>;
namespace _ { template<typename T, typename Src> struct _copy_reference; }
template<typename T, typename Src> using copy_reference = typename _::_copy_reference<T, Src>::type;
template<typename T, typename Src> using copy_cvref = copy_reference<copy_cv<T, Src>, Src>;
namespace _ { template<typename T, typename Src> struct _copy_extent : t_type<T> {}; }
template<typename T, typename Src> using copy_extent = typename _::_copy_extent<T, Src>::type;
template<typename T, typename Src> using copy_pointer = select_type<is_pointer<Src>, copy_cv<add_pointer<T>, Src>, T>;

/// checks if `F` is invocable with `As...`.
template<typename F, typename... As> concept invocable = std::invocable<F, As...>;
/// checks if `F` is invocable with `As...` without throwing exceptions.
template<typename F, typename... As> concept nt_invocable =
  invocable<F, As...> && requires { requires std::is_nothrow_invocable_v<F, As...>; };
/// return type of `yw::invoke(F, As...)`.
template<typename F, typename... As> using invoke_result =
  select_type<is_void<std::invoke_result_t<F, As...>>, none, std::invoke_result_t<F, As...>>;
/// checks if `F` is invocable with `As...` and returns `R`.
template<typename F, typename R, typename... As> concept invocable_r =
  invocable<F, As...> && convertible_to<invoke_result<F, As...>, R>;
/// checks if `F` is invocable with `As...` and returns `R` without throwing exceptions.
template<typename F, typename R, typename... As> concept nt_invocable_r =
  nt_invocable<F, As...> && nt_convertible_to<invoke_result<F, As...>, R>;
/// checks if `F` is a predicate with `As...`.
template<typename F, typename... As> concept predicate = invocable_r<F, bool, As...>;
/// invokes `Func` with `Args...`.
/// \return `none{}` if `Func` returns `void`; otherwise, returns the result of `Func`.
inline constexpr auto invoke = []<typename F, typename... As>(F&& Func, As&&... Args)
  noexcept(nt_invocable<F, As...>) -> invoke_result<F, As...> requires invocable<F, As...> {
  if constexpr (is_void<std::invoke_result_t<F, As...>>) return std::invoke(fwd<F>(Func), fwd<As>(Args)...), none{};
  else return std::invoke(fwd<F>(Func), fwd<As>(Args)...); };
/// invokes `Func` with `Args...` and returns the result as `R`.
template<typename R> inline constexpr auto invoke_r = []<typename F, typename... As>(F&& f, As&&... as)
  noexcept(nt_invocable_r<F, R, As...>) -> R requires invocable_r<F, R, As...> {
  return static_cast<R>(invoke(fwd<F>(f), fwd<As>(as)...)); };

namespace _ { template<typename... Ts> struct _common_type : t_type<none> {}; }
/// returns the common type of `Ts...` if it exists; otherwise, returns `none`.
template<typename... Ts> using common_type = typename _::_common_type<Ts...>::type;
/// checks if `Ts...` have a common type except `none`.
template<typename... Ts> concept common_with = requires {
  requires !is_none<common_type<Ts...>>;
  requires (std::common_reference_with<common_type<Ts...>, Ts> && ...); };

namespace _ { template<typename T, template<typename...> typename Tm> struct _specialization_of : constant<false> {}; }
/// checks if `T` is a specialization of `Tm`.
template<typename T, template<typename...> typename Tm> concept specialization_of = _::_specialization_of<T, Tm>::value;
namespace _ { template<typename T, typename U> struct _variation_of : constant<false> {}; }
/// checks if `T` is a variation of `U`.
/// \example `std::array<int, 4>` is a variation of `std::array<double, 3>`.
template<typename T, typename U> concept variation_of = _::_variation_of<T, U>::value;

/// function object to compare two values.
inline constexpr auto eq = [](auto&& a, auto&& b) noexcept(noexcept(bool(a == b)))
  -> bool requires requires { { a == b } -> convertible_to<bool>; } { return a == b; };
/// function object to compare two values.
inline constexpr auto ne = [](auto&& a, auto&& b) noexcept(noexcept(bool(a != b)))
  -> bool requires requires { { a != b } -> convertible_to<bool>; } { return a != b; };
/// function object to compare two values.
inline constexpr auto lt = [](auto&& a, auto&& b) noexcept(noexcept(bool(a < b), 1 > 0))
  -> bool requires requires { { a < b } -> convertible_to<bool>; } { return a < b; };
/// function object to compare two values.
inline constexpr auto le = [](auto&& a, auto&& b) noexcept(noexcept(bool(a <= b), 1 > 0))
  -> bool requires requires { { a <= b } -> convertible_to<bool>; } { return a <= b; };
/// function object to compare two values.
inline constexpr auto gt = [](auto&& a, auto&& b) noexcept(noexcept(bool(a > b)))
  -> bool requires requires { { a > b } -> convertible_to<bool>; } { return a > b; };
/// function object to compare two values.
inline constexpr auto ge = [](auto&& a, auto&& b) noexcept(noexcept(bool(a >= b)))
  -> bool requires requires { { a >= b } -> convertible_to<bool>; } { return a >= b; };
/// function object type to compare two values.
using equal = decltype(eq);
/// function object type to compare two values.
using not_equal = decltype(ne);
/// function object type to compare two values.
using less = decltype(lt);
/// function object type to compare two values.
using less_equal = decltype(le);
/// function object type to compare two values.
using greater = decltype(gt);
/// function object type to compare two values.
using greater_than = decltype(gt);

template<trivial T> inline constexpr auto bitcast = [](const trivial auto& Ref) noexcept
  requires (sizeof(T) == sizeof(Ref)) { return __builtin_bit_cast(T, Ref); };
inline constexpr auto bitcount = [](const nat Value) noexcept -> nat { return std::popcount(Value); };
inline constexpr auto bitfloor = [](const nat Value) noexcept -> nat { return std::bit_floor(Value); };
inline constexpr auto bitceil = [](const nat Value) noexcept -> nat { return std::bit_ceil(Value); };
inline constexpr auto bitwidth = [](const nat Value) noexcept -> nat { return std::bit_width(Value); };

namespace _ {
template<is_pointer T> struct _remove_all_pointers<T> : _remove_all_pointers<remove_pointer<T>> {};
template<typename M, typename C> struct _member_type<M C::*> { using m = M; using c = C; };
template<typename T> struct _add_cv { using cv = const volatile T; using c = const T; using v = volatile T; };
template<typename T> struct _add_cv<T&> { using cv = const volatile T&; using c = const T&; using v = volatile T&; };
template<typename T> struct _add_cv<T&&> { using cv = const volatile T&&; using c = const T&&; using v = volatile T&&; };
template<typename T> requires valid<T*> struct _add_pointer<T> : t_type<T*> {};
template<typename T> requires valid<T*> struct _add_pointer<T&> : t_type<T*&> {};
template<typename T> requires valid<T*> struct _add_pointer<T&&> : t_type<T*&&> {};
template<typename T, nat N> requires valid<T[N]> struct _add_extent<T, N> : t_type<T[N]> {};
template<typename T, nat N> requires valid<T[N]> struct _add_extent<T&, N> : t_type<T(&)[N]> {};
template<typename T, nat N> requires valid<T[N]> struct _add_extent<T&&, N> : t_type<T(&&)[N]> {};
template<typename T> requires valid<T[]> struct _add_extent<T, 0> : t_type<T[]> {};
template<typename T> requires valid<T[]> struct _add_extent<T&, 0> : t_type<T(&)[]> {};
template<typename T> requires valid<T[]> struct _add_extent<T&&, 0> : t_type<T(&&)[]> {};
template<typename T, T I, typename... Ts> struct _select_type : _select_type<nat, I, Ts...> {};
template<bool B, typename Tt, typename Tf> struct _select_type<bool, B, Tt, Tf> : std::conditional<B, Tt, Tf> {};
template<nat I, typename T, typename... Ts> struct _select_type<nat, I, T, Ts...> : _select_type<nat, I - 1, Ts...> {};
template<typename T, typename... Ts> struct _select_type<nat, 0, T, Ts...> : t_type<T> {};
template<typename T, typename U> struct _copy_reference : t_type<remove_ref<T>> {};
template<typename T, typename U> struct _copy_reference<T, U&> : t_type<add_lvref<T>> {};
template<typename T, typename U> struct _copy_reference<T, U&&> : t_type<add_rvref<T>> {};
template<typename T, is_array U> struct _copy_extent<T, U> : t_type<add_extent<T, std::extent_v<U>>> {};
template<typename... Ts> requires valid<std::common_reference_t<Ts...>> struct _common_type<Ts...> : std::common_reference<Ts...> {};
template<template<typename...> typename Tm, typename... Ts> struct _specialization_of<Tm<Ts...>, Tm> : constant<true> {};
template<template<typename...> typename Tm, typename... Ts, typename... Us> struct _variation_of<Tm<Ts...>, Tm<Us...>> : constant<true> {};
template<template<auto...> typename Tm, auto... Vs, auto... Ws> struct _variation_of<Tm<Vs...>, Tm<Ws...>> : constant<true> {};
template<template<typename, auto...> typename Tm, typename T, typename U, auto... Vs, auto... Ws> struct _variation_of<Tm<T, Vs...>, Tm<U, Ws...>> : constant<true> {};
template<template<auto, typename...> typename Tm, auto V, auto W, typename... Ts, typename... Us> struct _variation_of<Tm<V, Ts...>, Tm<W, Us...>> : constant<true> {};
}
}

namespace yw { // Tuple Definitions

namespace _::_get {
template<nat I> void get(auto&&) = delete;
template<nat I, typename T> inline constexpr auto pattern = []() -> int {
  if constexpr (is_bounded_array<remove_ref<T>>) return I < std::extent_v<remove_ref<T>> ? 16 : 8;
  else if constexpr (requires { get<I>(declval<T>()); }) return 1 | noexcept(get<I>(declval<T>())) * 16;
  else if constexpr (requires { declval<T>().template get<I>(); }) return 2 | noexcept(declval<T>().template get<I>()) * 16;
  else return I == 0 ? 20 : 8; }();
template<nat I, typename T, nat P = pattern<I, T>> requires(P != 8) constexpr decltype(auto) call(T&& A) noexcept(bool(P & 16)) {
  if constexpr ((P & 7) == 0) return static_cast<T&&>(A)[I];
  else if constexpr ((P & 7) == 1) return get<I>(static_cast<T&&>(A));
  else if constexpr ((P & 7) == 2) return static_cast<T&&>(A).template get<I>();
  else if constexpr ((P & 7) == 4) return static_cast<T&&>(A); }
template<typename T, nat I = (pattern<0, T> & 15)> struct extent : std::tuple_size<T> {};
template<typename T> struct extent<T, 0> : std::extent<remove_ref<T>> {};
template<typename T> struct extent<T, 4> : constant<1> {};
}

template<auto... Vs> struct sequence;
template<typename... Ts> struct typepack;
template<typename... Ts> struct list;

/// returns the number of elements in `T`.
template<typename T> inline constexpr nat extent = _::_get::extent<remove_ref<T>>::value;
/// checks if all of `Ts...` have the same number of elements as `T`.
template<typename T, typename... Ts> concept same_extent = ((extent<T> == extent<Ts>) && ...);
/// checks if `T` is a tuple-like type.
template<typename T> concept tuple = requires { requires (_::_get::pattern<0, T> & 15) < 3; };
/// checks if `yw::get<I>(T)` returns the element at index `I` of `T`.
template<typename T, nat I> concept gettable = requires { _::_get::call<I>(declval<T>()); };
/// checks if `yw::get<I>(T)` returns the element at index `I` of `T` without throwing exceptions.
template<typename T, nat I> concept nt_gettable = gettable<T, I> && requires { { _::_get::call<I>(declval<T>()) } noexcept; };
/// returns the type of the element at index `I` of `T`.
template<typename T, nat I> requires gettable<T, I> using element_t = decltype(_::_get::call<I>(declval<T>()));
/// returns the the element at index `I` of `T`.
template<nat I> inline constexpr auto get = []<gettable<I> T>(T&& Ref)
  noexcept(nt_gettable<T, I>) -> element_t<T, I> { return _::_get::call<I>(static_cast<T&&>(Ref)); };

/// index sequence type
template<nat... Is> using indices = sequence<Is...>;
namespace _ { template<typename S, typename T> struct _to_sequence : t_type<none> {}; }
/// converts `S` to a `yw::sequence`.
template<typename S, typename T = none> using to_sequence = typename _::_to_sequence<S, T>::type;
/// checks if `S` is a sequence-like type.
template<typename S, typename T = none> concept sequence_of = variation_of<to_sequence<S, T>, sequence<>>;
namespace _ { template<typename S, nat N> struct _indices_for : constant<false> {}; }
/// checks if `S` is a sequence-like type whose all elements are convertible to `nat`.
template<typename S, typename T> concept indices_for = _::_indices_for<to_sequence<S>, extent<T>>::value;
namespace _ { template<nat I, nat N, auto F, nat... Vs> struct _make_sequence; }
/// creates a `yw::sequence` with the elements; `Proj(Begin)`, `Proj(Begin + 1)`, ..., `Proj(End - 1)`
template<nat Begin, nat End, invocable<nat> auto Proj = pass{}> requires (Begin <= End)
using make_sequence = typename _::_make_sequence<Begin, End, Proj>::type;
/// creates a indices for getting all elements of `T`.
template<typename Tp> using make_indices_for = make_sequence<0, extent<Tp>>;
namespace _ { template<nat I, nat N, typename S, nat... Is> struct _extracting_indices; }
/// creates a `yw::indices` with the indices which are `true` in `Sq`.
template<sequence_of<bool> Sq> using extracting_indices = typename _::_extracting_indices<0, extent<Sq>, Sq>::type;
namespace _ { template<typename T, typename S> struct _common_element; }
/// returns the common type of the elements of `T`.
template<typename T> using common_element = typename _::_common_element<T, make_indices_for<T>>::type;
namespace _ { template<typename T, typename S> struct _to_typepack; }
/// returns a `yw::typepack` which contains the types of the elements of `T`.
template<typename T> using to_typepack = typename _::_to_typepack<T, make_indices_for<T>>::type;
namespace _ { template<typename T, typename U, typename S> struct _tuple_for : constant<0> {}; }
/// checks if all elements of `T` are convertible to `U`.
template<typename T, typename U> concept tuple_for =
  requires { requires bool(_::_tuple_for<T, U, make_indices_for<T>>::value & 1); };
/// checks if all elements of `T` are convertible to `U` without throwing exceptions.
template<typename T, typename U> concept nt_tuple_for =
  tuple_for<T, U> && requires { requires bool(_::_tuple_for<T, U, make_indices_for<T>>::value & 2); };

/// struct to represent a sequence of values.
template<auto... Vs> struct sequence {
private:
  template<typename S> struct _append : _append<to_sequence<S, none>> {};
  template<auto... Ws> struct _append<sequence<Ws...>> : std::type_identity<sequence<Vs..., Ws...>> {};
  template<> struct _append<none> : std::type_identity<none> {};
  template<typename S> struct _extract : _extract<to_sequence<S, none>> {};
  template<nat... Is> struct _extract<sequence<Is...>> : std::type_identity<sequence<select_value<Is, Vs...>...>> {};
  template<> struct _extract<none> : std::type_identity<none> {};
public:
  /// the number of values in the sequence.
  static constexpr nat count = sizeof...(Vs);
  /// returns the value at index `I`.
  template<nat I> requires(lt(I, count)) static constexpr auto at = select_value<I, Vs...>;
  /// returns the type of value at index `I`.
  template<nat I> requires(lt(I, count)) using type_at = select_type<I, decltype(Vs)...>;
  /// returns a `yw::sequence` which contains `Vs...` and the values of `Sq`.
  template<sequence_of Sq> using append = typename _append<to_sequence<Sq>>::type;
  /// extracts the values at the indices of `Ind`.
  template<indices_for<sequence> Ind> using extract = typename _extract<to_sequence<Ind, nat>>::type;
  /// extracts the first `N` values.
  template<nat N> requires(N <= count) using fore = extract<make_sequence<0, N>>;
  /// extracts the last `N` values.
  template<nat N> requires(N <= count) using back = extract<make_sequence<count, count - N>>;
  /// inserts the values of `Sq` at index `I`.
  template<nat I, sequence_of Sq> requires(I < count)
  using insert = typename fore<I>::template append<Sq>::template append<back<count - I>>;
  /// expands the values to `Tm`.
  template<template<auto...> typename Tm> using expand = Tm<Vs...>;
  /// used by the customization point object `yw::get`.
  template<nat I> requires(I < count) constexpr const auto&& get() const noexcept { return mv(at<I>); }
};

/// struct to represent a pack of types.
template<typename... Ts> struct typepack {
private:
  template<typename T, typename U> struct t_append {};
  template<typename... Us, typename... Vs> struct t_append<typepack<Us...>, typepack<Vs...>> : t_type<typepack<Us..., Vs...>> {};
  template<typename T, typename S> struct t_extract {};
  template<typename... Us, nat... Is> struct t_extract<typepack<Us...>, sequence<Is...>> : t_type<typepack<select_type<Is, Us...>...>> {};
public:
  /// the number of types in the pack.
  static constexpr nat count = sizeof...(Ts);
  /// the common type of the types in the pack.
  using common = common_type<Ts...>;
  /// returns the type at index `I`.
  template<nat I> requires(I < count) using at = select_type<I, Ts...>;
  /// returns a `yw::typepack` which contains `Ts...` and the element types of `Tp`.
  template<tuple Tp> using append = typename t_append<typepack, to_typepack<Tp>>::type;
  /// extracts the types at the indices of `Sq`.
  template<indices_for<typepack> Sq> using extract = typename t_extract<typepack, to_sequence<Sq, nat>>::type;
  /// extracts the first `N` types.
  template<nat N> requires(N <= count) using fore = extract<make_sequence<0, N>>;
  /// extracts the last `N` types.
  template<nat N> requires(N <= count) using back = extract<make_sequence<count, count - N>>;
  /// inserts the types of `Tp` at index `I`.
  template<nat I, tuple T> requires(I < count)
  using insert = typename fore<I>::template append<T>::template append<back<count - I>>;
  /// expands the types to `Tm`.
  template<template<typename...> typename Tm> using expand = Tm<Ts...>;
  /// used by the customization point object `yw::get`.
  template<nat I> requires(I < count) constexpr at<I> get() const noexcept;
};

/// struct to represent a list of values.
template<typename... Ts> struct list : typepack<Ts...>::template fore<sizeof...(Ts) - 1>::template expand<list> {
  /// base class which contains the elements except the last one.
  using base = typepack<Ts...>::template fore<sizeof...(Ts) - 1>::template expand<list>;
  /// the number of elements in the list.
  static constexpr nat count = sizeof...(Ts);
  /// the type of the last element.
  using last_type = select_type<count - 1, Ts...>;
  /// the last element.
  last_type last;
  /// used by the customization point object `yw::get`.
  template<nat I> constexpr auto get() & noexcept -> select_type<I, Ts...>& {
    if constexpr (I == count - 1) return last;
    else return base::template get<I>();
  }
  /// used by the customization point object `yw::get`.
  template<nat I> constexpr auto get() const& noexcept -> add_const<select_type<I, Ts...>&> {
    if constexpr (I == count - 1) return last;
    else return base::template get<I>();
  }
  /// used by the customization point object `yw::get`.
  template<nat I> constexpr auto get() && noexcept -> select_type<I, Ts...>&& {
    if constexpr (I == count - 1) return fwd<last_type>(last);
    else return fwd<select_type<I, Ts...>>(base::template get<I>());
  }
  /// used by the customization point object `yw::get`.
  template<nat I> constexpr auto get() const&& noexcept -> add_const<select_type<I, Ts...>&&> {
    if constexpr (I == count - 1) return fwd<add_const<last_type>>(last);
    else return fwd<add_const<select_type<I, Ts...>>>(base::template get<I>());
  }
};

/// specialization of `yw::list` for three elements.
template<typename T1, typename T2, typename T3> struct list<T1, T2, T3> : list<T1, T2> {
  /// base class; `yw::list<T1, T2>`.
  using base = list<T1, T2>;
  /// the number of elements in the list.
  static constexpr nat count = 3;
  /// the type of the third element.
  using third_type = T3;
  /// the third element.
  third_type third;
  /// used by the customization point object `yw::get`.
  template<nat I> constexpr auto get() & noexcept -> select_type<I, T1, T2, T3>&
  { if constexpr (I == 2) return third; else return base::template get<I>(); }
  /// used by the customization point object `yw::get`.
  template<nat I> constexpr auto get() const& noexcept -> add_const<select_type<I, T1, T2, T3>&>
  { if constexpr (I == 2) return third; else return base::template get<I>(); }
  /// used by the customization point object `yw::get`.
  template<nat I> constexpr auto get() && noexcept -> select_type<I, T1, T2, T3>&&
  { if constexpr (I == 2) return fwd<T3>(third); else return fwd<select_type<I, T1, T2>>(base::template get<I>()); }
  /// used by the customization point object `yw::get`.
  template<nat I> constexpr auto get() const&& noexcept -> add_const<select_type<I, T1, T2, T3>&&>
  { if constexpr (I == 2) return fwd<add_const<T3>>(third);
    else return fwd<add_const<select_type<I, T1, T2>>>(base::template get<I>());
  }
};

/// specialization of `yw::list` for two elements.
template<typename T1, typename T2> struct list<T1, T2> : public list<T1> {
  /// base class; `yw::list<T1>`.
  using base = list<T1>;
  /// the number of elements in the list.
  static constexpr nat count = 2;
  /// the type of the second element.
  using second_type = T2;
  /// the second element.
  second_type second;
  /// used by the customization point object `yw::get`.
  template<nat I> constexpr auto get() & noexcept -> select_type<I, T1, T2>&
  { if constexpr (I == 1) return second; else return base::first; }
  /// used by the customization point object `yw::get`.
  template<nat I> constexpr auto get() const& noexcept -> add_const<select_type<I, T1, T2>&>
  { if constexpr (I == 1) return second; else return base::first; }
  /// used by the customization point object `yw::get`.
  template<nat I> constexpr auto get() && noexcept -> select_type<I, T1, T2>&&
  { if constexpr (I == 1) return fwd<T2>(second); else return fwd<T1>(base::first); }
  /// used by the customization point object `yw::get`.
  template<nat I> constexpr auto get() const&& noexcept -> add_const<select_type<I, T1, T2>&&>
  { if constexpr (I == 1) return fwd<add_const<T2>>(second); else return fwd<add_const<T1>>(base::first); }
};

/// specialization of `yw::list` for one element.
template<typename T> struct list<T> {
  /// the number of elements in the list.
  static constexpr nat count = 1;
  /// the type of the first element.
  using first_type = T;
  /// the first element.
  first_type first;
  /// used by the customization point object `yw::get`.
  template<nat I> requires(I == 0) constexpr T& get() & noexcept { return first; }
  /// used by the customization point object `yw::get`.
  template<nat I> requires(I == 0) constexpr add_const<T&> get() const& noexcept { return first; }
  /// used by the customization point object `yw::get`.
  template<nat I> requires(I == 0) constexpr T&& get() && noexcept { return fwd<T>(first); }
  /// used by the customization point object `yw::get`.
  template<nat I> requires(I == 0) constexpr add_const<T&&> get() const&& noexcept { return fwd<add_const<T>>(first); }
};

/// specialization of `yw::list` for no elements; used to some utility functions.
template<> struct list<> {
private:
  template<typename T, typename U, typename V> struct _from_typepack {};
  template<typename... Ts, typename U, template<typename...> typename Tm, typename... Vs> struct _from_typepack<typepack<Ts...>, U, Tm<Vs...>> : t_type<list<copy_cvref<Tm<Ts>, U>...>> {};
  template<typename... Ts, typename U, template<typename, auto...> typename Tm, typename V, auto... Vs> struct _from_typepack<typepack<Ts...>, U, Tm<V, Vs...>> : t_type<list<copy_cvref<Tm<Ts, Vs...>, U>...>> {};
  template<typename... Ts, typename U, typename V> struct _from_typepack<typepack<Ts...>, U, V> : t_type<list<copy_cvref<Ts, U>...>> {};
public:
  /// the number of elements in the list.
  static constexpr nat count = 0;
  /// returns a `yw::list` which contains the references to `Args...`.
  template<typename... Ts> static constexpr auto asref(Ts&&... Args)
    noexcept { return list<Ts&&...>{fwd<Ts>(Args)...}; }
  /// returns a `yw::list` which is specialized by the types of `Tp`.
  /// \tparam Tp a `yw::typepack` which contains the types.
  /// \tparam Qualifier (optional) used to qualify the types.
  /// \note `from_typepack<typepack<Ts...>, const array<int>&>` returns `list<const array<Ts>&...>`.
  template<specialization_of<typepack> Tp, typename Qualifier = none>
  using from_typepack = _from_typepack<Tp, Qualifier, remove_cvref<Qualifier>>::type;
};

template<typename... Ts> list(Ts...) -> list<Ts...>;

/// struct to create a virtual tuple-like object; arranging and/or projecting elements.
/// \note `projector(list{0, 1, 2, 3}, [](auto a){ return a * 2;}, sequence<2, 3, 1, 0>{})` is a tuple of `{4, 6, 2, 0}`.
template<typename T, typename Pj = pass, sequence_of<nat> Sq = make_indices_for<T>> struct projector {
  static_assert(to_sequence<Sq, nat>::count > 0);
  static_assert(!tuple<T> || indices_for<Sq, T>);
  /// indices to arrange the elements.
  using indices = to_sequence<Sq, nat>;
  /// `extent<projector>`
  static constexpr nat count = indices::count;
  /// reference to the object to project.
add_fwref<T> ref;
  /// function object for projection.
  remove_ref<Pj> proj = {};
  template<typename U = T> constexpr projector(U&& Ref, Pj p, Sq) noexcept(nt_constructible<Pj, Pj>) : ref(fwd<U>(Ref)), proj(mv(p)) {}
  template<typename U = T> constexpr projector(U&& Ref, Pj p) noexcept(nt_constructible<Pj, Pj>) : ref(fwd<U>(Ref)), proj(mv(p)) {}
  template<typename U = T> constexpr projector(U&& Ref, Sq) noexcept : ref(fwd<U>(Ref)) {}
  template<typename U = T> constexpr projector(U&& Ref) noexcept : ref(fwd<U>(Ref)) {}
  /// used by the customization point object `yw::get`.
  template<nat I> requires(I < count && tuple<T>) constexpr decltype(auto) get() const
    noexcept(nt_gettable<T, indices::template at<I>> && nt_invocable<Pj, element_t<T, indices::template at<I>>>)
    requires gettable<T, indices::template at<I>> && invocable<Pj, element_t<T, indices::template at<I>>>
  { return invoke(proj, yw::get<indices::template at<I>>(ref)); }
  /// used by the customization point object `yw::get`.
  template<nat I> requires(I < count && !tuple<T>) constexpr decltype(auto) get() const
    noexcept(nt_invocable<Pj, T>) requires invocable<Pj, T> { return invoke(proj, ref); }
};

template<typename T, typename Pj, sequence_of<nat> Sq> projector(T&&, Pj, Sq) -> projector<T, Pj, Sq>;
template<typename T, typename Pj> requires(!sequence_of<Pj, nat>) projector(T&&, Pj) -> projector<T, Pj>;
template<typename T, sequence_of<nat> Sq> projector(T&&, Sq) -> projector<T, pass, Sq>;
template<typename T> projector(T&&) -> projector<T>;

namespace _ {
template<template<auto...> typename Tm, typename T, auto... Vs> struct _to_sequence<Tm<Vs...>, T> : t_type<sequence<T(Vs)...>> {};
template<template<typename, auto...> typename Tm, typename T, typename U, auto... Vs> struct _to_sequence<Tm<U, Vs...>, T> : t_type<sequence<T(Vs)...>> {};
template<template<auto...> typename Tm, auto... Vs> struct _to_sequence<Tm<Vs...>, none> : t_type<sequence<Vs...>> {};
template<template<typename, auto...> typename Tm, typename U, auto... Vs> struct _to_sequence<Tm<U, Vs...>, none> : t_type<sequence<Vs...>> {};
template<nat... Is, nat N> struct _indices_for<sequence<Is...>, N> : constant<(lt(Is, N) && ...)> {};
template<nat I, nat N, auto F, nat... Vs> struct _make_sequence : _make_sequence<I + 1, N, F, Vs..., F(I)> {};
template<nat N, auto F, nat... Vs> struct _make_sequence<N, N, F, Vs...> : t_type<sequence<Vs...>> {};
template<nat I, nat N, bool... Bs, nat... Is> struct _extracting_indices<I, N, sequence<Bs...>, Is...>
  : select_type<select_value<I, Bs...>, _extracting_indices<I + 1, N, sequence<Bs...>, Is..., I>, _extracting_indices<I + 1, N, sequence<Bs...>, Is...>> {};
template<nat N, bool... B, nat... Is> struct _extracting_indices<N, N, sequence<B...>, Is...> : t_type<sequence<Is...>> {};
template<typename T, nat... Is> struct _common_element<T, sequence<Is...>> : _common_type<element_t<T, Is>...> {};
template<typename T, nat... Is> struct _to_typepack<T, sequence<Is...>> : t_type<typepack<element_t<T, Is>...>> {};
template<typename T, typename U, nat... Is> struct _tuple_for<T, U, sequence<Is...>>
  : constant<int((convertible_to<element_t<T, Is>, U> && ...)) + 2 * int((nt_convertible_to<element_t<T, Is>, U> && ...))> {};
template<typename F, typename... Ts> requires (!(tuple<Ts> || ...)) constexpr decltype(auto) _apply(F&& f, Ts&&... ts)
  noexcept(nt_invocable<F, Ts...>) requires invocable<F, Ts...> { return invoke(fwd<F>(f), fwd<Ts>(ts)...); }
template<nat I, nat... Is, nat... Js, nat... Ks, typename F, typename... Ts> constexpr decltype(auto) _apply_b(sequence<Is...>, sequence<Js...>, sequence<Ks...>, F&& f, Ts&&... ts)
  ywlib_wrapper(_apply(fwd<F>(f), select_parameter<Is>(fwd<Ts>(ts)...)..., get<Js>(fwd<select_type<I, Ts...>>(select_parameter<I>(fwd<Ts>(ts)...)))..., select_parameter<Ks>(fwd<Ts>(ts)...)...));
template<nat I, typename F, typename... Ts> constexpr decltype(auto) _apply_a(F&& f, Ts&&... ts)
  ywlib_wrapper(_apply_b<I>(make_sequence<0, I>{}, make_indices_for<select_type<I, Ts...>>{}, make_sequence<I + 1, sizeof...(Ts)>{}, fwd<F>(f), fwd<Ts>(ts)...));
template<typename F, typename... Ts> requires (tuple<Ts> || ...) constexpr decltype(auto) _apply(F&& f, Ts&&... ts)
  ywlib_wrapper(_apply_a<inspects<tuple<Ts>...>>(fwd<F>(f), fwd<Ts>(ts)...));
template<nat I, typename F, typename... Ts> constexpr decltype(auto) _vapply_i(F&& f, Ts&&... ts)
  noexcept(nt_invocable<F, element_t<Ts, I>...>) requires invocable<F, element_t<Ts, I>...> { return invoke(fwd<F>(f), get<I>(fwd<Ts>(ts))...); }
template<nat... Is, typename F, typename... Ts> constexpr decltype(auto) _vapply_is(sequence<Is...>, F&& f, Ts&&... ts)
  ywlib_wrapper(list{_vapply_i<Is>(fwd<F>(f), fwd<Ts>(ts)...)...});
template<typename F, typename T, typename... Ts> requires same_extent<T, Ts...> constexpr decltype(auto) _vapply(F&& f, T&& t, Ts&&... ts)
  ywlib_wrapper(_vapply_is(make_indices_for<T>(), fwd<F>(f), fwd<T>(t), fwd<Ts>(ts)...));
template<typename F, typename T, typename... Ts> requires (!same_extent<T, Ts...> && tuple<T> && (tuple<Ts> && ...)) void _vapply(F&& f, T&& t, Ts&&... ts) = delete;
template<typename F, typename... Ts> requires (!(tuple<Ts> || ...)) void _vapply(F&& f, Ts&&... ts) = delete;
template<nat I, nat N, nat... Is, nat... Js, typename F, typename... Ts> constexpr decltype(auto) _vapply_b(sequence<Is...>, sequence<Js...>, F&& f, Ts&&... ts)
  ywlib_wrapper(_vapply(fwd<F>(f), select_parameter<Is>(fwd<Ts>(ts)...)..., projector(select_parameter<I>(fwd<Ts>(ts)...), make_sequence<0, N>{}), select_parameter<Js>(fwd<Ts>(ts)...)...));
template<nat I, nat J, typename F, typename... Ts> constexpr decltype(auto) _vapply_a(F&& f, Ts&&... ts)
  ywlib_wrapper(_vapply_b<I, extent<select_type<J, Ts...>>>(make_sequence<0, I>{}, make_sequence<I + 1, sizeof...(Ts)>{}, fwd<F>(f), fwd<Ts>(ts)...));
template<typename F, typename... Ts> requires (!(tuple<Ts> && ...) && (tuple<Ts> || ...)) constexpr decltype(auto) _vapply(F&& f, Ts&&... ts)
  ywlib_wrapper(_vapply_a<inspects<!tuple<Ts>...>, inspects<tuple<Ts>...>>(fwd<F>(f), fwd<Ts>(ts)...));
}

/// checks if `F` is applyable to `Ts...`.
template<typename F, typename... Ts> concept applyable =
  requires(F&& f, Ts&&... ts) { { _::_apply(fwd<F>(f), fwd<Ts>(ts)...) }; };
/// checks if `F` is applyable to `Ts...` without throwing exceptions.
template<typename F, typename... Ts> concept nt_applyable =
  applyable<F, Ts...> && requires(F&& f, Ts&&... ts) { { _::_apply(fwd<F>(f), fwd<Ts>(ts)...) } noexcept; };
/// returns the result type of `yw::apply(F, Ts...)`.
template<typename F, typename... Ts> using apply_result = decltype(_::_apply(declval<F>(), declval<Ts>()...));
/// invokes `Func` to `Args...` with tuple-like objects expanded.
inline constexpr auto apply = []<typename F, typename... Ts>(F&& Func, Ts&&... Args)
  noexcept(nt_applyable<F, Ts...>) requires applyable<F, Ts...> { return _::_apply(fwd<F>(Func), fwd<Ts>(Args)...); };
/// checks if `T` is constructible from the elements of `Tp`.
template<typename T, typename Tp> concept buildable = applyable<decltype(construct<T>), Tp>;
/// checks if `T` is constructible from the elements of `Tp` without throwing exceptions.
template<typename T, typename Tp> concept nt_buildable = nt_applyable<decltype(construct<T>), Tp>;
/// constructs an object of `T` from the elements of `Tp`.
template<typename T> inline constexpr auto build = []<typename Tp>(Tp&& Tuple)
  noexcept(nt_buildable<T, Tp>) requires buildable<T, Tp> { return apply(construct<T>, fwd<Tp>(Tuple)); };
/// checks if `F` is vapplyable to `T, Ts...`.
template<typename T, typename... Ts> concept vapplyable = requires(T&& t, Ts&&... ts) { { _::_vapply(fwd<T>(t), fwd<Ts>(ts)...) }; };
/// checks if `F` is vapplyable to `T, Ts...` without throwing exceptions.
template<typename T, typename... Ts> concept nt_vapplyable =
  vapplyable<T, Ts...> && requires(T&& t, Ts&&... ts) { { _::_vapply(fwd<T>(t), fwd<Ts>(ts)...) } noexcept; };
/// returns the result type of `yw::vapply(F, T, Ts...)`.
template<typename T, typename... Ts> using vapply_result = decltype(_::_vapply(declval<T>(), declval<Ts>()...));
/// invokes `Func` to `T` and `Args...` with tuple-like objects vertically expanded.
inline constexpr auto vapply = []<typename F, typename... Ts>(F&& f, Ts&&... ts)
  noexcept(nt_vapplyable<F, Ts...>) requires vapplyable<F, Ts...> { return _::_vapply(fwd<F>(f), fwd<Ts>(ts)...); };
/// checks if the elements of `Lt` are assignable from the elements of `Rt`.
template<typename Lt, typename Rt> concept vassignable = tuple<Lt> && vapplyable<decltype(assign), Lt, Rt>;
/// checks if the elements of `Lt` are assignable from the elements of `Rt` without throwing exceptions.
template<typename Lt, typename Rt> concept nt_vassignable = tuple<Lt> && nt_vapplyable<decltype(assign), Lt, Rt>;
/// assigns the elements of `R` to the elements of `L`.
inline constexpr auto vassign = []<typename Lt, typename Rt>(Lt&& L, Rt&& R)
  noexcept(nt_vassignable<Lt, Rt>) requires vassignable<Lt, Rt> { return vapply(assign, fwd<Lt>(L), fwd<Rt>(R)); };

/// struct to overload conversion operators.
template<typename... Fs> struct caster : public Fs... {
private:
  template<typename T> static constexpr nat i = []<typename... Ts>(typepack<Ts...>) { return inspects<same_as<Ts, T>...>; }(typepack<invoke_result<Fs>...>{});
  template<typename T> static constexpr nat j = i<T> < sizeof...(Fs) ? i<T> : []<typename... Ts>(typepack<Ts...>) { return inspects<convertible_to<Ts, T>...>; }(typepack<invoke_result<Fs>...>{});
  template<typename... As> static constexpr nat k = inspects<invocable<Fs, As...>...>;
public:
  using Fs::operator()...;
  template<typename T> requires(j<T> < sizeof...(Fs)) constexpr operator T() const
    noexcept(nt_convertible_to<invoke_result<select_type<j<T>, Fs...>>, T>)
    requires convertible_to<invoke_result<select_type<j<T>, Fs...>>, T> {
    return mv(select_type<j<T>, Fs...>::operator()());
  }
  template<typename... As> requires(k<As...> != sizeof...(Fs)) constexpr auto operator()(As&&... Args) const
    noexcept(nt_invocable<select_type<k<As...>, Fs...>, As...>)
    -> invoke_result<select_type<k<As...>, Fs...>> {
    return select_type<k<As...>, Fs...>::operator()(fwd<As>(Args)...);
  }
};

/// checks if this is converted to `bool` in constant evaluation.
inline constexpr caster is_cev{[]() noexcept { return std::is_constant_evaluated(); }};

/// function object type to calculate the maximum or minimum value.
template<bool Max> struct t_max {
  constexpr none operator()() const noexcept { return {}; }
  template<typename T> constexpr T operator()(T&& t) const noexcept { return t; }
  template<typename T0, typename T1, typename... Ts> constexpr auto operator()(T0&& t0, T1&& t1, Ts&&... ts) const
    -> common_type<T0, T1, Ts...> { return (*this)(call<common_type<T0, T1, Ts...>>(t0, t1), ts...); }
  template<typename F, typename T, typename... Ts> constexpr auto operator()(F&& f, T&& t, Ts&&... ts) const
    -> common_type<invoke_result<F&, T>, invoke_result<F&, Ts>...> { return (*this)(invoke(f, t), invoke(f, ts)...); }
private:
  template<typename R> static constexpr auto call(auto&& t, auto&& u) -> R { if constexpr (Max) return t < u ? u : t; else return u < t ? u : t; }
};

/// function object to calculate the maximum value.
inline constexpr t_max<1> max;
/// function object to calculate the minimum value.
inline constexpr t_max<0> min;

/// function object type to returns the index of the maximum or minimum value.
template<bool Max> struct t_maxi {
  constexpr list<nat, none> operator()() const noexcept { return list<nat, none>{}; }
  template<typename T> constexpr list<nat, remove_ref<T>> operator()(T&& t) const noexcept { return {0, fwd<T>(t)}; }
  template<typename T0, typename T1, typename... Ts> constexpr list<nat, remove_ref<common_type<T0, T1, Ts...>>> operator()(T0&& t0, T1&& t1, Ts&&... ts)
    const { return call<1>(list<>::asref(t0, t1, ts...), list<nat, remove_ref<common_type<T0, T1, Ts...>>>{0, fwd<T0>(t0)}); }
private:
  template<nat I, typename Tp, typename R> static constexpr auto call(Tp&& L, R M) {
    if constexpr (I == extent<Tp>) return mv(M);
    else { if constexpr (Max) { if (M.second < get<I>(L)) return call<I + 1>(fwd<Tp>(L), R{I, get<I>(L)}); else return call<I + 1>(fwd<Tp>(L), mv(M)); }
           else {               if (M.second > get<I>(L)) return call<I + 1>(fwd<Tp>(L), R{I, get<I>(L)}); else return call<I + 1>(fwd<Tp>(L), mv(M)); } } }
};

/// function object to returns the index of the maximum value.
inline constexpr t_maxi<1> maxi;
/// function object to returns the index of the minimum value.
inline constexpr t_maxi<0> mini;
}

namespace yw { // Range Definitions

template<typename It> concept iterator = std::input_or_output_iterator<It>;
template<typename Se, typename It> concept sentinel_for = std::sentinel_for<Se, It>;
template<typename Se, typename It> concept sized_sentinel_for = std::sized_sentinel_for<Se, It>;
template<typename Rg> concept range = std::ranges::range<Rg>;
template<typename Rg> concept borrowed_range = std::ranges::borrowed_range<Rg>;
template<typename Rg> concept sized_range = std::ranges::sized_range<Rg>;
template<range Rg> using iterator_t = std::ranges::iterator_t<Rg>;
template<range Rg> using borrowed_iterator_t = std::ranges::borrowed_iterator_t<Rg>;
template<range Rg> using sentinel_t = std::ranges::sentinel_t<Rg>;
namespace _ { template<typename T> struct _iter_t {}; }
template<typename T> requires iterator<T> || range<T> using iter_value = typename _::_iter_t<T>::v;
template<typename T> requires iterator<T> || range<T> using iter_difference = typename _::_iter_t<T>::d;
template<typename T> requires iterator<T> || range<T> using iter_reference = typename _::_iter_t<T>::r;
template<typename T> requires iterator<T> || range<T> using iter_rvref = typename _::_iter_t<T>::rr;
template<typename T> requires iterator<T> || range<T> using iter_common = common_type<iter_reference<T>, iter_value<T>>;
template<typename It, typename T> concept output_iterator = std::output_iterator<It, T>;
template<typename It> concept input_iterator = std::input_iterator<It>;
template<typename It> concept fwd_iterator = std::forward_iterator<It>;
template<typename It> concept bid_iterator = std::bidirectional_iterator<It>;
template<typename It> concept rnd_iterator = std::random_access_iterator<It>;
template<typename It> concept cnt_iterator = std::contiguous_iterator<It>;
template<typename It, typename U> concept iterator_for = iterator<It> && convertible_to<iter_reference<It>, U>;
template<typename It, typename U> concept cnt_iterator_of = cnt_iterator<It> && same_as<remove_ref<iter_reference<It>>, U>;
template<typename Rg, typename T> concept output_range = std::ranges::output_range<Rg, T>;
template<typename Rg> concept input_range = std::ranges::input_range<Rg>;
template<typename Rg> concept fwd_range = std::ranges::forward_range<Rg>;
template<typename Rg> concept bid_range = std::ranges::bidirectional_range<Rg>;
template<typename Rg> concept rnd_range = std::ranges::random_access_range<Rg>;
template<typename Rg> concept cnt_range = std::ranges::contiguous_range<Rg>;
template<typename Rg, typename U> concept range_for = iterator_for<iterator_t<Rg>, U>;
template<typename Rg, typename U> concept cnt_range_of = cnt_range<Rg> && same_as<iter_value<iterator_t<Rg>>, U>;
template<typename Rg> concept cnt_sized_range = cnt_range<Rg> && sized_range<Rg>;
template<typename Rg, typename U> concept cnt_sized_range_of = cnt_sized_range<Rg> && cnt_range_of<Rg, U>;
template<typename It, typename In> concept iter_copyable = iterator<It> && iterator<In> && std::indirectly_copyable<In, It>;
template<typename It, typename In> concept iter_movable = iterator<It> && iterator<In> && std::indirectly_movable<In, It>;
template<typename Fn, typename It> concept iter_unary_invocable = iterator<It> && std::indirectly_unary_invocable<Fn, It>;
template<typename Fn, typename It> concept iter_unary_predicate = iterator<It> && std::indirect_unary_predicate<Fn, It>;
inline constexpr auto begin = []<range Rg>(Rg&& r) ywlib_wrapper(std::ranges::begin(fwd<Rg>(r)));
inline constexpr auto end = []<range Rg>(Rg&& r) ywlib_wrapper(std::ranges::end(fwd<Rg>(r)));
inline constexpr auto rbegin = []<range Rg>(Rg&& r) ywlib_wrapper(std::ranges::rbegin(fwd<Rg>(r)));
inline constexpr auto rend = []<range Rg>(Rg&& r) ywlib_wrapper(std::ranges::rend(fwd<Rg>(r)));
inline constexpr auto size = []<range Rg>(Rg&& r) ywlib_wrapper(std::ranges::size(fwd<Rg>(r)));
inline constexpr auto empty = []<range Rg>(Rg&& r) ywlib_wrapper(std::ranges::empty(fwd<Rg>(r)));
inline constexpr auto data = []<range Rg>(Rg&& r) ywlib_wrapper(std::ranges::data(fwd<Rg>(r)));
inline constexpr auto iter_move = []<iterator It>(It&& i) ywlib_wrapper(std::ranges::iter_move(fwd<It>(i)));
inline constexpr auto iter_swap = []<iterator It, iterator Jt>(It&& i, Jt&& j) ywlib_wrapper(std::ranges::iter_swap(fwd<It>(i), fwd<Jt>(j)));

template<typename T, nat N = 0> class array {
public:
  T _[N] = {{}};
  static constexpr nat count = N;
  using value_type = T;
  template<convertible_to<T>> constexpr array& operator=(const T (&Array)[N])
  { for (nat i{}; i < N; ++i) _[i] = Array[i]; return *this; }
  constexpr operator add_lvref<T[N]>() noexcept { return _; }
  constexpr operator add_lvref<const T[N]>() const noexcept { return _; }
  constexpr T& operator[](nat I) { return _[I]; }
  constexpr const T& operator[](nat I) const { return _[I]; }
  constexpr nat size() const noexcept { return N; }
  constexpr bool empty() const noexcept { return false; }
  constexpr T* data() noexcept { return _; }
  constexpr const T* data() const noexcept { return _; }
  constexpr T* begin() noexcept { return _; }
  constexpr const T* begin() const noexcept { return _; }
  constexpr T* end() noexcept { return _ + N; }
  constexpr const T* end() const noexcept { return _ + N; }
  constexpr T& front() noexcept { return *_; }
  constexpr const T& front() const noexcept { return *_; }
  constexpr T& back() noexcept { return _[N - 1]; }
  constexpr const T& back() const noexcept { return _[N - 1]; }
  template<nat I> requires(I < N) constexpr T& get() & noexcept { return _[I]; }
  template<nat I> requires(I < N) constexpr T&& get() && noexcept { return mv(_[I]); }
  template<nat I> requires(I < N) constexpr const T& get() const& noexcept { return _[I]; }
  template<nat I> requires(I < N) constexpr const T&& get() const&& noexcept { return mv(_[I]); }
};

template<typename T> class array<T, 0> : public std::vector<T> {
public:
  constexpr array() noexcept = default;
  constexpr array(std::vector<T>&& v) : std::vector<T>(mv(v)) {}
  constexpr explicit array(nat n) : std::vector<T>(n) {}
  constexpr array(nat n, const T& v) : std::vector<T>(n, v) {}
  template<iterator_for<T> It> constexpr array(It i, It s) : std::vector<T>(i, s) {}
  template<iterator_for<T> It, sentinel_for<It> Se> requires(!same_as<It, Se>)
  constexpr array(It i, Se s) : std::vector<T>(std::common_iterator<It, Se>(i), std::common_iterator<It, Se>(s)) {}
  template<range_for<T> Rg> constexpr array(Rg&& r) : std::vector<T>(yw::begin(r), yw::end(r)) {}
};

template<typename T, convertible_to<T>... Ts> array(T, Ts...) -> array<T, 1 + sizeof...(Ts)>;
template<typename T> array(nat, const T&) -> array<T, 0>;
template<iterator It, sentinel_for<It> Se> array(It, Se) -> array<iter_value<It>, 0>;
template<range Rg> array(Rg&&) -> array<iter_value<Rg>, 0>;

namespace _ {
template<range Rg> struct _iter_t<Rg> : _iter_t<iterator_t<Rg>> {};
template<iterator It> struct _iter_t<It> { using v = std::iter_value_t<It>; using d = std::iter_difference_t<It>; using r = std::iter_reference_t<It>; using rr = std::iter_rvalue_reference_t<It>; };
}
}

namespace yw { // String Definitions

template<character Ct> using string = std::basic_string<Ct>;
template<character Ct> using string_view = std::basic_string_view<Ct>;
using str1 = string<cat1>;
using str2 = string<cat2>;
using stv1 = string_view<cat1>;
using stv2 = string_view<cat2>;
using path = std::filesystem::path;

/// checks if `T` is a string-like type.
template<typename T, typename Ct = iter_value<T>> concept stringable = nt_convertible_to<T&, string_view<Ct>>;

/// struct to be used as a non-type template parameter.
template<character Ct> struct literal {
  Ct string[256]{};
  nat count;
  template<nat N> constexpr literal(const Ct (&S)[N]) noexcept : count(N - 1) { std::char_traits<Ct>::copy(string, S, N - 1); }
  constexpr operator const Ct*() const noexcept { return string; }
  constexpr operator string_view<Ct>() const noexcept { return {string, count}; }
  constexpr operator yw::string<Ct>() const noexcept { return {string, count}; }
  constexpr nat size() const noexcept { return count; }
  constexpr bool empty() const noexcept { return count == 0; }
  constexpr const Ct* begin() const noexcept { return string; }
  constexpr const Ct* end() const noexcept { return string + count; }
  constexpr const Ct* data() const noexcept { return string; }
  constexpr const Ct& front() const noexcept { return *string; }
  constexpr const Ct& back() const noexcept { return string[count - 1]; }
};
template<character Ct, nat N> literal(const Ct (&)[N]) -> literal<Ct>;
static_assert(stringable<literal<cat1>>);

/// returns the length of the specified string.
inline constexpr overload strlen{
  []<character Ct>(const Ct* const Str) { return std::char_traits<Ct>::length(Str); },
  []<range Rg>(Rg&& Str) requires character<iter_value<Rg>> { return std::ranges::distance(Str); }
};

namespace _ {
template<typename Ct> constexpr string<Ct> _utf32_to_utf16(const string_view<uct4>& utf32) noexcept {
  auto utf16 = string<Ct>(utf32.size() * 2, Ct('\0'));
  nat size = 0;
  for (auto i = utf32.begin(); i < utf32.end(); ++i) {
    if (*i < 0x10000) utf16[size++] = Ct(*i);
    else if (*i < 0x110000) {
      utf16[size++] = Ct(0xD800 + (*i - 0x10000) / 0x400);
      utf16[size++] = Ct(0xDC00 + (*i - 0x10000) % 0x400);
    } else break; } utf16.resize(size); return utf16; }
template<typename Ct> constexpr string<uct4> _utf16_to_utf32(const string_view<Ct>& utf16) noexcept {
  if (utf16.empty()) return {};
  string<uct4> utf32(utf16.size(), 0);
  nat size = 0;
  for (auto i = utf16.begin(); i < utf16.end(); ++i) {
    if (*i < 0xD800 || *i >= 0xDC00) utf32[size++] = uct4(*i);
    else if (*i < 0xDC00) {
      if (++i == utf16.end()) break;
      utf32[size++] = uct4(0x10000 + (*i - 0xD800) * 0x400 + (*(i + 1) - 0xDC00));
    } else break; } utf32.resize(size); return utf32; }
}

/// function object type to convert a string to a utf-32 string.
struct t_to_utf32 {
  /// converts a multi-byte string to utf-32 string.
  string<uct4> operator()(stringable<cat1> auto&& s) const {
    string_view<cat1> mbs(s);
    if (mbs.empty()) return {};
    if (auto size = ::MultiByteToWideChar(932, 0, mbs.data(), -1, nullptr, 0); size) {
      string<cat2> wcs(size - 1, L'\0');
      ::MultiByteToWideChar(932, 0, mbs.data(), -1, wcs.data(), size);
      return operator()(wcs);
    } else return {};
  }
  /// converts a utf-8 string to utf-32 string.
  constexpr string<uct4> operator()(stringable<uct1> auto&& s) const {
    string_view<uct1> utf8(s);
    if (utf8.empty()) return {};
    string<uct4> utf32(utf8.size(), 0);
    nat size = 0;
    for (auto i = utf8.begin(); i < utf8.end(); ++i) {
      if (*i < 0x80) utf32[size++] = *i;
      else if (*i < 0xE0) utf32[size++] = uct4((*i & 0x1F) << 6 | (*(++i) & 0x3F));
      else if (*i < 0xF0) utf32[size++] = uct4((*i & 0x0F) << 12 | (*(++i) & 0x3F) << 6 | (*(++i) & 0x3F));
      else if (*i < 0xF8) utf32[size++] = uct4((*i & 0x07) << 18 | (*(++i) & 0x3F) << 12 | (*(++i) & 0x3F) << 6 | (*(++i) & 0x3F));
      else break; } utf32.resize(size); return utf32;
  }
  /// converts a wide-char string to utf-32 string.
  constexpr string<uct4> operator()(stringable<cat2> auto&& s) const { return _::_utf16_to_utf32(string_view<cat2>(s)); }
  /// converts a utf-16 string to utf-32 string.
  constexpr string<uct4> operator()(stringable<uct2> auto&& s) const { return _::_utf16_to_utf32(string_view<uct2>(s)); }
  /// converts a utf-32 string to utf-32 string.
  constexpr string<uct4> operator()(stringable<uct4> auto&& s) const { return string<uct4>(string_view<uct4>(s)); }
};

/// function object to convert a string to a utf-32 string.
inline constexpr t_to_utf32 to_utf32;

/// function object type to convert a string to a utf-16 string.
struct t_to_utf16 {
  /// converts a multi-byte string to utf-16 string.
  string<uct2> operator()(stringable<cat1> auto&& s) const {
    string_view<cat1> mbs(s);
    if (mbs.empty()) return {};
    if (auto size = ::MultiByteToWideChar(932, 0, mbs.data(), -1, nullptr, 0); size) {
      string<uct2> utf16(size - 1, L'\0');
      ::MultiByteToWideChar(932, 0, mbs.data(), -1, reinterpret_cast<cat2*>(utf16.data()), size);
      return utf16;
    } else return {};
  }
  /// converts a wide-char string to utf-16 string.
  constexpr string<uct2> operator()(stringable<cat2> auto&& s) const { return string<uct2>(bitcast<string_view<uct2>>(string_view<cat2>(s))); }
  /// converts a utf-8 string to utf-16 string.
  constexpr string<uct2> operator()(stringable<uct1> auto&& s) const { return _::_utf32_to_utf16<uct2>(to_utf32(s)); }
  /// converts a utf-16 string to utf-16 string.
  constexpr string<uct2> operator()(stringable<uct2> auto&& s) const { return string<uct2>(string_view<uct2>(s)); }
  /// converts a utf-32 string to utf-16 string.
  constexpr string<uct2> operator()(stringable<uct4> auto&& s) const { return _::_utf32_to_utf16<uct2>(string_view<uct4>(s)); }
};

/// function object to convert a string to a utf-16 string.
inline constexpr t_to_utf16 to_utf16;

/// function object type to convert a string to a utf-8 string.
struct t_to_utf8 {
  /// converts a multi-byte string to utf-8 string.
  string<uct1> operator()(stringable<cat1> auto&& s) const {
    string_view<cat1> mbs(s);
    if (mbs.empty()) return {};
    if (auto size = ::MultiByteToWideChar(932, 0, mbs.data(), -1, nullptr, 0); size) {
      string<uct2> utf16(size - 1, L'\0');
      ::MultiByteToWideChar(932, 0, mbs.data(), -1, reinterpret_cast<cat2*>(utf16.data()), size);
      return operator()(utf16);
    } else return {};
  }
  /// converts a utf-32 string to utf-8 string.
  constexpr string<uct1> operator()(stringable<uct4> auto&& s) const {
    string_view<uct4> utf32(s);
    if (utf32.empty()) return {};
    string<uct1> utf8(utf32.size() * 4, '\0');
    nat size = 0;
    for (auto i = utf32.begin(); i < utf32.end(); ++i) {
      if (*i < 0x80) utf8[size++] = uct1(*i);
      else if (*i < 0x800) {
        utf8[size++] = uct1(0xC0 | *i >> 6);
        utf8[size++] = uct1(0x80 | *i & 0x3F);
      } else if (*i < 0x10000) {
        utf8[size++] = uct1(0xE0 | *i >> 12);
        utf8[size++] = uct1(0x80 | *i >> 6 & 0x3F);
        utf8[size++] = uct1(0x80 | *i & 0x3F);
      } else if (*i < 0x110000) {
        utf8[size++] = uct1(0xF0 | *i >> 18);
        utf8[size++] = uct1(0x80 | *i >> 12 & 0x3F);
        utf8[size++] = uct1(0x80 | *i >> 6 & 0x3F);
        utf8[size++] = uct1(0x80 | *i & 0x3F);
      } else break; }
    utf8.resize(size);
    return utf8;
  }
  /// converts a wide-char string to utf-8 string.
  constexpr string<uct1> operator()(stringable<cat2> auto&& s) const { return operator()(to_utf32(s)); }
  /// converts a utf-8 string to utf-8 string.
  constexpr string<uct1> operator()(stringable<uct1> auto&& s) const { return string<uct1>(string_view<uct1>(s)); }
  /// converts a utf-16 string to utf-8 string.
  constexpr string<uct1> operator()(stringable<uct2> auto&& s) const { return operator()(to_utf32(s)); }
};

/// function object to convert a string to a utf-8 string.
inline constexpr t_to_utf8 to_utf8;

/// function object type to convert a string to a wide-char string.
struct t_to_wcs {
  /// converts a multi-byte string to wide-char string.
  string<cat2> operator()(stringable<cat1> auto&& s) const {
    string_view<cat1> mbs(s);
    if (mbs.empty()) return {};
    if (auto size = ::MultiByteToWideChar(932, 0, mbs.data(), -1, nullptr, 0); size) {
      string<cat2> wcs(size - 1, L'\0');
      ::MultiByteToWideChar(932, 0, mbs.data(), -1, reinterpret_cast<cat2*>(wcs.data()), size);
      return wcs;
    } else return {};
  }
  /// converts a wide-char string to wide-char string.
  constexpr string<cat2> operator()(stringable<cat2> auto&& s) const { return string<cat2>(string_view<cat2>(s)); }
  /// converts a utf-8 string to wide-char string.
  constexpr string<cat2> operator()(stringable<uct1> auto&& s) const { return _::_utf32_to_utf16<cat2>(to_utf32(s)); }
  /// converts a utf-16 string to wide-char string.
  constexpr string<cat2> operator()(stringable<uct2> auto&& s) const { return string<cat2>(bitcast<string_view<cat2>>(string_view<uct2>(s))); }
  /// converts a utf-32 string to wide-char string.
  constexpr string<cat2> operator()(stringable<uct4> auto&& s) const { return _::_utf32_to_utf16<cat2>(s); }
};

/// function object to convert a string to a wide-char string.
inline constexpr t_to_wcs to_wcs;

/// function object type to convert a string to a multi-byte string.
struct t_to_mbs {
  /// converts a wide-char string to multi-byte string.
  string<cat1> operator()(stringable<cat2> auto&& s) const {
    string_view<cat2> wcs(s);
    if (wcs.empty()) return {};
    if (auto size = ::WideCharToMultiByte(932, 0, wcs.data(), UINT(wcs.size()), nullptr, 0, nullptr, nullptr); size) {
      string<cat1> mbs(size, '\0');
      ::WideCharToMultiByte(932, 0, wcs.data(), UINT(wcs.size()), mbs.data(), size, nullptr, nullptr);
      return mbs;
    } else return {};
  }
  /// converts a multi-byte string to multi-byte string.
  constexpr string<cat1> operator()(stringable<cat1> auto&& s) const { return string<cat1>(string_view<cat1>(s)); }
  /// converts a utf-8 string to multi-byte string.
  string<cat1> operator()(stringable<uct1> auto&& s) const { return operator()(to_wcs(s)); }
  /// converts a utf-16 string to multi-byte string.
  string<cat1> operator()(stringable<uct2> auto&& s) const { return operator()(bitcast<string_view<cat2>>(string_view<uct2>(s))); }
  /// converts a utf-32 string to multi-byte string.
  string<cat1> operator()(stringable<uct4> auto&& s) const { return operator()(to_utf16(s)); }
};

/// function object to convert a string to a multi-byte string.
inline constexpr t_to_mbs to_mbs;

/// converts a string to a string of the specified character type.
template<character Ct> inline constexpr auto to_string = [](stringable auto&& s) {
  if constexpr (same_as<Ct, cat1>) return to_mbs(s);
  else if constexpr (same_as<Ct, cat2>) return to_wcs(s);
  else if constexpr (same_as<Ct, uct1>) return to_utf8(s);
  else if constexpr (same_as<Ct, uct2>) return to_utf16(s);
  else return to_utf32(s);
};

struct date {
  int year{}, month{}, day{};
  template<typename Clock, typename Duration> date(const std::chrono::time_point<Clock, Duration>& tp) {
    auto d = std::chrono::floor<std::chrono::days>(tp);
    auto ymd = std::chrono::year_month_day(d);
    year = int(ymd.year()), month = int(nat4(ymd.month())), day = int(nat4(ymd.day()));
  }
  date() : date(std::chrono::zoned_time(std::chrono::current_zone(), std::chrono::system_clock::now()).get_local_time()) {}
  date(numerical auto Y, numerical auto M, numerical auto D) : year(Y), month(M), day(D) {}
  operator str1() const { return std::format("{:0>4}-{:0>2}-{:0>2}", year, month, day); }
  explicit operator str2() const { return std::format(L"{:0>4}-{:0>2}-{:0>2}", year, month, day); }
  explicit operator string<uct1>() const { string<uct1> s(10, u8'-'); std::ranges::copy(operator str1(), s.begin()); return s; }
  explicit operator string<uct2>() const { string<uct2> s(10, u' '); std::ranges::copy(operator str2(), s.begin()); return s; }
  explicit operator string<uct4>() const { string<uct4> s(10, U' '); std::ranges::copy(operator str1(), s.begin()); return s; }
};

struct time {
  int4 hour{}, minute{}, second{};
  template<typename Clock, typename Duration> time(const std::chrono::time_point<Clock, Duration>& tp) {
    auto d = std::chrono::floor<std::chrono::days>(tp);
    auto hms = std::chrono::hh_mm_ss(std::chrono::floor<std::chrono::seconds>(tp - d));
    hour = int4(hms.hours().count()), minute = int4(hms.minutes().count()), second = int4(hms.seconds().count());
  }
  time() : time(std::chrono::zoned_time(std::chrono::current_zone(), std::chrono::system_clock::now()).get_local_time()) {}
  time(numerical auto H, numerical auto M, numerical auto S) : hour(H), minute(M), second(S) {}
  operator str1() const { return std::format("{:0>2}:{:0>2}:{:0>2}", hour, minute, second); }
  explicit operator str2() const { return std::format(L"{:0>2}:{:0>2}:{:0>2}", hour, minute, second); }
  explicit operator string<uct1>() const { string<uct1> s(8, u8':'); std::ranges::copy(operator str1(), s.begin()); return s; }
  explicit operator string<uct2>() const { string<uct2> s(8, u':'); std::ranges::copy(operator str2(), s.begin()); return s; }
  explicit operator string<uct4>() const { string<uct4> s(8, U':'); std::ranges::copy(operator str1(), s.begin()); return s; }
};

struct now {
  yw::date date;
  yw::time time;
  now() : now(std::chrono::zoned_time(std::chrono::current_zone(), std::chrono::system_clock::now()).get_local_time()) {}
  template<typename Clock, typename Duration> now(const std::chrono::time_point<Clock, Duration>& tp) : date(tp), time(tp) {}
  now(const yw::date& d, const yw::time& t) : date(d), time(t) {}
  operator const yw::date&() const { return date; }
  operator const yw::time&() const { return time; }
  operator str1() const { return std::format("{:0>4}-{:0>2}-{:0>2} {:0>2}:{:0>2}:{:0>2}", date.year, date.month, date.day, time.hour, time.minute, time.second); }
  explicit operator str2() const { return std::format(L"{:0>4}-{:0>2}-{:0>2} {:0>2}:{:0>2}:{:0>2}", date.year, date.month, date.day, time.hour, time.minute, time.second); }
  explicit operator string<uct1>() const { string<uct1> s(19, u8' '); std::ranges::copy(operator str1(), s.begin()); return s; }
  explicit operator string<uct2>() const { string<uct2> s(19, u' '); std::ranges::copy(operator str2(), s.begin()); return s; }
  explicit operator string<uct4>() const { string<uct4> s(19, U' '); std::ranges::copy(operator str1(), s.begin()); return s; }
};

/// struct to represent the source location.
struct source {
  source(const char* const) = delete;
  const cat1* const file; // file name
  const cat1* const func; // function name
  const int line;         // line number
  const int column;       // column number
  /// default constructor to initialize the source location.
  constexpr source(const cat1* const File = __builtin_FILE(), const cat1* const Func = __builtin_FUNCTION(),
                   const int Line = __builtin_LINE(), const int Column = __builtin_COLUMN()) noexcept
    : file(File), func(Func), line(Line), column(Column) {}
  /// returns the string representation of the source location.
  str1 to_string() const { return std::format("{}({},{})", file, line, column); }
  /// returns the string representation of the source location.
  template<character Ct> string<Ct> to_string() const { return yw::to_string<Ct>(stv1(this->to_string())); }
  /// outputs the string representation of the source location to the specified output stream.
  template<typename Ct, typename Tr> friend std::basic_ostream<char, Tr>&
  operator<<(std::basic_ostream<Ct, Tr>& os, const source& s) { return os << s.to_string<Ct>(); }
private:
  template<typename Ct> static constexpr string_view<Ct> get_format() {
    if constexpr (same_as<Ct, cat1>) return "{}({},{})";
    else if constexpr (same_as<Ct, cat2>) return L"{}({},{})";
    else if constexpr (same_as<Ct, uct1>) return u8"{}({},{})";
    else if constexpr (same_as<Ct, uct2>) return u"{}({},{})";
    else if constexpr (same_as<Ct, uct4>) return U"{}({},{})";
  }
};

/// checks if the character is a digit.
inline constexpr auto is_digit = []<character Ct>(const Ct c) noexcept -> int {
  if (is_cev) return c >= Ct('0') && c <= Ct('9');
  else return std::isdigit(static_cast<cat1>(c)); };

namespace _ {
template<typename Ct> constexpr int8 _stoi(string_view<Ct>& s) noexcept {
  int8 v{};
  bool neg = false;
  while (!s.empty()) {
    if (s.front() == Ct('-')) {
      s.remove_prefix(1);
      if (s.empty()) return {};
      if (is_digit(s.front())) { neg = true; v = s.front() - '0'; break; }
    } else if (is_digit(s.front())) { v = s.front() - '0'; break; }
    s.remove_prefix(1);
  }
  s.remove_prefix(1);
  while (!s.empty()) {
    if (is_digit(s.front())) v = v * 10 + s.front() - '0';
    else break;
    s.remove_prefix(1);
  }
  return neg ? -v : v;
}
template<typename Ct> constexpr nat8 _ston(string_view<Ct>& s) noexcept {
  nat8 v{};
  while (!s.empty()) {
    if (is_digit(s.front())) { v = s.front() - '0'; break; }
    s.remove_prefix(1);
  }
  s.remove_prefix(1);
  while (!s.empty()) {
    if (is_digit(s.front())) v = v * 10 + s.front() - '0';
    else return v;
    s.remove_prefix(1);
  }
  return v;
}
template<typename Ct> constexpr fat8 _stof(string_view<Ct>& s) noexcept {
  fat8 v{};
  bool neg = false, dot = false;
  while (!s.empty()) {
    if (s.front() == Ct('-')) {
      s.remove_prefix(1);
      if (s.empty()) return {};
      if (is_digit(s.front())) { neg = true; v = s.front() - '0'; break; }
      else if (s.front() == Ct('.')) { neg = true; dot = true; break; }
    } else if (is_digit(s.front())) { v = s.front() - '0'; break; }
    else if (s.front() == Ct('.')) { dot = true; break; }
    s.remove_prefix(1);
  }
  s.remove_prefix(1);
  if (!dot) {
    while (!s.empty()) {
      if (is_digit(s.front())) v = v * 10 + s.front() - '0';
      else if (s.front() == Ct('.')) { dot = true; break; }
      else return neg ? -v : v;
      s.remove_prefix(1);
    }
    s.remove_prefix(1);
  }
  fat8 p = 0.1;
  while (!s.empty()) {
    if (is_digit(s.front())) { v += (s.front() - '0') * p; p *= 0.1; }
    else return neg ? -v : v;
    s.remove_prefix(1);
  }
  return neg ? -v : v;
}
}

/// function object type to convert a value to a string.
template<arithmetic T> struct t_stov {
  /// converts a string to a value of type T.
  /// \param Str : the string to convert.
  T operator()(string_view<cat1> Str) const noexcept { return call(Str); }
  /// converts a wide string to a value of type T.
  /// \param Str : the wide string to convert.
  T operator()(string_view<cat2> Str) const noexcept { return call(Str); }
  /// converts a utf-8 string to a value of type T.
  /// \param Str : the utf-8 string to convert.
  T operator()(string_view<uct1> Str) const noexcept { return call(Str); }
  /// converts a utf-16 string to a value of type T.
  /// \param Str : the utf-16 string to convert.
  T operator()(string_view<uct2> Str) const noexcept { return call(Str); }
  /// converts a utf-32 string to a value of type T.
  /// \param Str : the utf-32 string to convert.
  T operator()(string_view<uct4> Str) const noexcept { return call(Str); }
  /// converts a string to a value of type T.
  /// \param Str : the string to convert.
  /// \param Rest (out) : the rest of the string after the conversion.
  T operator()(string_view<cat1> Str, string_view<cat1>& Rest) const noexcept
  { return [&](T v) noexcept { return Rest = Str, v; }(call(Str)); }
  /// converts a wide string to a value of type T.
  /// \param Str : the wide string to convert.
  /// \param Rest (out) : the rest of the wide string after the conversion.
  T operator()(string_view<cat2> Str, string_view<cat2>& Rest) const noexcept
  { return [&](T v) noexcept { return Rest = Str, v; }(call(Str)); }
  /// converts a utf-8 string to a value of type T.
  /// \param Str : the utf-8 string to convert.
  /// \param Rest (out) : the rest of the utf-8 string after the conversion.
  T operator()(string_view<uct1> Str, string_view<uct1>& Rest) const noexcept
  { return [&](T v) noexcept { return Rest = Str, v; }(call(Str)); }
  /// converts a utf-16 string to a value of type T.
  /// \param Str : the utf-16 string to convert.
  /// \param Rest (out) : the rest of the utf-16 string after the conversion.
  T operator()(string_view<uct2> Str, string_view<uct2>& Rest) const noexcept
  { return [&](T v) noexcept { return Rest = Str, v; }(call(Str)); }
  /// converts a utf-32 string to a value of type T.
  /// \param Str : the utf-32 string to convert.
  /// \param Rest (out) : the rest of the utf-32 string after the conversion.
  T operator()(string_view<uct4> Str, string_view<uct4>& Rest) const noexcept
  { return [&](T v) noexcept { return Rest = Str, v; }(call(Str)); }
private:
  template<typename Ct> static T call(string_view<Ct>& s) noexcept {
    if constexpr (std::floating_point<T>) return static_cast<T>(_::_stof(s));
    else if constexpr (std::signed_integral<T>) return static_cast<T>(_::_stoi(s));
    else return static_cast<T>(_::_ston(s));
  }
};

/// converts a string to a value of type T.
template<arithmetic T> inline constexpr t_stov<T> stov;

/// class for logging text; the text is written to a file when the object is destroyed.
class logger {
protected:
  string<uct1> text{}; // log text
public:
  path file; // file name
  logger(const path& LogFileName) : file(LogFileName) {}

  /// while destructing, writes the log text to the file.
  ~logger() {
    try {
      if (std::basic_ofstream<uct1> ofs(file, std::ios::app); ofs) ofs << text, text.clear();
      else std::cerr << "failed to open the file (" << file.string() << ")" << std::endl;
    } catch (const std::exception& e) { std::cerr << e.what() << std::endl; }
  }
  /// writes the specified text to the log.
  /// \param Level : the log level; only the first 7 ASCII characters are used.
  /// \param Text : the log text.
  void output(stringable<cat1> auto&& Level, stringable<uct1> auto&& Text, const source& _ = {}) {
    auto lv = std::format(" [{:^7}] ", stv1(Level));
    text += string<uct1>(now{});
    text += reinterpret_cast<string<uct1>&>(lv);
    text += Text;
    text += to_utf8(std::format(" (at {}({},{}))\n", _.file, _.line, _.column));
  }
  /// appends debug log.
  void debug(stringable auto&& s, const source& _ = {}) { output("DEBUG", to_utf8(s), _); }
  /// appends info log.
  void info(stringable auto&& s, const source& _ = {}) { output("INFO", to_utf8(s), _); }
  /// appends warning log.
  void warning(stringable auto&& s, const source& _ = {}) { output("WARNING", to_utf8(s), _); }
  /// appends error log.
  void error(stringable auto&& s, const source& _ = {}) { output("ERROR", to_utf8(s), _); }
  /// appends critical log.
  void fatal(stringable auto&& s, const source& _ = {}) { output("CRITICAL", to_utf8(s), _); }
};

/// default logger object for ywlib
inline auto log = logger(std::format("log/{}.log", date{}));
}

namespace yw::file {
/// checks if the specified path exists.
inline constexpr auto exists = [](const path& p) noexcept -> bool {
  try { return std::filesystem::exists(p); }
  catch (...) { return false; }
};
/// removes the specified path.
inline constexpr auto remove = [](const path& p) noexcept -> bool {
  try { return std::filesystem::remove(p); }
  catch (const std::exception& e) { yw::log.error(stv1(e.what())); }
  return {};
};
/// checks if the specified path is a regular file.
inline constexpr auto is_file = [](const path& p) noexcept -> bool {
  try { return std::filesystem::is_regular_file(p); }
  catch (const std::exception& e) { yw::log.error(stv1(e.what())); }
  return {};
};
/// checks if the specified path is a directory.
inline constexpr auto is_directory = [](const path& p) noexcept -> bool {
  try { return std::filesystem::is_directory(p); }
  catch (const std::exception& e) { yw::log.error(stv1(e.what())); }
  return {};
};
/// returns the size of the specified file.
inline constexpr auto size = [](const path& p) noexcept -> nat {
  try { return std::filesystem::file_size(p); }
  catch (const std::exception& e) { yw::log.error(stv1(e.what())); }
  return {};
};
/// returns the file list of the specified directory.
inline constexpr auto list = [](const path& p, bool Recursive = false) noexcept -> array<path> {
  try { array<path> a;
        if (!file::exists(p)) throw  std::runtime_error(std::format("the path ({}) does not exist", p.string()));
        if (!file::is_directory(p)) throw std::runtime_error(std::format("the path ({}) is not a directory", p.string()));
        if (Recursive) for (const auto& e : std::filesystem::recursive_directory_iterator(p)) a.push_back(e.path());
        else for (const auto& e : std::filesystem::directory_iterator(p)) a.push_back(e.path());
        return a; }
  catch (const std::exception& e) { yw::log.error(stv1(e.what())); return {}; }
};
/// reads the specified file and writes the data to the output range.
inline void read(const path& p, cnt_range auto&& Out) noexcept requires (!is_const<decltype(yw::data(Out))>) {
  try { if (const auto n = yw::size(Out) * sizeof(iter_value<decltype(Out)>); file_size(p) == n) {
          if (std::ifstream ifs(p, std::ios::binary); ifs) return void(ifs.read(reinterpret_cast<char*>(yw::data(Out)), n));
          else throw std::runtime_error(std::format("failed to open the file ({})", p.string()));
        } else throw std::runtime_error(std::format("the byte size of the output range ({}) is not equal to the file size ({})", n, p.string()));
  } catch (const std::exception& e) { yw::log.error(stv1(e.what())); }
}
/// reads the specified file and returns the byte array.
inline array<nat1> read(const path& p) noexcept {
  try { array<nat1> a(file_size(p), nat1{}); read(p, a); return a; }
  catch (const std::exception& e) { yw::log.error(stv1(e.what())); return {}; }
}
/// writes the data of the input range to the specified file.
inline void write(const path& p, cnt_range auto&& In) {
  try {
    if (std::ofstream ofs(p, std::ios::binary); ofs) {
      if (const auto n = yw::size(In) * sizeof(iter_value<decltype(In)>); ofs.write(reinterpret_cast<const char*>(yw::data(In)), n)) return;
      else throw std::runtime_error(std::format("failed to write to the file ({})", p.string()));
    } else throw std::runtime_error(std::format("failed to open the file ({})", p.string()));
  } catch (const std::exception& e) { yw::log.error(stv1(e.what())); }
}
/// canonicalizes the specified path.
inline constexpr auto canonical = [](const path& p) noexcept {
  try { return std::filesystem::canonical(p); }
  catch (const std::exception& e) { yw::log.error(stv1(e.what())); }
  return path{};
};
/// weakly canonicalizes the specified path.
inline constexpr auto weakly_canonical = [](const path& p) noexcept {
  try { return std::filesystem::weakly_canonical(p); }
  catch (const std::exception& e) { yw::log.error(stv1(e.what())); }
  return path{};
};
}

namespace std {
template<typename T> struct common_type<yw::none, T> : type_identity<yw::none> {};
template<typename T> struct common_type<T, yw::none> : type_identity<yw::none> {};
template<> struct formatter<yw::none, char> : formatter<const char*, char> { auto format(yw::none, auto& ctx) const { return formatter<const char*, char>::format("none", ctx); } };
template<> struct formatter<yw::none, wchar_t> : formatter<const wchar_t*, wchar_t> { auto format(yw::none, auto& ctx) const { return formatter<const wchar_t*, wchar_t>::format(L"none", ctx); } };
template<common_with<double> T> struct common_type<yw::value, T> : type_identity<double> {};
template<common_with<double> T> struct common_type<T, yw::value> : type_identity<double> {};
template<typename Ct> struct formatter<yw::value, Ct> : formatter<double, Ct> { auto format(yw::value v, auto& ctx) const { return formatter<double, Ct>::format(v, ctx); } };
template<auto... Vs> struct tuple_size<yw::sequence<Vs...>> : integral_constant<nat, sizeof...(Vs)> {};
template<nat I, auto... Vs> struct tuple_element<I, yw::sequence<Vs...>> : type_identity<decltype(yw::select_value<I, Vs...>)> {};
template<typename... Ts> struct tuple_size<yw::typepack<Ts...>> : integral_constant<nat, sizeof...(Ts)> {};
template<nat I, typename... Ts> struct tuple_element<I, yw::typepack<Ts...>> : type_identity<yw::select_type<I, Ts...>> {};
template<typename... Ts> struct tuple_size<yw::list<Ts...>> : integral_constant<nat, sizeof...(Ts)> {};
template<nat I, typename... Ts> struct tuple_element<I, yw::list<Ts...>> : type_identity<yw::select_type<I, Ts...>> {};
template<typename T, typename Pj, yw::sequence_of<nat> Sq> struct tuple_size<yw::projector<T, Pj, Sq>> : integral_constant<nat, yw::projector<T, Pj, Sq>::count> {};
template<nat I, typename T, typename Pj, yw::sequence_of<nat> Sq> struct tuple_element<I, yw::projector<T, Pj, Sq>> : type_identity<yw::element_t<yw::projector<T, Pj, Sq>, I>> {};
template<typename T, size_t N> struct tuple_size<yw::array<T, N>> : integral_constant<size_t, N> {};
template<size_t I, typename T, size_t N> struct tuple_element<I, yw::array<T, N>> : type_identity<T> {};
template<typename Ct> struct formatter<yw::source, Ct> : formatter<basic_string<Ct>, Ct> {
  auto format(const yw::source& s, auto& c) const { return formatter<basic_string<Ct>, Ct>::format(s.to_string<Ct>(), c); } };
template<typename Ct> struct formatter<yw::path, Ct> : formatter<basic_string<Ct>, Ct> { auto format(const yw::path& p, auto& c) const {
  if constexpr (same_as<remove_cv<Ct>, char>) return std::format("\"{}\"", formatter<basic_string<Ct>, Ct>::format(p.string<Ct>(), c));
  else return std::format(L"\"{}\"", formatter<basic_string<Ct>, Ct>::format(p.string<Ct>(), c)); } };
template<typename Ct, typename Tr> basic_ostream<Ct, Tr>& operator<<(basic_ostream<Ct, Tr>& os, const yw::date& d) { return os << yw::string<Ct>(d); }
template<typename Ct, typename Tr> basic_ostream<Ct, Tr>& operator<<(basic_ostream<Ct, Tr>& os, const yw::time& t) { return os << yw::string<Ct>(t); }
template<typename Ct, typename Tr> basic_ostream<Ct, Tr>& operator<<(basic_ostream<Ct, Tr>& os, const yw::now& n) { return os << yw::string<Ct>(n); }
template<typename Ct> struct formatter<yw::date, Ct> : formatter<basic_string<Ct>, Ct> { auto format(const yw::date& d, auto& c) const { return formatter<basic_string<Ct>, Ct>::format(basic_string<Ct>(d), c); } };
template<typename Ct> struct formatter<yw::time, Ct> : formatter<basic_string<Ct>, Ct> { auto format(const yw::time& t, auto& c) const { return formatter<basic_string<Ct>, Ct>::format(basic_string<Ct>(t), c); } };
template<typename Ct> struct formatter<yw::now, Ct> : formatter<basic_string<Ct>, Ct> { auto format(const yw::now& n, auto& c) const { return formatter<basic_string<Ct>, Ct>::format(basic_string<Ct>(n), c); } };
}

#include <immintrin.h>

namespace yw { // Extended Vector Definitions

using xvector = __m128;
using xwector = __m256d;
using xrect = __m128i;
using xmatrix = array<xvector, 4>;
template<typename Xv> concept xv = included_in<remove_cvref<Xv>, xvector, xwector, xrect>;

struct t_xvload {
  xvector operator()(const float Fill) const noexcept { return _mm_set1_ps(Fill); }
  xwector operator()(const double Fill) const noexcept { return _mm256_set1_pd(Fill); }
  xrect operator()(const int Fill) const noexcept { return _mm_set1_epi32(Fill); }
  xvector operator()(const float* Ptr) const noexcept { return _mm_loadu_ps(Ptr); }
  xwector operator()(const double* Ptr) const noexcept { return _mm256_loadu_pd(Ptr); }
  xrect operator()(const int* Ptr) const noexcept { return _mm_loadu_epi32(Ptr); }
  xvector operator()(const float X, const float Y, const float Z = {}, const float W = {}) const noexcept { return _mm_set_ps(W, Z, Y, X); }
  xwector operator()(const double X, const double Y, const double Z = {}, const double W = {}) const noexcept { return _mm256_set_pd(W, Z, Y, X); }
  xrect operator()(const int X, const int Y, const int Z = {}, const int W = {}) const noexcept { return _mm_set_epi32(W, Z, Y, X); }
  xvector operator()(const xvector& Xv) const noexcept { return Xv; }
  xwector operator()(const xwector& Xv) const noexcept { return Xv; }
  xrect operator()(const xrect& Xv) const noexcept { return Xv; }
};
inline constexpr t_xvload xvload;

template<xv Xv> struct t_xvcast {
  Xv operator()(const xvector& A) const noexcept {
    if constexpr (same_as<Xv, xvector>) return A;
    else if constexpr (same_as<Xv, xwector>) return _mm256_cvtps_pd(A);
    else if constexpr (same_as<Xv, xrect>) return _mm_cvtps_epi32(A);
  }
  Xv operator()(const xwector& A) const noexcept {
    if constexpr (same_as<Xv, xvector>) return _mm256_cvtpd_ps(A);
    else if constexpr (same_as<Xv, xwector>) return A;
    else if constexpr (same_as<Xv, xrect>) return _mm256_cvtpd_epi32(A);
  }
  Xv operator()(const xrect& A) const noexcept {
    if constexpr (same_as<Xv, xvector>) return _mm_cvtepi32_ps(A);
    else if constexpr (same_as<Xv, xwector>) return _mm256_cvtepi32_pd(A);
    else if constexpr (same_as<Xv, xrect>) return A;
  } };
template<xv Xv> inline constexpr t_xvcast<Xv> xvcast;

struct t_xvbitcast {
  xrect operator()(const xvector& A) const noexcept { return _mm_castps_si128(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_castsi128_ps(A); }
};
inline constexpr t_xvbitcast xvbitcast;

inline constexpr caster xv_zero{
  []() noexcept { return _mm_setzero_ps(); }, []() noexcept { return _mm256_setzero_pd(); }, []() noexcept { return _mm_setzero_si128(); },
  []() noexcept -> const xmatrix& { static const xmatrix s{_mm_setzero_ps(), _mm_setzero_ps(), _mm_setzero_ps(), _mm_setzero_ps()}; return s; }};

template<value X, value Y = X, value Z = Y, value W = Z> inline constexpr caster xv_constant{
  []() noexcept -> const xvector& { static const xvector s = xvload(float(X), float(Y), float(Z), float(W)); return s; },
  []() noexcept -> const xwector& { static const xwector s = xvload(double(X), double(Y), double(Z), double(W)); return s; },
  []() noexcept -> const xrect& { static const xrect s = xvload(int(X), int(Y), int(Z), int(W)); return s; }};

inline constexpr auto xv_x = xv_constant<1, 0, 0, 0>;
inline constexpr auto xv_y = xv_constant<0, 1, 0, 0>;
inline constexpr auto xv_z = xv_constant<0, 0, 1, 0>;
inline constexpr auto xv_w = xv_constant<0, 0, 0, 1>;
inline constexpr auto xv_neg_zero = xv_constant<-0.0, -0.0, -0.0, -0.0>;
inline constexpr auto xv_neg_x = xv_constant<-1, 0, 0, 0>;
inline constexpr auto xv_neg_y = xv_constant<0, -1, 0, 0>;
inline constexpr auto xv_neg_z = xv_constant<0, 0, -1, 0>;
inline constexpr auto xv_neg_w = xv_constant<0, 0, 0, -1>;

inline constexpr caster xv_identity{[]() noexcept -> const xmatrix& { static const xmatrix m{xv_x, xv_y, xv_z, xv_w}; return m; }};

template<nat I> requires (I < 4) struct t_xvget {
  fat4 operator()(const xvector& A) const noexcept { if constexpr (I == 0) return _mm_cvtss_f32(A); else return bitcast<fat4>(_mm_extract_ps(A, I)); }
  fat8 operator()(const xwector& A) const noexcept { return bitcast<fat8>(_mm256_extract_epi64(_mm256_castpd_si256(A), I)); }
  int4 operator()(const xrect& A) const noexcept { if constexpr (I == 0) return _mm_cvtsi128_si32(A); else return _mm_extract_epi32(A, I); }
};
template<nat I> requires (I < 4) inline constexpr t_xvget<I> xvget;

template<nat I> requires (I < 4) struct t_xvset {
  xvector operator()(const xvector& A, const fat4 Value) const noexcept { return xvbitcast(_mm_insert_epi32(A, bitcast<int>(Value), int(I))); }
  xwector operator()(const xwector& A, const fat8 Value) const noexcept { return _mm256_castsi256_pd(_mm256_insert_epi64(_mm256_castpd_si256(A), bitcast<int8>(Value), int(I))); }
  xrect operator()(const xrect& A, const int4 Value) const noexcept { return _mm_insert_epi32(A, Value, int(I)); }
};
template<nat I> requires (I < 4) inline constexpr t_xvset<I> xvset;

template<bool X, bool Y, bool Z, bool W> struct t_xvblend {
  xvector operator()(const xvector& A, const xvector& B) const noexcept {
    if constexpr (!(X || Y || Z || W)) return A;
    else if constexpr (X && Y && Z && W) return B;
    else return _mm_blend_ps(A, B, X + Y * 2 + Z * 4 + W * 8);
  }
  xwector operator()(const xwector& A, const xwector& B) const noexcept {
    if constexpr (!(X || Y || Z || W)) return A;
    else if constexpr (X && Y && Z && W) return B;
    else return _mm256_blend_pd(A, B, X + Y * 2 + Z * 4 + W * 8);
  }
  xrect operator()(const xrect& A, const xrect& B) const noexcept {
    if constexpr (!(X || Y || Z || W)) return A;
    else if constexpr (X && Y && Z && W) return B;
    else return _mm_blend_epi32(A, B, X + Y * 2 + Z * 4 + W * 8);
  } };
template<bool X, bool Y, bool Z, bool W> inline constexpr t_xvblend<X, Y, Z, W> xvblend;

template<bool X, bool Y, bool Z, bool W> struct t_xvsetzero {
  xvector operator()(const xvector& A) const noexcept { return xvblend<X, Y, Z, W>(A, xv_zero); }
  xwector operator()(const xwector& A) const noexcept { return xvblend<X, Y, Z, W>(A, xv_zero); }
  xrect operator()(const xrect& A) const noexcept { return xvblend<X, Y, Z, W>(A, xv_zero); }
};
template<bool X, bool Y, bool Z, bool W> inline constexpr t_xvsetzero<X, Y, Z, W> xvsetzero;

namespace _ {
template<int x, int y, int z, int w> xvector _xvpermute1(const xvector& a) noexcept {
  constexpr auto f = [](auto a, auto b) { return a == b || a < 0 || 4 <= a; };
  if constexpr (f(x, 0) && f(y, 1) && f(z, 2) && f(w, 3)) return a;
  else if constexpr (f(x, 0) && f(y, 0) && f(z, 2) && f(w, 2)) return _mm_moveldup_ps(a);
  else if constexpr (f(x, 1) && f(y, 1) && f(z, 3) && f(w, 3)) return _mm_movehdup_ps(a);
  else return _mm_permute_ps(a, (x & 3) + (y & 3) * 4 + (z & 3) * 16 + (w & 3) * 64); }
template<int x, int y, int z, int w> xvector _xvpermute2(const xvector& a, const xvector& b) noexcept {
  constexpr auto f = [](auto a, auto b) { return a == b || a < 0; };
  if constexpr (f(x, 0) && f(y, 1) && f(z, 2) && f(w, 3)) return a;
  else if constexpr (f(x, 4) && f(y, 5) && f(z, 6) && f(w, 7)) return b;
  else if constexpr ((x < 0 || (x & 3) == 0) && (y < 0 || (y & 3) == 1) && (z < 0 || (z & 3) == 2) && (w < 0 || (w & 3) == 3))
    return xvblend<lt(x, 4), lt(y, 4), lt(z, 4), lt(w, 4)>(b, a);
  else if constexpr ((x < 4) && (y < 4) && (z < 0 || 4 <= z) && (w < 0 || 4 <= w))
    return _mm_shuffle_ps(a, b, (x & 3) + (y & 3) * 4 + ((z - 4) & 3) * 16 + ((w - 4) & 3) * 64);
  else if constexpr ((x < 0 || 4 <= x) && (y < 0 || 4 <= y) && (z < 4) && (w < 4))
    return _mm_shuffle_ps(b, a, (x - 4) & 3 | ((y - 4) & 3) * 4 | (z & 3) * 16 | (w & 3) * 64);
  else if constexpr (x < 4 && y < 4 && z < 4 && w < 4) return _::_xvpermute1<x, y, z, w>(a);
  else if constexpr ((x < 0 || 4 <= x) && (y < 0 || 4 <= y) && (z < 0 || 4 <= z) && (w < 0 || 4 <= w))
    return _::_xvpermute1<x - 4, y - 4, z - 4, w - 4>(b);
  else if constexpr (f(x, 0) + f(y, 1) + f(z, 2) + f(w, 3) == 3) {
    constexpr nat i = inspects<!f(x, 0), !f(y, 1), !f(z, 2), !f(w, 3)>;
    return _mm_insert_ps(a, b, int((select_value<i, x, y, z, w> - 4) << 6 | i << 4));
  } else if constexpr (f(x, 4) + f(y, 5) + f(z, 6) + f(w, 7) == 3) {
    constexpr nat i = inspects<!f(x, 4), !f(y, 5), !f(z, 6), !f(w, 7)>;
    return _mm_insert_ps(b, a, int(select_value<i, x, y, z, w>) << 6 | i << 4);
  }
  else if constexpr ((x < 4 || x == 4) && (y < 4 || y == 5) && (z < 4 || z == 6) && (w < 4 || w == 7))
    return xvblend<x == 4, y == 5, z == 6, w == 7>(_::_xvpermute1<x, y, z, w>(a), b);
  else if constexpr ((x < 0 || x == 0 || 4 <= x) && (y < 0 || y == 1 || 4 <= y) && (z < 0 || z == 2 || 4 <= z) && (w < 0 || w == 3 || 4 <= w))
    return xvblend<x == 0, y == 1, z == 2, w == 3>(_::_xvpermute1<x - 4, y - 4, z - 4, w - 4>(b), a);
  else if constexpr ((0 <= x && x < 4) + (0 <= y && y < 4) + (0 <= z && z < 4) + (0 <= w && w < 4) == 1) {
    constexpr nat i = inspects<(0 <= x && x < 4), (0 <= y && y < 4), (0 <= z && z < 4), (0 <= w && w < 4)>;
    return _mm_insert_ps(_::_xvpermute1<x - 4, y - 4, z - 4, w - 4>(b), a, i << 4 | select_value<i, x, y, z, w> << 6);
  } else if constexpr ((4 <= x) + (4 <= y) + (4 <= z) + (4 <= w) == 1) {
    constexpr nat i = inspects<(4 <= x), (4 <= y), (4 <= z), (4 <= w)>;
    return _mm_insert_ps(_::_xvpermute1<x, y, z, w>(a), b, i << 4 | (select_value<i, x, y, z, w> - 4) << 6);
  } else return xvblend<lt(x, 4), lt(y, 4), lt(z, 4), lt(w, 4)>(_::_xvpermute1<x - 4, y - 4, z - 4, w - 4>(b), _::_xvpermute1<x, y, z, w>(a));
  return xvload(-1.f, -1.f, -1.f, -1.f);
}
}

/// permutes the elements of the specified vector.
/// \note if the index is less than 0, the element is chosen to optimize the operation.
template<int X, int Y, int Z, int W> requires (max(X, Y, Z, W) < 4)
xvector xvpermute(const xvector& A) noexcept { return _::_xvpermute1<X, Y, Z, W>(A); }

/// permutes the elements of the specified vectors.
/// \note if the index is less than 0, the element is chosen to optimize the operation.
template<int X, int Y, int Z, int W> requires (max(X, Y, Z, W) < 8)
xvector xvpermute(const xvector& A, const xvector& B) noexcept { return _::_xvpermute2<X, Y, Z, W>(A, B); }

template<int X, int Y, int Z, int W> requires (max(X, Y, Z, W) < 4)
xrect xvpermute(const xrect& A) noexcept { return xvbitcast(xvpermute<X, Y, Z, W>(xvbitcast(A))); }

template<int X, int Y, int Z, int W> requires (max(X, Y, Z, W) < 8)
xrect xvpermute(const xrect& A, const xrect& B) noexcept { return xvbitcast(xvpermute<X, Y, Z, W>(xvbitcast(A), xvbitcast(B))); }

template<int X, int Y, int Z, int W> requires (max(X, Y, Z, W) < 4)
xwector xvpermute(const xwector& A) noexcept { return _mm256_permute4x64_pd(A, X + Y * 4 + Z * 16 + W * 64); }

// template<int X, int Y, int Z, int W> requires (max(X, Y, Z, W) < 8)
// xwector xvpermute(const xwector& A, const xwector& B) noexcept { return _mm256_permute2f128_pd(A, B, X + Y * 2 + Z * 4 + W * 8); }

// template<int X, int Y, int Z, int W> struct t_xvpermute {
//   template<int A, int B, int C, int D> friend struct t_xvpermute;
//   xwector operator()(const xwector& A, const xwector& B) const noexcept requires (lt(max(X, Y, Z, W), 8)) {
//     constexpr auto f = [](auto a, auto b) { return a == b || a < 0; };
//     constexpr int xa = (f(X, 0) ? 0 : X), ya = (f(Y, 1) ? 1 : Y), za = (f(Z, 2) ? 2 : Z), wa = (f(W, 3) ? 3 : W),
//                   xb = (f(X, 4) ? 4 : X), yb = (f(Y, 5) ? 5 : Y), zb = (f(Z, 6) ? 6 : Z), wb = (f(W, 7) ? 7 : W);
//     if constexpr ((xa | ya | za | wa) < 4) return t_xvpermute<xa, ya, za, wa>::call(A);
//     else if constexpr (4 <= (xb & yb & zb & wb)) return t_xvpermute<xb - 4, yb - 4, zb - 4, wb - 4>::call(B);
//     else if constexpr ((xa & 3) == 0 && (ya & 3) == 1 && (za & 3) == 2 && (wa & 3) == 3) return xvblend<lt(xa, 4), lt(ya, 4), lt(za, 4), lt(wa, 4)>(B, A);
//     else if constexpr (xa < 2 && (yb == 4 || yb == 5) && (za == 2 || zb == 3) && wb > 5) return _mm256_shuffle_pd(A, B, (xa == 1) + (yb == 5) * 2 + (za == 3) * 4 + (wb == 7) * 8);
//     else if constexpr ((xb == 4 || xb == 5) && ya < 2 && zb > 5 && (wa == 2 || wa == 3)) return _mm256_shuffle_pd(B, A, (xb == 5) + (ya == 1) * 2 + (zb == 7) * 4 + (wa == 3) * 8);
//     else if constexpr ((xa | ya | za | wa) < 4) return t_xvpermute<xa, ya, za, wa>::call(A);
//     else if constexpr ((xb & yb & zb & wb) > 3) return t_xvpermute<xb - 4, yb - 4, zb - 4, wb - 4>::call(B);
//     else if constexpr (((xa == 0 && ya == 1) || (xa == 2 && ya == 3)) && ((zb == 4 && wb == 5) || (zb == 6 && wb == 7))) return _mm256_shuffle_f64x2(A, B, (xa == 2) + (zb == 6) * 2);
//     else if constexpr (((xb == 4 && yb == 5) || (xb == 6 && yb == 7)) && ((za == 0 && wa == 1) || (za == 2 && wa == 3))) return _mm256_shuffle_f64x2(B, A, (xb == 6) + (za == 2) * 2);
//     else return xvblend<lt(xa, 4), lt(ya, 4), lt(za, 4), lt(wa, 4)>(t_xvpermute<xb - 4, yb - 4, zb - 4, wb - 4>::call(B), t_xvpermute<xa, ya, za, wa>::call(A));
//   }
//   xrect operator()(const xrect& A, const xrect& B) const noexcept requires (lt(max(X, Y, Z, W), 8)) { return xvbitcast(call(xvbitcast(A), xvbitcast(B))); }
// };
// template<int X, int Y, int Z, int W> inline constexpr t_xvpermute<X, Y, Z, W> xvpermute;

template<nat To, nat From, nat Zero = 0> requires ((To | From) < 4 && Zero < 16) struct t_xvinsert {
  xvector operator()(const xvector& Inserted, const xvector& Picked) const noexcept {
    constexpr auto f = [](auto a) { return To == a ? From + 4 : a; };
    if constexpr (Zero == 0) return xvpermute<f(0), f(1), f(2), f(3)>(Inserted, Picked);
    else return _mm_insert_ps(Inserted, Picked, From << 6 | To << 4 | Zero);
  }
  xwector operator()(const xwector& Inserted, const xwector& Picked) const noexcept {
    constexpr auto f = [](auto a) { return To == a ? From + 4 : a; };
    if constexpr (Zero == 0) return xvpermute<f(0), f(1), f(2), f(3)>(Inserted, Picked);
    else return xvsetzero<Zero & 1, Zero & 2, Zero & 4, Zero & 8>(xvpermute<f(0), f(1), f(2), f(3)>(Inserted, Picked));
  }
  xrect operator()(const xrect& Inserted, const xrect& Picked) const noexcept {
    constexpr auto f = [](auto a) { return To == a ? From + 4 : a; };
    if constexpr (Zero == 0) return xvpermute<f(0), f(1), f(2), f(3)>(Inserted, Picked);
    else return xvbitcast(_mm_insert_ps(xvbitcast(Inserted), xvbitcast(Picked), From << 6 | To << 4 | Zero));
  }
};
template<nat To, nat From, nat Zero = 0> inline constexpr t_xvinsert<To, From, Zero> xvinsert;

struct t_xveq {
  bool operator()(const xvector& A, const xvector& B) const noexcept { return _mm_test_all_ones(xvbitcast(_mm_cmpeq_ps(A, B))); }
  bool operator()(const xwector& A, const xwector& B) const noexcept { return _mm256_testc_pd(_mm256_cmp_pd(A, B, 0), xv_neg_zero); }
  bool operator()(const xrect& A, const xrect& B) const noexcept { return _mm_test_all_ones(_mm_cmpeq_epi32(A, B)); }
};
inline constexpr t_xveq xveq;

struct t_xvne {
  bool operator()(const xvector& A, const xvector& B) const noexcept { return !xveq(A, B); }
  bool operator()(const xwector& A, const xwector& B) const noexcept { return !xveq(A, B); }
  bool operator()(const xrect& A, const xrect& B) const noexcept { return !xveq(A, B); }
};
inline constexpr t_xvne xvne;

struct t_xvlt {
  bool operator()(const xvector& A, const xvector& B) const noexcept { return _mm_movemask_ps(_mm_cmpgt_ps(A, B)) < _mm_movemask_ps(_mm_cmplt_ps(A, B)); }
  bool operator()(const xwector& A, const xwector& B) const noexcept { return _mm256_movemask_pd(_mm256_cmp_pd(B, A, 17)) < _mm256_movemask_pd(_mm256_cmp_pd(A, B, 17)); }
  bool operator()(const xrect& A, const xrect& B) const noexcept { return _mm_movemask_ps(xvbitcast(_mm_cmpgt_epi32(A, B))) < _mm_movemask_ps(xvbitcast(_mm_cmplt_epi32(A, B))); }
};
inline constexpr t_xvlt xvlt;

struct t_xvle {
  bool operator()(const xvector& A, const xvector& B) const noexcept { return _mm_movemask_ps(_mm_cmpgt_ps(A, B)) <= _mm_movemask_ps(_mm_cmplt_ps(A, B)); }
  bool operator()(const xwector& A, const xwector& B) const noexcept { return _mm256_movemask_pd(_mm256_cmp_pd(B, A, 17)) <= _mm256_movemask_pd(_mm256_cmp_pd(A, B, 17)); }
  bool operator()(const xrect& A, const xrect& B) const noexcept { return _mm_movemask_ps(xvbitcast(_mm_cmpgt_epi32(A, B))) <= _mm_movemask_ps(xvbitcast(_mm_cmplt_epi32(A, B))); }
};
inline constexpr t_xvle xvle;

struct t_xvgt {
  bool operator()(const xvector& A, const xvector& B) const noexcept { return _mm_movemask_ps(_mm_cmpgt_ps(A, B)) > _mm_movemask_ps(_mm_cmplt_ps(A, B)); }
  bool operator()(const xwector& A, const xwector& B) const noexcept { return _mm256_movemask_pd(_mm256_cmp_pd(B, A, 17)) > _mm256_movemask_pd(_mm256_cmp_pd(A, B, 17)); }
  bool operator()(const xrect& A, const xrect& B) const noexcept { return _mm_movemask_ps(xvbitcast(_mm_cmpgt_epi32(A, B))) > _mm_movemask_ps(xvbitcast(_mm_cmplt_epi32(A, B))); }
};
inline constexpr t_xvgt xvgt;

struct t_xvge {
  bool operator()(const xvector& A, const xvector& B) const noexcept { return _mm_movemask_ps(_mm_cmpgt_ps(A, B)) >= _mm_movemask_ps(_mm_cmplt_ps(A, B)); }
  bool operator()(const xwector& A, const xwector& B) const noexcept { return _mm256_movemask_pd(_mm256_cmp_pd(B, A, 17)) >= _mm256_movemask_pd(_mm256_cmp_pd(A, B, 17)); }
  bool operator()(const xrect& A, const xrect& B) const noexcept { return _mm_movemask_ps(xvbitcast(_mm_cmpgt_epi32(A, B))) >= _mm_movemask_ps(xvbitcast(_mm_cmplt_epi32(A, B))); }
};
inline constexpr t_xvge xvge;

struct t_xvtw {
  auto operator()(const xvector& A, const xvector& B) const noexcept { return _mm_movemask_ps(_mm_cmpgt_ps(A, B)) <=> _mm_movemask_ps(_mm_cmplt_ps(A, B)); }
  auto operator()(const xwector& A, const xwector& B) const noexcept { return _mm256_movemask_pd(_mm256_cmp_pd(B, A, 17)) <=> _mm256_movemask_pd(_mm256_cmp_pd(A, B, 17)); }
  auto operator()(const xrect& A, const xrect& B) const noexcept { return _mm_movemask_ps(xvbitcast(_mm_cmpgt_epi32(A, B))) <=> _mm_movemask_ps(xvbitcast(_mm_cmplt_epi32(A, B))); }
};
inline constexpr t_xvtw xvtw;

struct t_xvabs {
  xvector operator()(const xvector& A) const noexcept { return _mm_andnot_ps(xv_neg_zero, A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_andnot_pd(xv_neg_zero, A); }
  xrect operator()(const xrect& A) const noexcept { return _mm_abs_epi32(A); }
};
inline constexpr t_xvabs xvabs;

struct t_xvneg {
  xvector operator()(const xvector& A) const noexcept { return _mm_xor_ps(A, xv_neg_zero); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_xor_pd(A, xv_neg_zero); }
  xrect operator()(const xrect& A) const noexcept { return _mm_xor_si128(A, xv_neg_zero); }
};
inline constexpr t_xvneg xvneg;

struct t_xvadd {
  xvector operator()(const xvector& A, const xvector& B) const noexcept { return _mm_add_ps(A, B); }
  xwector operator()(const xwector& A, const xwector& B) const noexcept { return _mm256_add_pd(A, B); }
  xrect operator()(const xrect& A, const xrect& B) const noexcept { return _mm_add_epi32(A, B); }
};
inline constexpr t_xvadd xvadd;

struct t_xvsub {
  xvector operator()(const xvector& A, const xvector& B) const noexcept { return _mm_sub_ps(A, B); }
  xwector operator()(const xwector& A, const xwector& B) const noexcept { return _mm256_sub_pd(A, B); }
  xrect operator()(const xrect& A, const xrect& B) const noexcept { return _mm_sub_epi32(A, B); }
};
inline constexpr t_xvsub xvsub;

struct t_xvmul {
  xvector operator()(const xvector& A, const xvector& B) const noexcept { return _mm_mul_ps(A, B); }
  xwector operator()(const xwector& A, const xwector& B) const noexcept { return _mm256_mul_pd(A, B); }
  xrect operator()(const xrect& A, const xrect& B) const noexcept { return _mm_mul_epi32(A, B); }
};
inline constexpr t_xvmul xvmul;

struct t_xvdiv {
  xvector operator()(const xvector& A, const xvector& B) const noexcept { return _mm_div_ps(A, B); }
  xwector operator()(const xwector& A, const xwector& B) const noexcept { return _mm256_div_pd(A, B); }
  xrect operator()(const xrect& A, const xrect& B) const noexcept { return _mm_div_epi32(A, B); }
};
inline constexpr t_xvdiv xvdiv;

template<bool X, bool Y, bool Z, bool W> struct t_xvabsolute {
  xvector operator()(const xvector& A) const noexcept { return xvblend<X, Y, Z, W>(A, xvabs(A)); }
  xwector operator()(const xwector& A) const noexcept { return xvblend<X, Y, Z, W>(A, xvabs(A)); }
  xrect operator()(const xrect& A) const noexcept { return xvblend<X, Y, Z, W>(A, xvabs(A)); }
};
template<bool X, bool Y, bool Z, bool W> inline constexpr t_xvabsolute<X, Y, Z, W> xvabsolute;

template<bool X, bool Y, bool Z, bool W> struct t_xvnegate {
  xvector operator()(const xvector& A) const noexcept { return xvblend<X, Y, Z, W>(A, xvneg(A)); }
  xwector operator()(const xwector& A) const noexcept { return xvblend<X, Y, Z, W>(A, xvneg(A)); }
  xrect operator()(const xrect& A) const noexcept { return xvblend<X, Y, Z, W>(A, xvneg(A)); }
};
template<bool X, bool Y, bool Z, bool W> inline constexpr t_xvnegate<X, Y, Z, W> xvnegate;

struct t_xvfma {
  xvector operator()(const xvector& A, const xvector& B, const xvector& C) const noexcept { return _mm_fmadd_ps(A, B, C); }
  xwector operator()(const xwector& A, const xwector& B, const xwector& C) const noexcept { return _mm256_fmadd_pd(A, B, C); }
  xrect operator()(const xrect& A, const xrect& B, const xrect& C) const noexcept { return xvadd(xvmul(A, B), C); }
};
inline constexpr t_xvfma xvfma;

struct t_xvfms {
  xvector operator()(const xvector& A, const xvector& B, const xvector& C) const noexcept { return _mm_fmsub_ps(A, B, C); }
  xwector operator()(const xwector& A, const xwector& B, const xwector& C) const noexcept { return _mm256_fmsub_pd(A, B, C); }
  xrect operator()(const xrect& A, const xrect& B, const xrect& C) const noexcept { return xvsub(xvmul(A, B), C); }
};
inline constexpr t_xvfms xvfms;

struct t_xvfnma {
  xvector operator()(const xvector& A, const xvector& B, const xvector& C) const noexcept { return _mm_fnmadd_ps(A, B, C); }
  xwector operator()(const xwector& A, const xwector& B, const xwector& C) const noexcept { return _mm256_fnmadd_pd(A, B, C); }
  xrect operator()(const xrect& A, const xrect& B, const xrect& C) const noexcept { return xvsub(xvmul(xvneg(A), B), C); }
};
inline constexpr t_xvfnma xvfnma;

struct t_xvfnms {
  xvector operator()(const xvector& A, const xvector& B, const xvector& C) const noexcept { return _mm_fnmsub_ps(A, B, C); }
  xwector operator()(const xwector& A, const xwector& B, const xwector& C) const noexcept { return _mm256_fnmsub_pd(A, B, C); }
  xrect operator()(const xrect& A, const xrect& B, const xrect& C) const noexcept { return xvsub(xvmul(xvneg(A), B), C); }
};
inline constexpr t_xvfnms xvfnms;

struct t_xvceil {
  xvector operator()(const xvector& A) const noexcept { return _mm_ceil_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_ceil_pd(A); }
  xrect operator()(const xrect& A) const noexcept { return A; };
};
inline constexpr t_xvceil xvceil;

struct t_xvfloor {
  xvector operator()(const xvector& A) const noexcept { return _mm_floor_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_floor_pd(A); }
  xrect operator()(const xrect& A) const noexcept { return A; };
};
inline constexpr t_xvfloor xvfloor;

struct t_xvtrunc {
  xvector operator()(const xvector& A) const noexcept { return _mm_trunc_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_trunc_pd(A); }
  xrect operator()(const xrect& A) const noexcept { return A; };
};
inline constexpr t_xvtrunc xvtrunc;

struct t_xvround {
  xvector operator()(const xvector& A) const noexcept { return _mm_round_ps(A, 8); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_round_pd(A, 8); }
  xrect operator()(const xrect& A) const noexcept { return A; };
};
inline constexpr t_xvround xvround;

struct t_xvmax {
  xvector operator()(const xvector& A, const xvector& B) const noexcept { return _mm_max_ps(A, B); }
  xwector operator()(const xwector& A, const xwector& B) const noexcept { return _mm256_max_pd(A, B); }
  xrect operator()(const xrect& A, const xrect& B) const noexcept { return _mm_max_epi32(A, B); };
};
inline constexpr t_xvmax xvmax;

struct t_xvmin {
  xvector operator()(const xvector& A, const xvector& B) const noexcept { return _mm_min_ps(A, B); }
  xwector operator()(const xwector& A, const xwector& B) const noexcept { return _mm256_min_pd(A, B); }
  xrect operator()(const xrect& A, const xrect& B) const noexcept { return _mm_min_epi32(A, B); };
};
inline constexpr t_xvmin xvmin;

struct t_xvsin {
  xvector operator()(const xvector& A) const noexcept { return _mm_sin_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_sin_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_sin_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvsin xvsin;

struct t_xvasin {
  xvector operator()(const xvector& A) const noexcept { return _mm_asin_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_asin_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_asin_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvasin xvasin;

struct t_xvsinh {
  xvector operator()(const xvector& A) const noexcept { return _mm_sinh_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_sinh_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_sinh_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvsinh xvsinh;

struct t_xvasinh {
  xvector operator()(const xvector& A) const noexcept { return _mm_asinh_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_asinh_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_asinh_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvasinh xvasinh;

struct t_xvcos {
  xvector operator()(const xvector& A) const noexcept { return _mm_cos_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_cos_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_cos_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvcos xvcos;

struct t_xvacos {
  xvector operator()(const xvector& A) const noexcept { return _mm_acos_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_acos_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_acos_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvacos xvacos;

struct t_xvcosh {
  xvector operator()(const xvector& A) const noexcept { return _mm_cosh_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_cosh_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_cosh_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvcosh xvcosh;

struct t_xvacosh {
  xvector operator()(const xvector& A) const noexcept { return _mm_acosh_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_acosh_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_acosh_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvacosh xvacosh;

struct t_xvtan {
  xvector operator()(const xvector& A) const noexcept { return _mm_tan_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_tan_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_tan_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvtan xvtan;

struct t_xvatan {
  xvector operator()(const xvector& A) const noexcept { return _mm_atan_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_atan_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_atan_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvatan xvatan;

struct t_xvtanh {
  xvector operator()(const xvector& A) const noexcept { return _mm_tanh_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_tanh_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_tanh_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvtanh xvtanh;

struct t_xvatanh {
  xvector operator()(const xvector& A) const noexcept { return _mm_atanh_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_atanh_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_atanh_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvatanh xvatanh;

struct t_xvatan2 {
  xvector operator()(const xvector& Sin, const xvector& Cos) const noexcept { return _mm_atan2_ps(Sin, Cos); }
  xwector operator()(const xwector& Sin, const xwector& Cos) const noexcept { return _mm256_atan2_pd(Sin, Cos); }
  xvector operator()(const xrect& Sin, const xrect& Cos) const noexcept { return _mm_atan2_ps(xvcast<xvector>(Sin), xvcast<xvector>(Cos)); };
};
inline constexpr t_xvatan2 xvatan2;

struct t_xvsincos {
  xvector operator()(const xvector& A, xvector& Cos) const noexcept { return _mm_sincos_ps(&Cos, A); }
  xwector operator()(const xwector& A, xwector& Cos) const noexcept { return _mm256_sincos_pd(&Cos, A); }
  xvector operator()(const xrect& A, xvector& Cos) const noexcept { return _mm_sincos_ps(&Cos, xvcast<xvector>(A)); };
};
inline constexpr t_xvsincos xvsincos;

struct t_xvpow {
  xvector operator()(const xvector& A, const xvector& B) const noexcept { return _mm_pow_ps(A, B); }
  xwector operator()(const xwector& A, const xwector& B) const noexcept { return _mm256_pow_pd(A, B); }
  xvector operator()(const xrect& A, const xrect& B) const noexcept { return _mm_pow_ps(xvcast<xvector>(A), xvcast<xvector>(B)); };
};
inline constexpr t_xvpow xvpow;

struct t_xvexp {
  xvector operator()(const xvector& A) const noexcept { return _mm_exp_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_exp_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_exp_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvexp xvexp;

struct t_xvexp2 {
  xvector operator()(const xvector& A) const noexcept { return _mm_exp2_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_exp2_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_exp2_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvexp2 xvexp2;

struct t_xvexp10 {
  xvector operator()(const xvector& A) const noexcept { return _mm_exp10_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_exp10_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_exp10_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvexp10 xvexp10;

struct t_xvexpm1 {
  xvector operator()(const xvector& A) const noexcept { return _mm_expm1_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_expm1_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_expm1_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvexpm1 xvexpm1;

struct t_xvln {
  xvector operator()(const xvector& A) const noexcept { return _mm_log_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_log_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_log_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvln xvln;

struct t_xvlog {
  xvector operator()(const xvector& A, const xvector& Base) const noexcept { return xvdiv(xvln(A), xvln(Base)); }
  xwector operator()(const xwector& A, const xwector& Base) const noexcept { return xvdiv(xvln(A), xvln(Base)); }
  xvector operator()(const xrect& A, const xrect& Base) const noexcept { return xvdiv(xvln(A), xvln(Base)); };
};
inline constexpr t_xvlog xvlog;

struct t_xvlog2 {
  xvector operator()(const xvector& A) const noexcept { return _mm_log2_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_log2_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_log2_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvlog2 xvlog2;

struct t_xvlog10 {
  xvector operator()(const xvector& A) const noexcept { return _mm_log10_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_log10_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_log10_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvlog10 xvlog10;

struct t_xvlog1p {
  xvector operator()(const xvector& A) const noexcept { return _mm_log1p_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_log1p_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_log1p_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvlog1p xvlog1p;

struct t_xvlogb {
  xvector operator()(const xvector& A) const noexcept { return _mm_logb_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_logb_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_logb_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvlogb xvlogb;

struct t_xvsqrt {
  xvector operator()(const xvector& A) const noexcept { return _mm_sqrt_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_sqrt_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_sqrt_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvsqrt xvsqrt;

struct t_xvcbrt {
  xvector operator()(const xvector& A) const noexcept { return _mm_cbrt_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_cbrt_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_cbrt_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvcbrt xvcbrt;

struct t_xvhypot {
  xvector operator()(const xvector& A, const xvector& B) const noexcept { return _mm_hypot_ps(A, B); }
  xwector operator()(const xwector& A, const xwector& B) const noexcept { return _mm256_hypot_pd(A, B); }
  xvector operator()(const xrect& A, const xrect& B) const noexcept { return _mm_hypot_ps(xvcast<xvector>(A), xvcast<xvector>(B)); };
};
inline constexpr t_xvhypot xvhypot;

struct t_xvsqrt_r {
  xvector operator()(const xvector& A) const noexcept { return _mm_invsqrt_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_invsqrt_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_invsqrt_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvsqrt_r xvsqrt_r;

struct t_xvcbrt_r {
  xvector operator()(const xvector& A) const noexcept { return _mm_invcbrt_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_invcbrt_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_invcbrt_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xvcbrt_r xvcbrt_r;

struct t_xverf {
  xvector operator()(const xvector& A) const noexcept { return _mm_erf_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_erf_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_erf_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xverf xverf;

struct t_xverfc {
  xvector operator()(const xvector& A) const noexcept { return _mm_erfc_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_erfc_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_erfc_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xverfc xverfc;

struct t_xverf_r {
  xvector operator()(const xvector& A) const noexcept { return _mm_erfinv_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_erfinv_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_erfinv_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xverf_r xverf_r;

struct t_xverfc_r {
  xvector operator()(const xvector& A) const noexcept { return _mm_erfcinv_ps(A); }
  xwector operator()(const xwector& A) const noexcept { return _mm256_erfcinv_pd(A); }
  xvector operator()(const xrect& A) const noexcept { return _mm_erfcinv_ps(xvcast<xvector>(A)); };
};
inline constexpr t_xverfc_r xverfc_r;

template<nat N, nat Zero = 0> requires (0 < N && N <= 4 && Zero < 16) struct t_xvdot {
  xvector operator()(const xvector& A, const xvector& B) const noexcept {
    if constexpr (Zero == 15) return xv_zero;
    else if constexpr (N == 1) { return call<Zero>(xvmul(A, B)); }
    else if constexpr (N == 2) { return call<Zero>(_mm_hadd_ps(xvmul(A, B), xv_zero)); }
    else return _mm_dp_ps(A, B, select_value<N, 0, 16, 48, 112, 240> | (15 ^ Zero));
  }
  xwector operator()(const xwector& A, const xwector& B) const noexcept {
    if constexpr (Zero == 15) return xv_zero;
    else if constexpr (N == 1) { return call<Zero>(xvmul(A, B)); }
    else if constexpr (N == 2) { return call<Zero>(xvadd(_mm256_hadd_pd(xvmul(A, B), xv_zero), A)); }
    else if constexpr (N == 3) { auto a = xvmul(A, B); return call<Zero>(xvadd(_mm256_hadd_pd(a, xv_zero), _mm256_castpd128_pd256(_mm256_extractf128_pd(A, 1)))); }
    else if constexpr (N == 4) { auto a = _mm256_hadd_pd(xvmul(A, B), xv_zero); return call<Zero>(xvadd(a, _mm256_castpd128_pd256(_mm256_extractf128_pd(a, 1)))); }
  }
  xrect operator()(const xrect& A, const xrect& B) const noexcept {
    if constexpr (Zero == 15) return xv_zero;
    else if constexpr (N == 1) { return call<Zero>(xvmul(A, B)); }
    else if constexpr (N == 2) { return call<Zero>(xvadd(_mm_hadd_epi32(xvmul(A, B), xv_zero), A)); }
    else if constexpr (N == 3) { auto a = xvmul(A, B); return call<Zero>(xvadd(_mm_hadd_epi32(a, A), xvpermute<2, -1, -1, -1>(a))); }
    else if constexpr (N == 4) { auto a = _mm_hadd_epi32(xvmul(A, B), A); return call<Zero>(xvadd(a, xvpermute<2, -1, -1, -1>(a))); }
  }
private:
  static auto call(const auto& A) noexcept {
    if constexpr (bitcount(Zero) == 3) return xvpermute<Zero & 1, Zero & 2, Zero & 4, Zero & 8>(xv_zero, A);
    else if constexpr (Zero == 0) return xvpermute<0, 0, 0, 0>(A);
    else return xvpermute<Zero & 1 ? 0 : 0, Zero & 2 ? 1 : 0, Zero & 4 ? 2 : 0, Zero & 8 ? 3 : 0>(xv_zero, A);
  } };
template<nat N, nat Zero = 0> requires (0 < N && N <= 4 && Zero < 16) inline constexpr t_xvdot<N, Zero> xvdot;

template<nat N> requires (0 < N && N <= 4) struct t_xvtransform {
  template<tuple_for<xvector> Matrix> requires (0 < extent<Matrix> && extent<Matrix> <= 4)
  xvector operator()(const Matrix& M, const xvector& V) const noexcept { return call<extent<Matrix>>(M, V); }
  template<tuple_for<xwector> Matrix> requires (0 < extent<Matrix> && extent<Matrix> <= 4)
  xwector operator()(const Matrix& M, const xwector& V) const noexcept { return call<extent<Matrix>>(M, V); }
  template<tuple_for<xrect> Matrix> requires (0 < extent<Matrix> && extent<Matrix> <= 4)
  xrect operator()(const Matrix& M, const xrect& V) const noexcept { return call<extent<Matrix>>(M, V); }
private:
  template<nat E> static auto call(const auto& M, const auto& V) noexcept {
    auto o = xvdot<N, 0b1110>(get<0>(M), V);
    if constexpr (E >= 2) o = xvinsert<1, 0, (N == 1) * 0b1100>(o, xvdot<N, 0b1110>(get<1>(M), V));
    if constexpr (E >= 3) o = xvinsert<2, 0, (N == 2) * 0b1000>(o, xvdot<N, 0b1110>(get<2>(M), V));
    if constexpr (E == 4) o = xvinsert<3, 0, 0>(o, xvdot<N, 0b1110>(get<3>(M), V));
    return o;
  } };
template<nat N> requires (0 < N && N <= 4) inline constexpr t_xvtransform<N> xvtransform;

struct t_xvproduct {
  template<tuple_for<xvector> ML, tuple_for<xvector> MR> requires (le(extent<MR>, 4))
  void operator()(const ML& Left, const MR& Right, ML& Out) const noexcept { return call<extent<ML>, extent<MR>>(Left, Right, Out); }
  template<tuple_for<xwector> ML, tuple_for<xwector> MR> requires (le(extent<MR>, 4))
  void operator()(const ML& Left, const MR& Right, ML& Out) const noexcept { return call<extent<ML>, extent<MR>>(Left, Right, Out); }
  template<tuple_for<xrect> ML, tuple_for<xrect> MR> requires (le(extent<MR>, 4))
  void operator()(const ML& Left, const MR& Right, ML& Out) const noexcept { return call<extent<ML>, extent<MR>>(Left, Right, Out); }
private:
  template<nat NL, nat NR> static void call(const auto& L, const auto& R, auto& O) noexcept {
    constexpr auto f = [](const auto& A, const auto& B, auto& C) noexcept {
    C = xvmul(xvpermute<0, 0, 0, 0>(A), get<0>(B));
    if constexpr (NR >= 2) C = xvfma(xvpermute<1, 1, 1, 1>(A), get<1>(B), C);
    if constexpr (NR >= 3) C = xvfma(xvpermute<2, 2, 2, 2>(A), get<2>(B), C);
    if constexpr (NR == 4) C = xvfma(xvpermute<3, 3, 3, 3>(A), get<3>(B), C); };
    [&]<nat... Is>(sequence<Is...>) noexcept { (f(get<Is>(L), R, get<Is>(O)), ...); }(make_sequence<0, NL>{});
  } };
inline constexpr t_xvproduct xvproduct;

struct t_xvcross {
  xvector operator()(const xvector& A, const xvector& B) const noexcept { return call(A, B); }
  xwector operator()(const xwector& A, const xwector& B) const noexcept { return call(A, B); }
  xrect operator()(const xrect& A, const xrect& B) const noexcept { return call(A, B); }
private:
  static auto call(const auto& A, const auto& B) noexcept {
    auto a = xvpermute<2, 0, 1, 3>(A), b = xvpermute<1, 2, 0, 3>(B);
    return xvfms(xvpermute<1, 2, 0, 3>(A), xvpermute<2, 0, 1, 3>(B), xvmul(a, b));
  } };
inline constexpr t_xvcross xvcross;

template<nat N, nat Zero = 0> requires (0 < N && N <= 4 && Zero < 16) struct t_xvlength {
  xvector operator()(const xvector& A) const noexcept { return xvsqrt(xvdot<N, Zero>(A, A)); }
  xwector operator()(const xwector& A) const noexcept { return xvsqrt(xvdot<N, Zero>(A, A)); }
  xvector operator()(const xrect& A) const noexcept { return xvsqrt(xvdot<N, Zero>(A, A)); }
};
template<nat N, nat Zero = 0> requires (0 < N && N <= 4 && Zero < 16) inline constexpr t_xvlength<N, Zero> xvlength;

template<nat N, nat Zero = 0> requires (0 < N && N <= 4 && Zero < 16) struct t_xvlength_r {
  xvector operator()(const xvector& A) const noexcept { return xvsqrt_r(xvdot<N, Zero>(A, A)); }
  xwector operator()(const xwector& A) const noexcept { return xvsqrt_r(xvdot<N, Zero>(A, A)); }
  xvector operator()(const xrect& A) const noexcept { return xvsqrt_r(xvdot<N, Zero>(A, A)); }
};
template<nat N, nat Zero = 0> requires (0 < N && N <= 4 && Zero < 16) inline constexpr t_xvlength_r<N, Zero> xvlength_r;

template<nat N> requires (0 < N && N <= 4) struct t_xvnormalize {
  xvector operator()(const xvector& A) const noexcept { return xvdiv(A, xvlength<N>(A)); }
  xwector operator()(const xwector& A) const noexcept { return xvdiv(A, xvlength<N>(A)); }
  xvector operator()(const xrect& A) const noexcept { return xvdiv(A, xvlength<N>(A)); }
};
template<nat N> requires (0 < N && N <= 4) inline constexpr t_xvnormalize<N> xvnormalize;

struct t_xvradian {
  xvector operator()(const xvector& A) const noexcept { return xvmul(A, xv_constant<pi / 180>); }
  xwector operator()(const xwector& A) const noexcept { return xvmul(A, xv_constant<pi / 180>); }
  xvector operator()(const xrect& A) const noexcept { return xvmul(xvcast<xvector>(A), xv_constant<pi / 180>); }
};
inline constexpr t_xvradian xvradian;

struct t_xvdegree {
  xvector operator()(const xvector& A) const noexcept { return xvmul(A, xv_constant<180 / pi>); }
  xwector operator()(const xwector& A) const noexcept { return xvmul(A, xv_constant<180 / pi>); }
  xvector operator()(const xrect& A) const noexcept { return xvmul(xvcast<xvector>(A), xv_constant<180 / pi>); }
};
inline constexpr t_xvdegree xvdegree;

struct t_xvtranspose {
  template<tuple_for<xvector> Matrix> requires (0 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const Matrix& M, Matrix& O) const noexcept { return call<extent<Matrix>>(M, O); }
  template<tuple_for<xwector> Matrix> requires (0 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const Matrix& M, Matrix& O) const noexcept { return call<extent<Matrix>>(M, O); }
  template<tuple_for<xrect> Matrix> requires (0 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const Matrix& M, Matrix& O) const noexcept { return call<extent<Matrix>>(M, O); }
private:
  template<nat N> static void call(const auto& M, auto& O) noexcept {
    constexpr auto f = []<nat I>(constant<I>, const auto& A, auto& B) noexcept {
      if constexpr (N == 1) B = xvinsert<0, I, 0b1110>(get<0>(A), get<0>(A));
      else {
        B = xvpermute<I, 4 + I, -1, -1>(get<0>(A), get<1>(A));
        if constexpr (N == 2) B = xvsetzero<0, 0, 1, 1>(B);
        else if constexpr (N == 3) B = xvinsert<2, I, 0b1000>(B, get<2>(A));
        else if constexpr (N == 4) B = xvpermute<0, 1, 4, 5>(B, xvpermute<I, 4 + I, -1, -1>(get<2>(A), get<3>(A)));
      } };
    [&]<nat... Is>(sequence<Is...>) noexcept { (f(constant<Is>{}, M, get<Is>(O)), ...); }(make_sequence<0, N>{});
  } };
inline constexpr t_xvtranspose xvtranspose;

struct t_xvtranslation {
  template<tuple_for<xvector> Matrix> requires (0 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const xvector& Offset, Matrix& O) const noexcept { return call<extent<Matrix>>(Offset, O); }
  template<tuple_for<xwector> Matrix> requires (0 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const xwector& Offset, Matrix& O) const noexcept { return call<extent<Matrix>>(Offset, O); }
  template<tuple_for<xrect> Matrix> requires (0 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const xrect& Offset, Matrix& O) const noexcept { return call<extent<Matrix>>(Offset, O); }
private:
  template<nat N> static void call(const auto& Offset, auto& O) noexcept {
    get<0>(O) = xvinsert<3, 0>(xv_x, Offset);
    if constexpr (N >= 2) get<1>(O) = xvinsert<3, 1>(xv_y, Offset);
    if constexpr (N >= 3) get<2>(O) = xvinsert<3, 2>(xv_z, Offset);
    if constexpr (N == 4) get<3>(O) = xv_w;
  } };
inline constexpr t_xvtranslation xvtranslation;

struct t_xvrotation {
  template<tuple_for<xvector> Matrix> requires (0 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const xvector& Radian, Matrix& O) const noexcept { return call<extent<Matrix>>(Radian, O); }
  template<tuple_for<xwector> Matrix> requires (0 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const xwector& Radian, Matrix& O) const noexcept { return call<extent<Matrix>>(Radian, O); }
  template<tuple_for<xrect> Matrix> requires (0 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const xrect& Radian, Matrix& O) const noexcept { return call<extent<Matrix>>(Radian, O); }
private:
  template<nat N> static void call(const auto& Radian, auto& O) noexcept {
    if constexpr (N == 2) {
      get<1>(O) = xvsincos(Radian, get<0>(O));
      get<0>(O) = xvinsert<1, 0, 0b1100>(get<0>(O), get<1>(O));
      get<1>(O) = xvinsert<1, 0, 0b1100>(get<1>(O), get<0>(O));
    } else if constexpr (N == 3) {
      get<0>(O) = xvsincos(Radian, get<1>(O));
      get<2>(O) = xvpermute<4, 6, 0, 2>(get<0>(O), get<1>(O));
      auto temp = xvpermute<3, 0, 1, 2>(get<2>(O));
      get<2>(O) = xvmul(get<2>(O), temp);
      get<1>(O) = xvmul(xvpermute<1, 1, 1, 1>(get<1>(O)), temp);
      get<0>(O) = xvpermute<1, 1, 1, 1>(get<0>(O));
      temp = _mm_addsub_ps(xvpermute<2, 3, 0, 1>(xvmul(get<0>(O), get<2>(O))), get<2>(O));
      get<2>(O) = xvinsert<0, 0, 0b1000>(xvpermute<-1, 3, 1, -1>(get<1>(O)), xvneg(get<0>(O)));
      get<0>(O) = xvinsert<0, 2, 0b1000>(xvpermute<-1, 0, 3, -1>(temp), get<1>(O));
      get<1>(O) = xvinsert<0, 0, 0b1000>(temp, get<1>(O));
    } else if constexpr (N == 4) {
      get<0>(O) = xvsincos(Radian, get<1>(O));
      get<2>(O) = xvpermute<4, 6, 0, 2>(get<0>(O), get<1>(O));
      get<3>(O) = xvpermute<3, 0, 1, 2>(get<2>(O));
      get<2>(O) = xvmul(get<2>(O), get<3>(O));
      get<1>(O) = xvmul(xvpermute<1, 1, 1, 1>(get<1>(O)), get<3>(O));
      get<0>(O) = xvpermute<1, 1, 1, 1>(get<0>(O));
      get<3>(O) = _mm_addsub_ps(xvpermute<2, 3, 0, 1>(xvmul(get<0>(O), get<2>(O))), get<2>(O));
      get<2>(O) = xvinsert<0, 0, 0b1000>(xvpermute<-1, 3, 1, -1>(get<1>(O)), xvneg(get<0>(O)));
      get<0>(O) = xvinsert<0, 2, 0b1000>(xvpermute<-1, 0, 3, -1>(get<3>(O)), get<1>(O));
      get<1>(O) = xvinsert<0, 0, 0b1000>(get<3>(O), get<1>(O));
      get<3>(O) = xv_w;
    } } };
inline constexpr t_xvrotation xvrotation;

struct t_xvrotation_inv {
  template<tuple_for<xvector> Matrix> requires (0 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const xvector& Radian, Matrix& O) const noexcept { return call<extent<Matrix>>(Radian, O); }
  template<tuple_for<xwector> Matrix> requires (0 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const xwector& Radian, Matrix& O) const noexcept { return call<extent<Matrix>>(Radian, O); }
  template<tuple_for<xrect> Matrix> requires (0 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const xrect& Radian, Matrix& O) const noexcept { return call<extent<Matrix>>(Radian, O); }
private:
  template<nat N> static void call(const auto& Radian, auto& O) noexcept {
    if constexpr (N == 2) {
    get<1>(O) = xvsincos(Radian, get<0>(O));
    get<0>(O) = xvinsert<1, 0, 0b1100>(get<0>(O), get<1>(O));
    get<1>(O) = xvinsert<1, 0, 0b1100>(get<1>(O), get<0>(O));
    get<1>(O) = xvnegate<0, 1, 0, 0>(get<1>(O));
  } else if constexpr (N == 3) {
    get<0>(O) = xvsincos(Radian, get<1>(O));
    get<2>(O) = xvpermute<4, 6, 0, 2>(get<0>(O), get<1>(O));
    auto temp = xvpermute<3, 0, 1, 2>(get<2>(O));
    get<2>(O) = xvmul(get<2>(O), temp);
    get<1>(O) = xvmul(xvpermute<1, 1, 1, 1>(get<1>(O)), temp);
    get<0>(O) = xvpermute<1, 1, 1, 1>(get<0>(O));
    temp = _mm_addsub_ps(xvpermute<2, 3, 0, 1>(xvmul(get<0>(O), get<2>(O))), get<2>(O));
    get<2>(O) = xvinsert<2, 1, 0b1000>(xvpermute<3, 2, -1, -1>(temp), get<1>(O));
    get<0>(O) = xvinsert<2, 2, 0b1000>(xvpermute<2, 0, -1, -1>(get<1>(O)), xvneg(get<0>(O)));
    get<1>(O) = xvinsert<2, 3, 0b1000>(temp, get<1>(O));
  } else if constexpr (N == 4) {
    get<0>(O) = xvsincos(Radian, get<1>(O));
    get<2>(O) = xvpermute<4, 6, 0, 2>(get<0>(O), get<1>(O));
    get<3>(O) = xvpermute<3, 0, 1, 2>(get<2>(O));
    get<2>(O) = xvmul(get<2>(O), get<3>(O));
    get<1>(O) = xvmul(xvpermute<1, 1, 1, 1>(get<1>(O)), get<3>(O));
    get<0>(O) = xvpermute<1, 1, 1, 1>(get<0>(O));
    get<3>(O) = _mm_addsub_ps(xvpermute<2, 3, 0, 1>(xvmul(get<0>(O), get<2>(O))), get<2>(O));
    get<2>(O) = xvinsert<2, 1, 0b1000>(xvpermute<3, 2, -1, -1>(get<3>(O)), get<1>(O));
    get<0>(O) = xvinsert<2, 2, 0b1000>(xvpermute<2, 0, -1, -1>(get<1>(O)), xvneg(get<0>(O)));
    get<1>(O) = xvinsert<2, 3, 0b1000>(get<3>(O), get<1>(O));
    get<3>(O) = xv_w;
  } } };
inline constexpr t_xvrotation_inv xvrotation_inv;

struct t_xvscale {
  template<tuple_for<xvector> Matrix> requires (0 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const xvector& Scalar, Matrix& O) const noexcept { return call<extent<Matrix>>(Scalar, O); }
  template<tuple_for<xwector> Matrix> requires (0 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const xwector& Scalar, Matrix& O) const noexcept { return call<extent<Matrix>>(Scalar, O); }
  template<tuple_for<xrect> Matrix> requires (0 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const xrect& Scalar, Matrix& O) const noexcept { return call<extent<Matrix>>(Scalar, O); }
private:
  template<nat N> static void call(const auto& Scalar, auto& O) noexcept {
    get<0>(O) = xvmul(get<0>(O), xvpermute<0, 0, 0, 0>(Scalar));
    if constexpr (N >= 2) get<1>(O) = xvmul(get<1>(O), xvpermute<1, 1, 1, 1>(Scalar));
    if constexpr (N >= 3) get<2>(O) = xvmul(get<2>(O), xvpermute<2, 2, 2, 2>(Scalar));
    if constexpr (N == 4) get<3>(O) = xvmul(get<3>(O), xvpermute<3, 3, 3, 3>(Scalar));
  } };
inline constexpr t_xvscale xvscale;

struct t_xvworld {
  template<tuple_for<xvector> Matrix> requires (1 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(Matrix& O) const noexcept { return zero<extent<Matrix>>(O); }
  template<tuple_for<xwector> Matrix> requires (1 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(Matrix& O) const noexcept { return zero<extent<Matrix>>(O); }
  template<tuple_for<xvector> Matrix> requires (1 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const xvector& Offset, Matrix& O) const noexcept { return xvtranslation(Offset, O); }
  template<tuple_for<xwector> Matrix> requires (1 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const xwector& Offset, Matrix& O) const noexcept { return xvtranslation(Offset, O); }
  template<tuple_for<xvector> Matrix> requires (1 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const xvector& Offset, const xvector& Radian, Matrix& O) const noexcept { return two(Offset, Radian, O); }
  template<tuple_for<xwector> Matrix> requires (1 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const xwector& Offset, const xwector& Radian, Matrix& O) const noexcept { return two(Offset, Radian, O); }
  template<tuple_for<xvector> Matrix> requires (1 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const xvector& Offset, const xvector& Radian, const xvector& Scale, Matrix& O) const noexcept { return three(Offset, Radian, Scale, O); }
  template<tuple_for<xwector> Matrix> requires (1 < extent<Matrix> && extent<Matrix> <= 4)
  void operator()(const xwector& Offset, const xwector& Radian, const xwector& Scale, Matrix& O) const noexcept { return three(Offset, Radian, Scale, O); }
private:
  template<nat N> static void zero(auto& O) noexcept {
    get<0>(O) = xv_x, get<1>(O) = xv_y;
    if constexpr (N >= 3) get<2>(O) = xv_z;
    if constexpr (N == 4) get<3>(O) = xv_w;
  }
  template<nat N> static void two(const auto& Offset, const auto& Radian, auto& O) noexcept {
    xmrotate(Radian, O);
    get<0>(O) = xvinsert<3, 0>(get<0>(O), Offset);
    get<1>(O) = xvinsert<3, 1>(get<1>(O), Offset);
    if constexpr (N >= 3) get<2>(O) = xvinsert<3, 2>(get<2>(O), Offset);
  }
  template<nat N> static void three(const auto& Offset, const auto& Radian, const auto& Scale, auto& O) noexcept {
    xmrotate(Radian, O);
    get<0>(O) = xvinsert<3, 0>(get<0>(O), Offset);
    get<1>(O) = xvinsert<3, 1>(get<1>(O), Offset);
    if constexpr (N >= 3) get<2>(O) = xvinsert<3, 2>(get<2>(O), Offset);
    get<0>(O) = xvmul(get<0>(O), xvpermute<0, 0, 0, 0>(Scale));
    get<1>(O) = xvmul(get<1>(O), xvpermute<1, 1, 1, 1>(Scale));
    if constexpr (N >= 3) get<2>(O) = xvmul(get<2>(O), xvpermute<2, 2, 2, 2>(Scale));
  } };
inline constexpr t_xvworld xvworld;

struct t_xvview {
  template<tuple_for<xvector> Matrix> requires (le(2, extent<Matrix>) && le(extent<Matrix>, 4))
  void operator()(const xvector& Radian, Matrix& O) const noexcept { return xvrotation_inv(Radian, O); }
  template<tuple_for<xwector> Matrix> requires (le(2, extent<Matrix>) && le(extent<Matrix>, 4))
  void operator()(const xwector& Radian, Matrix& O) const noexcept { return xvrotation_inv(Radian, O); }
  template<tuple_for<xvector> Matrix> requires (le(2, extent<Matrix>) && le(extent<Matrix>, 4))
  void operator()(const xvector& Position, const xvector& Radian, Matrix& O) const noexcept { two<extent<Matrix>>(Position, Radian, O); }
  template<tuple_for<xwector> Matrix> requires (le(2, extent<Matrix>) && le(extent<Matrix>, 4))
  void operator()(const xwector& Position, const xwector& Radian, Matrix& O) const noexcept { two<extent<Matrix>>(Position, Radian, O); }
  template<tuple_for<xvector> Matrix> requires (le(2, extent<Matrix>) && le(extent<Matrix>, 4))
  void operator()(const xvector& Position, const xvector& Radian, const xvector& Offset, Matrix& O) const noexcept { three<extent<Matrix>>(Position, Radian, Offset, O); }
  template<tuple_for<xwector> Matrix> requires (le(2, extent<Matrix>) && le(extent<Matrix>, 4))
  void operator()(const xwector& Position, const xwector& Radian, const xwector& Offset, Matrix& O) const noexcept { three<extent<Matrix>>(Position, Radian, Offset, O); }
private:
  template<nat N> static void two(const auto& Position, const auto& Radian, auto& O) noexcept {
    xvrotation_inv(Radian, O);
    if constexpr (N < 4) {
      auto temp = xvneg(Position);
      get<0>(O) = xvinsert<3, 3>(get<0>(O), xvdot<3>(get<0>(O), temp));
      get<1>(O) = xvinsert<3, 3>(get<1>(O), xvdot<3>(get<1>(O), temp));
      if constexpr (N == 3) get<2>(O) = xvinsert<3, 3>(get<2>(O), xvdot<3>(get<2>(O), temp));
    } else {
      get<3>(O) = xvneg(Position);
      get<0>(O) = xvinsert<3, 3>(get<0>(O), xvdot<3>(get<0>(O), get<3>(O)));
      get<1>(O) = xvinsert<3, 3>(get<1>(O), xvdot<3>(get<1>(O), get<3>(O)));
      get<2>(O) = xvinsert<3, 3>(get<2>(O), xvdot<3>(get<2>(O), get<3>(O)));
      get<3>(O) = xv_w;
    } }
  template<nat N> static void three(const auto& Position, const auto& Radian, const auto& Offset, auto& O) noexcept {
    xvrotation_inv(Radian, O);
    if constexpr (N < 4) {
      auto temp = xvneg(Position);
      get<0>(O) = xvsub(xvinsert<3, 3>(get<0>(O), xvdot<3>(get<0>(O), temp)), xvinsert<3, 0, 0b0111>(Offset, Offset));
      get<1>(O) = xvsub(xvinsert<3, 3>(get<1>(O), xvdot<3>(get<1>(O), temp)), xvinsert<3, 1, 0b0111>(Offset, Offset));
      if constexpr (N == 3) get<2>(O) = xvsub(xvinsert<3, 3>(get<2>(O), xvdot<3>(get<2>(O), temp)), xvinsert<3, 2, 0b0111>(Offset, Offset));
    } else {
      get<3>(O) = xvneg(Position);
      get<0>(O) = xvsub(xvinsert<3, 3>(get<0>(O), xvdot<3>(get<0>(O), get<3>(O))), xvinsert<3, 0, 0b0111>(Offset, Offset));
      get<1>(O) = xvsub(xvinsert<3, 3>(get<1>(O), xvdot<3>(get<1>(O), get<3>(O))), xvinsert<3, 1, 0b0111>(Offset, Offset));
      get<2>(O) = xvsub(xvinsert<3, 3>(get<2>(O), xvdot<3>(get<2>(O), get<3>(O))), xvinsert<3, 2, 0b0111>(Offset, Offset));
      get<3>(O) = xv_w;
    } } };
inline constexpr t_xvview xvview;

struct t_xvprojection {
  /// Create a perspective projection matrix; `Factor` is `1/tan(fov/2)`.
  template<tuple_for<xvector> Matrix> requires (le(3, extent<Matrix>) && le(extent<Matrix>, 4))
  void operator()(const xvector& Width, const xvector& Height, const xvector& Factor, Matrix& O) const noexcept { return parallel(Width, Height, Factor, O); }
  /// Create a perspective projection matrix; `Factor` is `1/tan(fov/2)`.
  template<tuple_for<xwector> Matrix> requires (le(3, extent<Matrix>) && le(extent<Matrix>, 4))
  void operator()(const xwector& Width, const xwector& Height, const xwector& Factor, Matrix& O) const noexcept { return parallel(Width, Height, Factor, O); }
  /// Create a orthographic projection matrix; `Factor` means magnification.
  template<tuple_for<xvector> Matrix> requires (le(3, extent<Matrix>) && le(extent<Matrix>, 4))
  void operator()(const xvector& Width, const xvector& Height, const xvector& Factor, none OrthographicMode, Matrix& O) const noexcept { return orthographic(Width, Height, Factor, O); }
  /// Create a orthographic projection matrix; `Factor` means magnification.
  template<tuple_for<xwector> Matrix> requires (le(3, extent<Matrix>) && le(extent<Matrix>, 4))
  void operator()(const xwector& Width, const xwector& Height, const xwector& Factor, none OrthographicMode, Matrix& O) const noexcept { return orthographic(Width, Height, Factor, O); }
private:
  template<nat N> static void parallel(const auto& Width, const auto& Height, const auto& Factor, auto& O) noexcept {
    constexpr value f = 1048576.0, n = 0.25;
    get<0>(O) = xvset<0>(xv_zero, -Factor * Height / Width);
    get<1>(O) = xvset<1>(xv_zero, Factor);
    get<2>(O) = xv_constant<0, 0, f / (f - n), -f * n / (f - n)>;
    if constexpr (N == 4) get<3>(O) = xv_z;
  }
  template<nat N> static void orthographic(const auto& Width, const auto& Height, const auto& Factor, auto& O) noexcept {
    constexpr value f = 1048576.0, n = 0.25;
    get<0>(O) = xvset<0>(xv_zero, -2.0f * Factor / Width);
    get<1>(O) = xvset<1>(xv_zero, 2.0f * Factor / Height);
    get<2>(O) = xv_constant<0, 0, 1 / (f - n), -n / (f - n)>;
    if constexpr (N == 4) get<3>(O) = xv_w;
  } };
/// Create a perspective (or orthographic) projection matrix.
inline constexpr t_xvprojection xvprojection;

inline constexpr auto xvinverse_transformation = [](const xmatrix& Transformation, xmatrix& O) noexcept {
  xvtranspose(Transformation, O);
  xvblend<0, 0, 0, 1>(get<0>(O), xvneg(get<0>(Transformation)));
  xvblend<0, 0, 0, 1>(get<1>(O), xvneg(get<1>(Transformation)));
  xvblend<0, 0, 0, 1>(get<2>(O), xvneg(get<2>(Transformation)));
  get<3>(O) = xv_w;
};

struct t_xveuler {
  /// Calculate the Euler angles from a rotation matrix.
  template<tuple_for<xvector> Matrix> requires (le(3, extent<Matrix>) && le(extent<Matrix>, 4))
  auto operator()(const Matrix& Rotation) const noexcept { return call<extent<Matrix>>(Rotation); }
  /// Calculate the Euler angles from a rotation matrix.
  template<tuple_for<xwector> Matrix> requires (le(3, extent<Matrix>) && le(extent<Matrix>, 4))
  auto operator()(const Matrix& Rotation) const noexcept { return call<extent<Matrix>>(Rotation); }
private:
  template<nat N> static auto call(const auto& Rotation) noexcept {
    auto v = xvneg(xvpermute<3, 0, 3, 3>(get<2>(Rotation)));
    if (xveq(v, xv_y)) return xvasin(xvinsert<0, 1, 0b1100>(v, get<0>(Rotation)));
    v = xvpermute<0, 1, 6, 3>(xvpermute<4, 1, -1, 3>(v, xvdiv(get<1>(Rotation), get<0>(Rotation))), xvdiv(xvpermute<-1, -1, 1, -1>(get<2>(Rotation)), get<2>(Rotation)));
    return xvpermute<6, 1, 4, 3>(xvasin(v), xvatan(xvpermute<0, -1, 5, -1>(get<1>(Rotation), get<2>(Rotation)), xvblend<0, 0, 1, 1>(get<0>(Rotation), get<2>(Rotation))));
  } };
/// Calculate the Euler angles from a rotation matrix.
inline constexpr t_xveuler xveuler;
}

namespace yw { // vectors

/// 2D vector.
struct vector2 {
  fat4 x{}; // x-coordinate
  fat4 y{}; // y-coordinate
  static constexpr nat count = 2;
  constexpr vector2() noexcept = default;
  explicit constexpr vector2(const fat4& Fill) noexcept : x(Fill), y(Fill) {}
  explicit constexpr vector2(const numerical auto& Fill) noexcept : vector2(fat4(Fill)) {}
  constexpr vector2(const numerical auto& X, const numerical auto& Y) noexcept : x(fat4(X)), y(fat4(Y)) {}
  constexpr fat4 power() const noexcept { return x * x + y * y; }
  fat4 length() const noexcept { return std::hypot(x, y); }
  constexpr nat size() const noexcept { return count; }
  fat4* data() noexcept { return &x; }
  const fat4* data() const noexcept { return &x; }
  fat4* begin() noexcept { return &x; }
  const fat4* begin() const noexcept { return &x; }
  fat4* end() noexcept { return &x + count; }
  const fat4* end() const noexcept { return &x + count; }
  fat4& operator[](nat i) { return *(&x + i); }
  const fat4& operator[](nat i) const { return *(&x + i); }
  template<nat I> requires(I < 2) fat4& get() noexcept { return select_parameter<I>(x, y); }
  template<nat I> requires(I < 2) fat4 get() const noexcept { return select_parameter<I>(x, y); }
  friend constexpr bool operator==(const vector2& A, const vector2& B) noexcept { return A.x == B.x && A.y == B.y; }
  friend constexpr auto operator<=>(const vector2& A, const vector2& B) noexcept { if (auto a = A.x <=> B.x; a != 0) return a; else return A.y <=> B.y; }
  friend constexpr vector2 operator+(const vector2& A) noexcept { return A; }
  friend constexpr vector2 operator-(const vector2& A) noexcept { return {-A.x, -A.y}; }
  friend constexpr vector2 operator+(const vector2& A, const vector2& B) noexcept { return {A.x + B.x, A.y + B.y}; }
  friend constexpr vector2 operator-(const vector2& A, const vector2& B) noexcept { return {A.x - B.x, A.y - B.y}; }
  friend constexpr vector2 operator*(const vector2& A, const vector2& B) noexcept { return {A.x * B.x, A.y * B.y}; }
  friend constexpr vector2 operator/(const vector2& A, const vector2& B) noexcept { return {A.x / B.x, A.y / B.y}; }
  friend constexpr vector2 operator*(const vector2& A, const fat4& B) noexcept { return {A.x * B, A.y * B}; }
  friend constexpr vector2 operator/(const vector2& A, const fat4& B) noexcept { return {A.x / B, A.y / B}; }
  friend constexpr vector2 operator*(const fat4& A, const vector2& B) noexcept { return {A * B.x, A * B.y}; }
  friend constexpr vector2 operator/(const fat4& A, const vector2& B) noexcept { return {A / B.x, A / B.y}; }
  friend constexpr vector2 operator*(const vector2& A, const numerical auto& B) noexcept { return A * fat4(B); }
  friend constexpr vector2 operator/(const vector2& A, const numerical auto& B) noexcept { return A / fat4(B); }
  friend constexpr vector2 operator*(const numerical auto& A, const vector2& B) noexcept { return fat4(A) * B; }
  friend constexpr vector2 operator/(const numerical auto& A, const vector2& B) noexcept { return fat4(A) / B; }
  friend constexpr vector2 operator+=(vector2& A, const vector2& B) noexcept { return A = A + B; }
  friend constexpr vector2 operator-=(vector2& A, const vector2& B) noexcept { return A = A - B; }
  friend constexpr vector2 operator*=(vector2& A, const vector2& B) noexcept { return A = A * B; }
  friend constexpr vector2 operator/=(vector2& A, const vector2& B) noexcept { return A = A / B; }
  friend constexpr vector2 operator*=(vector2& A, const numerical auto& B) noexcept { return A = A * fat4(B); }
  friend constexpr vector2 operator/=(vector2& A, const numerical auto& B) noexcept { return A = A / fat4(B); }
  friend constexpr fat4 dot(const vector2& A, const vector2& B) noexcept { return A.x * B.x + A.y * B.y; }
  friend constexpr vector2 cross(const vector2& A) noexcept { return {A.y, -A.x}; }
};

/// 3D vector.
struct vector3 {
  fat4 x{}; // x-coordinate
  fat4 y{}; // y-coordinate
  fat4 z{}; // z-coordinate
  static constexpr nat count = 3;
  constexpr vector3() noexcept = default;
  explicit constexpr vector3(const fat4& Fill) noexcept : x(Fill), y(Fill), z(Fill) {}
  explicit constexpr vector3(const numerical auto& Fill) noexcept : vector3(fat4(Fill)) {}
  constexpr vector3(const vector2& XY, const numerical auto& Z) noexcept : x(XY.x), y(XY.y), z(fat4(Z)) {}
  constexpr vector3(const numerical auto& X, const numerical auto& Y, const numerical auto& Z) noexcept : x(fat4(X)), y(fat4(Y)), z(fat4(Z)) {}
  explicit constexpr operator vector2() const noexcept { return {x, y}; }
  constexpr fat4 power() const noexcept { if (is_cev) return x * x + y * y + z * z; else return [](auto&& a) { return xvget<0>(xvdot<3>(a, a)); }(xvload(&x)); }
  fat4 length() const noexcept { return std::hypot(x, y, z); }
  constexpr nat size() const noexcept { return count; }
  fat4* data() noexcept { return &x; }
  const fat4* data() const noexcept { return &x; }
  fat4* begin() noexcept { return &x; }
  const fat4* begin() const noexcept { return &x; }
  fat4* end() noexcept { return &x + count; }
  const fat4* end() const noexcept { return &x + count; }
  fat4& operator[](nat i) { return *(&x + i); }
  const fat4& operator[](nat i) const { return *(&x + i); }
  template<nat I> requires(I < 3) fat4& get() noexcept { return select_parameter<I>(x, y, z); }
  template<nat I> requires(I < 3) fat4 get() const noexcept { return select_parameter<I>(x, y, z); }
  friend constexpr bool operator==(const vector3& A, const vector3& B) noexcept { return A.x == B.x && A.y == B.y && A.z == B.z; }
  friend constexpr auto operator<=>(const vector3& A, const vector3& B) noexcept { if (auto a = A.x <=> B.x; a != 0) return a; else if (a = A.y <=> B.y; a != 0) return a; else return A.z <=> B.z; }
  friend constexpr vector3 operator+(const vector3& A) noexcept { return A; }
  friend constexpr vector3 operator-(const vector3& A) noexcept { return {-A.x, -A.y, -A.z}; }
  friend constexpr vector3 operator+(const vector3& A, const vector3& B) noexcept { return {A.x + B.x, A.y + B.y, A.z + B.z}; }
  friend constexpr vector3 operator-(const vector3& A, const vector3& B) noexcept { return {A.x - B.x, A.y - B.y, A.z - B.z}; }
  friend constexpr vector3 operator*(const vector3& A, const vector3& B) noexcept { return {A.x * B.x, A.y * B.y, A.z * B.z}; }
  friend constexpr vector3 operator/(const vector3& A, const vector3& B) noexcept { return {A.x / B.x, A.y / B.y, A.z / B.z}; }
  friend constexpr vector3 operator*(const vector3& A, const fat4& B) noexcept { return {A.x * B, A.y * B, A.z * B}; }
  friend constexpr vector3 operator/(const vector3& A, const fat4& B) noexcept { return {A.x / B, A.y / B, A.z / B}; }
  friend constexpr vector3 operator*(const fat4& A, const vector3& B) noexcept { return {A * B.x, A * B.y, A * B.z}; }
  friend constexpr vector3 operator/(const fat4& A, const vector3& B) noexcept { return {A / B.x, A / B.y, A / B.z}; }
  friend constexpr vector3 operator*(const vector3& A, const numerical auto& B) noexcept { return A * fat4(B); }
  friend constexpr vector3 operator/(const vector3& A, const numerical auto& B) noexcept { return A / fat4(B); }
  friend constexpr vector3 operator*(const numerical auto& A, const vector3& B) noexcept { return fat4(A) * B; }
  friend constexpr vector3 operator/(const numerical auto& A, const vector3& B) noexcept { return fat4(A) / B; }
  friend constexpr vector3 operator+=(vector3& A, const vector3& B) noexcept { return A = A + B; }
  friend constexpr vector3 operator-=(vector3& A, const vector3& B) noexcept { return A = A - B; }
  friend constexpr vector3 operator*=(vector3& A, const vector3& B) noexcept { return A = A * B; }
  friend constexpr vector3 operator/=(vector3& A, const vector3& B) noexcept { return A = A / B; }
  friend constexpr vector3 operator*=(vector3& A, const numerical auto& B) noexcept { return A = A * fat4(B); }
  friend constexpr vector3 operator/=(vector3& A, const numerical auto& B) noexcept { return A = A / fat4(B); }
  friend constexpr fat4 dot(const vector3& A, const vector3& B) noexcept { return A.x * B.x + A.y * B.y + A.z * B.z; }
  friend constexpr vector3 cross(const vector3& A, const vector3& B) noexcept { return {A.y * B.z - A.z * B.y, A.z * B.x - A.x * B.z, A.x * B.y - A.y * B.x}; }
};

/// 4D vector.
struct vector {
  fat4 x{}; // x-coordinate
  fat4 y{}; // y-coordinate
  fat4 z{}; // z-coordinate
  fat4 w{}; // w-coordinate
  static constexpr nat count = 4;
  constexpr vector() noexcept = default;
  explicit constexpr vector(const fat4& Fill) noexcept : x(Fill), y(Fill), z(Fill), w(Fill) {}
  explicit constexpr vector(const numerical auto& Fill) noexcept : vector(fat4(Fill)) {}
  constexpr vector(const vector2& XY) noexcept : x(XY.x), y(XY.y) {}
  constexpr vector(const vector2& XY, const vector2& ZW) noexcept : x(XY.x), y(XY.y), z(ZW.x), w(ZW.y) {}
  constexpr vector(const vector2& XY, const numerical auto& Z) noexcept : x(XY.x), y(XY.y), z(fat4(Z)) {}
  constexpr vector(const vector2& XY, const numerical auto& Z, const numerical auto& W) noexcept : x(XY.x), y(XY.y), z(fat4(Z)), w(fat4(W)) {}
  constexpr vector(const vector3& XYZ) noexcept : x(XYZ.x), y(XYZ.y), z(XYZ.z) {}
  constexpr vector(const vector3& XYZ, const numerical auto& W) noexcept : x(XYZ.x), y(XYZ.y), z(XYZ.z), w(fat4(W)) {}
  constexpr vector(const numerical auto& X, const numerical auto& Y) noexcept : x(fat4(X)), y(fat4(Y)) {}
  constexpr vector(const numerical auto& X, const numerical auto& Y, const numerical auto& Z) noexcept : x(fat4(X)), y(fat4(Y)), z(fat4(Z)) {}
  constexpr vector(const numerical auto& X, const numerical auto& Y, const numerical auto& Z, const numerical auto& W) noexcept : x(fat4(X)), y(fat4(Y)), z(fat4(Z)), w(fat4(W)) {}
  vector(const xvector& Xv) noexcept { _mm_store_ps(&x, Xv); }
  explicit constexpr operator vector2() const noexcept { return {x, y}; }
  explicit constexpr operator vector3() const noexcept { return {x, y, z}; }
  operator xvector() const noexcept { return xvload(&x); }
  constexpr fat4 power() const noexcept { if (is_cev) return x * x + y * y + z * z + w * w; else return [](auto&& a) { return xvget<0>(xvdot<4>(a, a)); }(xvload(&x)); }
  fat4 length() const noexcept { return [](auto&& a) { return std::sqrt(xvget<0>(xvdot<4>(a, a))); }(xvload(&x)); }
  constexpr nat size() const noexcept { return count; }
  fat4* data() noexcept { return &x; }
  const fat4* data() const noexcept { return &x; }
  fat4* begin() noexcept { return &x; }
  const fat4* begin() const noexcept { return &x; }
  fat4* end() noexcept { return &x + count; }
  const fat4* end() const noexcept { return &x + count; }
  fat4& operator[](nat i) { return *(&x + i); }
  const fat4& operator[](nat i) const { return *(&x + i); }
  template<nat I> requires(I < 4) fat4& get() noexcept { return select_parameter<I>(x, y, z, w); }
  template<nat I> requires(I < 4) fat4 get() const noexcept { return select_parameter<I>(x, y, z, w); }
  friend constexpr bool operator==(const vector& A, const vector& B) noexcept { return A.x == B.x && A.y == B.y && A.z == B.z && A.w == B.w; }
  friend constexpr auto operator<=>(const vector& A, const vector& B) noexcept {
    if (auto a = A.x <=> B.x; a != 0) return a; else if (a = A.y <=> B.y; a != 0) return a;
    else if (a = A.z <=> B.z; a != 0) return a; else return A.w <=> B.w; }
  friend constexpr vector operator+(const vector& A) noexcept { return A; }
  friend constexpr vector operator-(const vector& A) noexcept { return {-A.x, -A.y, -A.z, -A.w}; }
  friend constexpr vector operator+(const vector& A, const vector& B) noexcept { return {A.x + B.x, A.y + B.y, A.z + B.z, A.w + B.w}; }
  friend constexpr vector operator-(const vector& A, const vector& B) noexcept { return {A.x - B.x, A.y - B.y, A.z - B.z, A.w - B.w}; }
  friend constexpr vector operator*(const vector& A, const vector& B) noexcept { return {A.x * B.x, A.y * B.y, A.z * B.z, A.w * B.w}; }
  friend constexpr vector operator/(const vector& A, const vector& B) noexcept { return {A.x / B.x, A.y / B.y, A.z / B.z, A.w / B.w}; }
  friend constexpr vector operator*(const vector& A, const fat4& B) noexcept { return {A.x * B, A.y * B, A.z * B, A.w * B}; }
  friend constexpr vector operator/(const vector& A, const fat4& B) noexcept { return {A.x / B, A.y / B, A.z / B, A.w / B}; }
  friend constexpr vector operator*(const fat4& A, const vector& B) noexcept { return {A * B.x, A * B.y, A * B.z, A * B.w}; }
  friend constexpr vector operator/(const fat4& A, const vector& B) noexcept { return {A / B.x, A / B.y, A / B.z, A / B.w}; }
  friend constexpr vector operator*(const vector& A, const numerical auto& B) noexcept { return A * fat4(B); }
  friend constexpr vector operator/(const vector& A, const numerical auto& B) noexcept { return A / fat4(B); }
  friend constexpr vector operator*(const numerical auto& A, const vector& B) noexcept { return fat4(A) * B; }
  friend constexpr vector operator/(const numerical auto& A, const vector& B) noexcept { return fat4(A) / B; }
  friend constexpr vector operator+=(vector& A, const vector& B) noexcept { return A = A + B; }
  friend constexpr vector operator-=(vector& A, const vector& B) noexcept { return A = A - B; }
  friend constexpr vector operator*=(vector& A, const vector& B) noexcept { return A = A * B; }
  friend constexpr vector operator/=(vector& A, const vector& B) noexcept { return A = A / B; }
  friend constexpr vector operator*=(vector& A, const numerical auto& B) noexcept { return A = A * fat4(B); }
  friend constexpr vector operator/=(vector& A, const numerical auto& B) noexcept { return A = A / fat4(B); }
  friend constexpr fat4 dot(const vector& A, const vector& B) noexcept { return A.x * B.x + A.y * B.y + A.z * B.z + A.w * B.w; }
};
}

namespace std {
template<> struct tuple_size<yw::vector2> : integral_constant<size_t, 2> {};
template<size_t I> requires (I < 2) struct tuple_element<I, yw::vector2> : type_identity<float> {};
template<typename Ct> struct formatter<yw::vector2, Ct> : formatter<basic_string<Ct>, Ct> {
  auto format(const yw::vector2& V, auto& Ctx) const {
    if constexpr (same_as<remove_cv_t<Ct>, char>)
      return formatter<basic_string<Ct>, Ct>::format(std::format("{{{}, {}}}", V.x, V.y), Ctx);
    else if constexpr (same_as<remove_cv_t<Ct>, wchar_t>)
      return formatter<basic_string<Ct>, Ct>::format(std::format(L"{{{}, {}}}", V.x, V.y), Ctx); } };
template<typename Ct, typename Tr> basic_ostringstream<Ct, Tr>& operator<<(
  basic_ostringstream<Ct, Tr>& Os, const yw::vector2& V) { return Os << '{' << V.x << ", " << V.y << '}'; }
template<> struct tuple_size<yw::vector3> : integral_constant<size_t, 3> {};
template<size_t I> requires (I < 3) struct tuple_element<I, yw::vector3> : type_identity<float> {};
template<typename Ct> struct formatter<yw::vector3, Ct> : formatter<basic_string<Ct>, Ct> {
  auto format(const yw::vector3& V, auto& Ctx) const {
    if constexpr (same_as<remove_cv_t<Ct>, char>)
      return formatter<basic_string<Ct>, Ct>::format(std::format("{{{}, {}, {}}}", V.x, V.y, V.z), Ctx);
    else if constexpr (same_as<remove_cv_t<Ct>, wchar_t>)
      return formatter<basic_string<Ct>, Ct>::format(std::format(L"{{{}, {}, {}}}", V.x, V.y, V.z), Ctx); } };
template<typename Ct, typename Tr> basic_ostringstream<Ct, Tr>& operator<<(
  basic_ostringstream<Ct, Tr>& Os, const yw::vector3& V) { return Os << '{' << V.x << ", " << V.y << ", " << V.z << '}'; }
template<> struct tuple_size<yw::vector> : integral_constant<size_t, 4> {};
template<size_t I> requires (I < 4) struct tuple_element<I, yw::vector> : type_identity<float> {};
template<typename Ct> struct formatter<yw::vector, Ct> : formatter<basic_string<Ct>, Ct> {
  auto format(const yw::vector& V, auto& Ctx) const {
    if constexpr (same_as<remove_cv_t<Ct>, char>)
      return formatter<basic_string<Ct>, Ct>::format(std::format("{{{}, {}, {}, {}}}", V.x, V.y, V.z, V.w), Ctx);
    else if constexpr (same_as<remove_cv_t<Ct>, wchar_t>)
      return formatter<basic_string<Ct>, Ct>::format(std::format(L"{{{}, {}, {}, {}}}", V.x, V.y, V.z, V.w), Ctx); } };
template<typename Ct, typename Tr> basic_ostringstream<Ct, Tr>& operator<<(
  basic_ostringstream<Ct, Tr>& Os, const yw::vector& V) { return Os << '{' << V.x << ", " << V.y << ", " << V.z << ", " << V.w << '}'; }
}

namespace yw { // yw::vector, yw::wector, yw::rect

struct wector;
struct rect;

struct wector {
  fat8 x{}, y{}, z{}, w{};
  constexpr wector() noexcept = default;
  explicit constexpr wector(const fat8 Fill) noexcept : x(Fill), y(Fill), z(Fill), w(Fill) {}
  explicit constexpr wector(const numerical auto Fill) noexcept : wector(fat8(Fill)) {}
  constexpr wector(const numerical auto X, const numerical auto Y, const numerical auto Z, const numerical auto W) noexcept : x(fat8(X)), y(fat8(Y)), z(fat8(Z)), w(fat8(W)) {}
  constexpr wector(const numerical auto X, const numerical auto Y, const numerical auto Z) noexcept : x(fat8(X)), y(fat8(Y)), z(fat8(Z)) {}
  constexpr wector(const numerical auto X, const numerical auto Y) noexcept : x(fat8(X)), y(fat8(Y)) {}
  wector(const xwector& A) noexcept { _mm256_storeu_pd(&x, A); }
  wector& operator=(const xwector& A) noexcept { return _mm256_storeu_pd(&x, A), *this; }
  operator xwector() const noexcept { return xvload(&x); }
  constexpr nat size() const noexcept { return 4; }
  fat8* data() noexcept { return &x; }
  const fat8* data() const noexcept { return &x; }
  fat8* begin() noexcept { return &x; }
  const fat8* begin() const noexcept { return &x; }
  fat8* end() noexcept { return &x + 4; }
  const fat8* end() const noexcept { return &x + 4; }
  fat8& operator[](nat i) { return *(&x + i); }
  const fat8& operator[](nat i) const { return *(&x + i); }
  template<nat Ix> requires(Ix < 4) constexpr fat8& get() noexcept { return select_parameter<Ix>(x, y, z, w); }
  template<nat Ix> requires(Ix < 4) constexpr fat8 get() const noexcept { return select_parameter<Ix>(x, y, z, w); }
  friend constexpr bool operator==(const wector& A, const wector& B) noexcept {
    if (!is_cev) return xveq(A, B);
    return A.x == B.x && A.y == B.y && A.z == B.z && A.w == B.w;
  }
  friend constexpr auto operator<=>(const wector& A, const wector& B) noexcept {
    if (!is_cev) return std::partial_ordering(xvtw(A, B));
    if (auto a = A.x <=> B.x; a != 0) return a;
    else if (a = A.y <=> B.y; a != 0) return a;
    else if (a = A.z <=> B.z; a != 0) return a;
    else return A.w <=> B.w;
  }
  friend constexpr wector operator+(const wector& A) noexcept { return A; }
  friend constexpr wector operator-(const wector& A) noexcept {
    if (!is_cev) return xvneg(A);
    else return {-A.x, -A.y, -A.z, -A.w};
  }
  friend constexpr wector operator+(const wector& A, const wector& B) noexcept {
    if (!is_cev) return xvadd(A, B);
    else return {A.x + B.x, A.y + B.y, A.z + B.z, A.w + B.w};
  }
  friend constexpr wector operator-(const wector& A, const wector& B) noexcept {
    if (!is_cev) return xvsub(A, B);
    else return {A.x - B.x, A.y - B.y, A.z - B.z, A.w - B.w};
  }
  friend constexpr wector operator*(const wector& A, const wector& B) noexcept {
    if (!is_cev) return xvmul(A, B);
    else return {A.x * B.x, A.y * B.y, A.z * B.z, A.w * B.w};
  }
  friend constexpr wector operator/(const wector& A, const wector& B) noexcept {
    if (!is_cev) return xvdiv(A, B);
    else return {A.x / B.x, A.y / B.y, A.z / B.z, A.w / B.w};
  }
  friend constexpr wector operator+(const wector& A, const fat8& B) noexcept {
    if (!is_cev) return xvadd(A, xvload(B));
    else return {A.x + B, A.y + B, A.z + B, A.w + B};
  }
  friend constexpr wector operator-(const wector& A, const fat8& B) noexcept {
    if (!is_cev) return xvsub(A, xvload(B));
    else return {A.x - B, A.y - B, A.z - B, A.w - B};
  }
  friend constexpr wector operator*(const wector& A, const fat8& B) noexcept {
    if (!is_cev) return xvmul(A, xvload(B));
    else return {A.x * B, A.y * B, A.z * B, A.w * B};
  }
  friend constexpr wector operator/(const wector& A, const fat8& B) noexcept {
    if (!is_cev) return xvdiv(A, xvload(B));
    else return {A.x / B, A.y / B, A.z / B, A.w / B};
  }
  friend constexpr wector operator+(const fat8& A, const wector& B) noexcept {
    if (!is_cev) return xvadd(xvload(A), B);
    else return {A + B.x, A + B.y, A + B.z, A + B.w};
  }
  friend constexpr wector operator-(const fat8& A, const wector& B) noexcept {
    if (!is_cev) return xvsub(xvload(A), B);
    else return {A - B.x, A - B.y, A - B.z, A - B.w};
  }
  friend constexpr wector operator*(const fat8& A, const wector& B) noexcept {
    if (!is_cev) return xvmul(xvload(A), B);
    else return {A * B.x, A * B.y, A * B.z, A * B.w};
  }
  friend constexpr wector operator/(const fat8& A, const wector& B) noexcept {
    if (!is_cev) return xvdiv(xvload(A), B);
    else return {A / B.x, A / B.y, A / B.z, A / B.w};
  }
  friend constexpr wector& operator+=(wector& A, const wector& B) noexcept { return A = A + B; }
  friend constexpr wector& operator-=(wector& A, const wector& B) noexcept { return A = A - B; }
  friend constexpr wector& operator*=(wector& A, const wector& B) noexcept { return A = A * B; }
  friend constexpr wector& operator/=(wector& A, const wector& B) noexcept { return A = A / B; }
  friend constexpr wector& operator+=(wector& A, const fat8& B) noexcept { return A = A + B; }
  friend constexpr wector& operator-=(wector& A, const fat8& B) noexcept { return A = A - B; }
  friend constexpr wector& operator*=(wector& A, const fat8& B) noexcept { return A = A * B; }
  friend constexpr wector& operator/=(wector& A, const fat8& B) noexcept { return A = A / B; }
  constexpr wector to_wector() const noexcept;
  constexpr rect to_rect() const noexcept;
};

struct rect {
  int left{}, top{}, right{}, bottom{};
  constexpr int width() const noexcept { return right - left; }
  constexpr int height() const noexcept { return bottom - top; }
  constexpr rect() noexcept = default;
  explicit constexpr rect(const int Fill) noexcept : left(Fill), top(Fill), right(Fill), bottom(Fill) {}
  template<castable_to<int> T> requires(!same_as<remove_cvref<T>, int>)
  explicit constexpr rect(T&& Fill) noexcept(nt_castable_to<T, int>) : rect(static_cast<int>(fwd<T>(Fill))) {}
  template<castable_to<int> T0, castable_to<int> T1, castable_to<int> T2, castable_to<int> T3>
  constexpr rect(T0&& L, T1&& T, T2&& R, T3&& B) noexcept(nt_castable_to<T0, int> && nt_castable_to<T1, int> && nt_castable_to<T2, int> && nt_castable_to<T3, int>)
    : left(static_cast<int>(fwd<T0>(L))), top(static_cast<int>(fwd<T1>(T))), right(static_cast<int>(fwd<T2>(R))), bottom(static_cast<int>(fwd<T3>(B))) {}
  rect(const xrect& A) noexcept { _mm_storeu_epi32(&left, A); }
  rect& operator=(const xrect& A) noexcept { return _mm_storeu_epi32(&left, A), *this; }
  operator xrect() const noexcept { return xvload(&left); }
  constexpr nat size() const noexcept { return 4; }
  int* data() noexcept { return &left; }
  const int* data() const noexcept { return &left; }
  int* begin() noexcept { return &left; }
  const int* begin() const noexcept { return &left; }
  int* end() noexcept { return &left + 4; }
  const int* end() const noexcept { return &left + 4; }
  template<nat Ix> requires(Ix < 4) constexpr int& get() noexcept {
    if constexpr (Ix == 0) return left;
    else if constexpr (Ix == 1) return top;
    else if constexpr (Ix == 2) return right;
    else return bottom;
  }
  template<nat Ix> requires(Ix < 4) constexpr int get() const noexcept {
    if constexpr (Ix == 0) return left;
    else if constexpr (Ix == 1) return top;
    else if constexpr (Ix == 2) return right;
    else return bottom;
  }
  friend constexpr bool operator==(const rect& A, const rect& B) noexcept {
    if (!is_cev) return xveq(A, B);
    return A.left == B.left && A.top == B.top && A.right == B.right && A.bottom == B.bottom;
  }
  friend constexpr auto operator<=>(const rect& A, const rect& B) noexcept {
    if (!is_cev) return xvtw(A, B);
    if (auto a = A.left <=> B.left; a != 0) return a;
    else if (a = A.top <=> B.top; a != 0) return a;
    else if (a = A.right <=> B.right; a != 0) return a;
    else return A.bottom <=> B.bottom;
  }
  friend constexpr rect operator+(const rect& A) noexcept { return A; }
  friend constexpr rect operator-(const rect& A) noexcept {
    if (!is_cev) return xvneg(A);
    else return {-A.left, -A.top, -A.right, -A.bottom};
  }
  friend constexpr rect operator+(const rect& A, const rect& B) noexcept {
    if (!is_cev) return xvadd(A, B);
    else return {A.left + B.left, A.top + B.top, A.right + B.right, A.bottom + B.bottom};
  }
  friend constexpr rect operator-(const rect& A, const rect& B) noexcept {
    if (!is_cev) return xvsub(A, B);
    else return {A.left - B.left, A.top - B.top, A.right - B.right, A.bottom - B.bottom};
  }
  friend constexpr rect operator*(const rect& A, const rect& B) noexcept {
    if (!is_cev) return xvmul(A, B);
    else return {A.left * B.left, A.top * B.top, A.right * B.right, A.bottom * B.bottom};
  }
  friend constexpr rect operator/(const rect& A, const rect& B) noexcept {
    if (!is_cev) return xvdiv(A, B);
    else return {A.left / B.left, A.top / B.top, A.right / B.right, A.bottom / B.bottom};
  }
  friend constexpr rect operator+(const rect& A, const int& B) noexcept {
    if (!is_cev) return xvadd(A, xvload(B));
    else return {A.left + B, A.top + B, A.right + B, A.bottom + B};
  }
  friend constexpr rect operator-(const rect& A, const int& B) noexcept {
    if (!is_cev) return xvsub(A, xvload(B));
    else return {A.left - B, A.top - B, A.right - B, A.bottom - B};
  }
  friend constexpr rect operator*(const rect& A, const int& B) noexcept {
    if (!is_cev) return xvmul(A, xvload(B));
    else return {A.left * B, A.top * B, A.right * B, A.bottom * B};
  }
  friend constexpr rect operator/(const rect& A, const int& B) noexcept {
    if (!is_cev) return xvdiv(A, xvload(B));
    else return {A.left / B, A.top / B, A.right / B, A.bottom / B};
  }
  friend constexpr rect operator+(const int& A, const rect& B) noexcept {
    if (!is_cev) return xvadd(xvload(A), B);
    else return {A + B.left, A + B.top, A + B.right, A + B.bottom};
  }
  friend constexpr rect operator-(const int& A, const rect& B) noexcept {
    if (!is_cev) return xvsub(xvload(A), B);
    else return {A - B.left, A - B.top, A - B.right, A - B.bottom};
  }
  friend constexpr rect operator*(const int& A, const rect& B) noexcept {
    if (!is_cev) return xvmul(xvload(A), B);
    else return {A * B.left, A * B.top, A * B.right, A * B.bottom};
  }
  friend constexpr rect operator/(const int& A, const rect& B) noexcept {
    if (!is_cev) return xvdiv(xvload(A), B);
    else return {A / B.left, A / B.top, A / B.right, A / B.bottom};
  }
  friend constexpr rect& operator+=(rect& A, const rect& B) noexcept { return A = A + B; }
  friend constexpr rect& operator-=(rect& A, const rect& B) noexcept { return A = A - B; }
  friend constexpr rect& operator*=(rect& A, const rect& B) noexcept { return A = A * B; }
  friend constexpr rect& operator/=(rect& A, const rect& B) noexcept { return A = A / B; }
  friend constexpr rect& operator+=(rect& A, const int& B) noexcept { return A = A + B; }
  friend constexpr rect& operator-=(rect& A, const int& B) noexcept { return A = A - B; }
  friend constexpr rect& operator*=(rect& A, const int& B) noexcept { return A = A * B; }
  friend constexpr rect& operator/=(rect& A, const int& B) noexcept { return A = A / B; }
  constexpr vector to_vector() const noexcept {
    if (is_cev) return {float(left), float(top), float(right), float(bottom)};
    else return {xvcast<xvector>(*this)};
  }
};

// constexpr rect vector::to_rect() const noexcept {
//   if (is_cev) return {int(x), int(y), int(z), int(w)};
//   else return {xvcast<xrect>(*this)};
// }

// constexpr wector vector::to_wector() const noexcept {
//   if (is_cev) return {fat8(x), fat8(y), fat8(z), fat8(w)};
//   else return {xvcast<xwector>(*this)};
// }
}

namespace std {
template<> struct tuple_size<yw::wector> : integral_constant<size_t, 4> {};
template<size_t I> requires (I < 4) struct tuple_element<I, yw::wector> : type_identity<double> {};
template<typename Ct> struct formatter<yw::wector, Ct> : formatter<basic_string<Ct>, Ct> {
  using base = formatter<basic_string<Ct>, Ct>;
  auto format(const yw::wector& v, auto& c) const {
    if constexpr (same_as<Ct, char>) return base::format(format("({}, {}, {}, {})", v.x, v.y, v.z, v.w), c);
    else return base::format(format(L"({}, {}, {}, {})", v.x, v.y, v.z, v.w), c); } };
template<> struct tuple_size<yw::rect> : integral_constant<size_t, 4> {};
template<size_t I> requires (I < 4) struct tuple_element<I, yw::rect> : type_identity<int> {};
template<typename Ct> struct formatter<yw::rect, Ct> : formatter<basic_string<Ct>, Ct> {
  using base = formatter<basic_string<Ct>, Ct>;
  auto format(const yw::rect& r, auto& c) const {
    if constexpr (same_as<Ct, char>) return base::format(format("({}, {}, {}, {})", r.left, r.top, r.right, r.bottom), c);
    else return base::format(format(L"({}, {}, {}, {})", r.left, r.top, r.right, r.bottom), c); } };
}

namespace yw { // yw::color

/// class to repreesnt a color in RGB format.
struct color {
  struct rgb;
  struct hsv;
  fat4 r = 0.f; // Red [0..1]
  fat4 g = 0.f; // Blue [0..1]
  fat4 b = 0.f; // Green [0..1]
  fat4 a = 1.f; // Alpha [0..1]
  constexpr color() noexcept = default;
  constexpr color(const numerical auto R, const numerical auto G, const numerical auto B) noexcept : r(fat4(R)), g(fat4(G)), b(fat4(B)) {}
  constexpr color(const numerical auto R, const numerical auto G, const numerical auto B, const numerical auto A) noexcept : r(fat4(R)), g(fat4(G)), b(fat4(B)), a(fat4(A)) {}
  static const color black, dimgray, gray, darkgray, silver, lightgray, gainsboro, whitesmoke, white, snow, ghostwhite, floralwhite, linen, antiquewhite,
    papayawhip, blanchedalmond, bisque, moccasin, navajowhite, peachpuff, mistyrose, lavenderblush, seashell, oldlace, ivory, honeydew, mintcream, azure,
    aliceblue, lavender, lightsteelblue, lightslategray, slategray, steelblue, royalblue, midnightblue, navy, darkblue, mediumblue, blue, dodgerblue,
    cornflowerblue, deepskyblue, lightskyblue, skyblue, lightblue, powderblue, paleturquoise, lightcyan, cyan, aqua, turquoise, mediumturquoise, darkturquoise,
    lightseagreen, cadetblue, darkcyan, teal, darkslategray, darkgreen, green, forestgreen, seagreen, mediumseagreen, mediumaquamarine, darkseagreen, aquamarine,
    palegreen, lightgreen, springgreen, mediumspringgreen, lawngreen, chartreuse, greenyellow, lime, limegreen, yellowgreen, darkolivegreen, olivedrab, olive,
    darkkhaki, palegoldenrod, cornsilk, beige, lightyellow, lightgoldenrodyellow, lemonchiffon, wheat, burlywood, tan, khaki, yellow, gold, orange, sandybrown,
    darkorange, goldenrod, peru, darkgoldenrod, chocolate, sienna, saddlebrown, maroon, darkred, brown, firebrick, indianred, rosybrown, darksalmon, lightcoral,
    salmon, lightsalmon, coral, tomato, orangered, red, crimson, mediumvioletred, deeppink, hotpink, palevioletred, pink, lightpink, thistle, magenta, fuchsia,
    violet, plum, orchid, mediumorchid, darkorchid, darkviolet, darkmagenta, purple, indigo, darkslateblue, blueviolet, mediumpurple, slateblue, mediumslateblue,
    transparent, undefined, yw;
  template<nat I> requires (I < 4) constexpr fat4& get() noexcept { return select_parameter<I>(r, g, b, a); }
  template<nat I> requires (I < 4) constexpr fat4 get() const noexcept { return select_parameter<I>(r, g, b, a); }
  template<typename Ct, typename Tr> friend auto& operator<<(std::basic_ostream<Ct, Tr>& os, const color& c) {
    return os << "RGBA(" << c.r << ", " << c.g << ", " << c.b << ", " << c.a << ')';
  }
};

/// class to repreesnt a color in RGB format.
struct color::rgb {
  fat4 r = 0.f; // Red [0..1]
  fat4 g = 0.f; // Blue [0..1]
  fat4 b = 0.f; // Green [0..1]
  fat4 a = 1.f; // Alpha [0..1]
  constexpr rgb() noexcept = default;
  constexpr rgb(const color& c) noexcept : r(c.r), g(c.g), b(c.b), a(c.a) {}
  constexpr operator color() const noexcept { return {r, g, b, a}; }
  constexpr rgb(const numerical auto R, const numerical auto G, const numerical auto B) noexcept : r(fat4(R)), g(fat4(G)), b(fat4(B)) {}
  constexpr rgb(const numerical auto R, const numerical auto G, const numerical auto B, const numerical auto A) noexcept : r(fat4(R)), g(fat4(G)), b(fat4(B)), a(fat4(A)) {}
  explicit constexpr rgb(unsigned xRRGGBB, fat4 A = 1.f) noexcept : rgb(from_hex(xRRGGBB, A)) {}
  explicit constexpr operator unsigned() const noexcept { return to_hex(*this); }
  explicit rgb(const xvector& Xv) noexcept { _mm_storeu_ps(&r, Xv); }
  operator xvector() const noexcept { return xvload(&r); }
  template<nat Ix> requires(Ix < 4) constexpr fat4& get() noexcept { return select_parameter<Ix>(r, g, b, a); }
  template<nat Ix> requires(Ix < 4) constexpr fat4 get() const noexcept { return select_parameter<Ix>(r, g, b, a); }
  template<typename Ct, typename Tr> friend auto& operator<<(std::basic_ostream<Ct, Tr>& os, const rgb& c) {
    return os << "RGBA(" << c.r << ", " << c.g << ", " << c.b << ", " << c.a << ')';
  }
private:
  static constexpr rgb from_hex(const unsigned x, const fat4 A) noexcept {
    if constexpr (is_cev) return {fat4((0xff0000 & x) >> 16) / 255.f, fat4((0xff00 & x) >> 8) / 255.f, fat4(0xff & x) / 255.f, A};
    else return rgb(xvset<3>(xvmul(xv_constant<1.0 / 255.0>, _mm_cvtepi32_ps(_mm_cvtepu8_epi32(xvbitcast(_mm_broadcast_ss((const float*)&x))))), A));
  }
  static constexpr unsigned to_hex(const rgb& a) noexcept {
    if constexpr (is_cev) return (unsigned)(a.r * 255.f) << 16 | (unsigned)(a.g * 255.f) << 6 | (unsigned)(a.b * 255.f) | (unsigned)(a.a * 255.f) << 24;
    else return bitcast<unsigned>(_mm_cvtsi128_si32(_mm_shuffle_epi8(_mm_cvtps_epi32(xvmul(xvload(&a.r), xv_constant<255>)), xv_constant<0, 0, 0, 0x03020100>)));
  }
};

/// class to repreesnt a color in HSV format.
struct color::hsv {
  fat4 h = 0.f; // Hue [0..1]
  fat4 s = 0.f; // Saturation [0..1]
  fat4 v = 0.f; // Chroma [0..1]
  fat4 a = 1.f; // Alpha [0..1]
  constexpr hsv() noexcept = default;
  constexpr hsv(const color& c) noexcept : hsv(from_rgb(c)) {}
  constexpr operator color() const noexcept { return to_rgb(*this); }
  explicit constexpr hsv(const rgb& RGB) noexcept : hsv(from_rgb(RGB)) {}
  explicit constexpr operator rgb() const noexcept { return to_rgb(*this); }
  constexpr hsv(const numerical auto H, const numerical auto S, const numerical auto V) noexcept : h(fat4(H)), s(fat4(S)), v(fat4(V)) {}
  constexpr hsv(const numerical auto H, const numerical auto S, const numerical auto V, const numerical auto A) noexcept : h(fat4(H)), s(fat4(S)), v(fat4(V)), a(fat4(A)) {}

private:
  static constexpr rgb to_rgb(const hsv& HSV) noexcept {
    if (HSV.s == 0.f) return rgb(HSV.v, HSV.v, HSV.v, HSV.a);
    else if (HSV.h < 0.5f) {
      if      (cev(2 / 6.f) < HSV.h) return rgb(HSV.v - HSV.s, HSV.v, HSV.v - 3 * HSV.s + 6 * HSV.h * HSV.s, HSV.a);
      else if (cev(1 / 6.f) < HSV.h) return rgb(HSV.v + HSV.s - 6 * HSV.h * HSV.s, HSV.v, HSV.v - HSV.s, HSV.a);
      else if (cev(0 / 6.f) < HSV.h) return rgb(HSV.v, HSV.v - HSV.s + 6 * HSV.h * HSV.s, HSV.v - HSV.s, HSV.a);
      else return rgb(0.f, 0.f, 0.f, HSV.a);
    } else {
      if      (HSV.h < cev(4.f / 6.f)) return rgb(HSV.v - HSV.s, HSV.v + 3 * HSV.s - 6 * HSV.h * HSV.s, HSV.v, HSV.a);
      else if (HSV.h < cev(5.f / 6.f)) return rgb(HSV.v - 5 * HSV.s + 6 * HSV.h * HSV.s, HSV.v - HSV.s, HSV.v, HSV.a);
      else if (HSV.h < 1.f)            return rgb(HSV.v, HSV.v - HSV.s, HSV.v + 5 * HSV.s - 6 * HSV.h * HSV.s, HSV.a);
      else return rgb(0.f, 0.f, 0.f, HSV.a);
    }
  }
  static constexpr hsv from_rgb(const rgb& RGB) noexcept {
    auto min = yw::mini(RGB.r, RGB.g, RGB.b);
    if (fat4 v = yw::max(RGB.r, RGB.g, RGB.b); v == min.second) return {0.f, 0.f, v, RGB.a};
    else if (fat4 s = v - min.second; min.first == 0) return {cev(1.0f / 6.0f) * ((RGB.b - RGB.g) / s + 3.f), s, v, RGB.a};
    else if (min.first == 1) return {cev(1.0f / 6.0f) * ((RGB.r - RGB.b) / s + 5.f), s, v, RGB.a};
    else return {cev(1.0f / 6.0f) * ((RGB.g - RGB.r) / s + 1.f), s, v, RGB.a};
  }
};

inline constexpr color color::black = color::rgb(0x000000);
inline constexpr color color::dimgray = color::rgb(0x696969);
inline constexpr color color::gray = color::rgb(0x808080);
inline constexpr color color::darkgray = color::rgb(0xa9a9a9);
inline constexpr color color::silver = color::rgb(0xc0c0c0);
inline constexpr color color::lightgray = color::rgb(0xd3d3d3);
inline constexpr color color::gainsboro = color::rgb(0xdcdcdc);
inline constexpr color color::whitesmoke = color::rgb(0xf5f5f5);
inline constexpr color color::white = color::rgb(0xffffff);
inline constexpr color color::snow = color::rgb(0xfffafa);
inline constexpr color color::ghostwhite = color::rgb(0xf8f8ff);
inline constexpr color color::floralwhite = color::rgb(0xfffaf0);
inline constexpr color color::linen = color::rgb(0xfaf0e6);
inline constexpr color color::antiquewhite = color::rgb(0xfaebd7);
inline constexpr color color::papayawhip = color::rgb(0xffefd5);
inline constexpr color color::blanchedalmond = color::rgb(0xffebcd);
inline constexpr color color::bisque = color::rgb(0xffe4c4);
inline constexpr color color::moccasin = color::rgb(0xffe4b5);
inline constexpr color color::navajowhite = color::rgb(0xffdead);
inline constexpr color color::peachpuff = color::rgb(0xffdab9);
inline constexpr color color::mistyrose = color::rgb(0xffe4e1);
inline constexpr color color::lavenderblush = color::rgb(0xfff0f5);
inline constexpr color color::seashell = color::rgb(0xfff5ee);
inline constexpr color color::oldlace = color::rgb(0xfdf5e6);
inline constexpr color color::ivory = color::rgb(0xfffff0);
inline constexpr color color::honeydew = color::rgb(0xf0fff0);
inline constexpr color color::mintcream = color::rgb(0xf5fffa);
inline constexpr color color::azure = color::rgb(0xf0ffff);
inline constexpr color color::aliceblue = color::rgb(0xf0f8ff);
inline constexpr color color::lavender = color::rgb(0xe6e6fa);
inline constexpr color color::lightsteelblue = color::rgb(0xb0c4de);
inline constexpr color color::lightslategray = color::rgb(0x778899);
inline constexpr color color::slategray = color::rgb(0x708090);
inline constexpr color color::steelblue = color::rgb(0x4682b4);
inline constexpr color color::royalblue = color::rgb(0x4169e1);
inline constexpr color color::midnightblue = color::rgb(0x191970);
inline constexpr color color::navy = color::rgb(0x000080);
inline constexpr color color::darkblue = color::rgb(0x00008b);
inline constexpr color color::mediumblue = color::rgb(0x0000cd);
inline constexpr color color::blue = color::rgb(0x0000ff);
inline constexpr color color::dodgerblue = color::rgb(0x1e90ff);
inline constexpr color color::cornflowerblue = color::rgb(0x6495ed);
inline constexpr color color::deepskyblue = color::rgb(0x00bfff);
inline constexpr color color::lightskyblue = color::rgb(0x87cefa);
inline constexpr color color::skyblue = color::rgb(0x87ceeb);
inline constexpr color color::lightblue = color::rgb(0xadd8e6);
inline constexpr color color::powderblue = color::rgb(0xb0e0e6);
inline constexpr color color::paleturquoise = color::rgb(0xafeeee);
inline constexpr color color::lightcyan = color::rgb(0xe0ffff);
inline constexpr color color::cyan = color::rgb(0x00ffff);
inline constexpr color color::aqua = color::rgb(0x00ffff);
inline constexpr color color::turquoise = color::rgb(0x40e0d0);
inline constexpr color color::mediumturquoise = color::rgb(0x48d1cc);
inline constexpr color color::darkturquoise = color::rgb(0x00ced1);
inline constexpr color color::lightseagreen = color::rgb(0x20b2aa);
inline constexpr color color::cadetblue = color::rgb(0x5f9ea0);
inline constexpr color color::darkcyan = color::rgb(0x008b8b);
inline constexpr color color::teal = color::rgb(0x008080);
inline constexpr color color::darkslategray = color::rgb(0x2f4f4f);
inline constexpr color color::darkgreen = color::rgb(0x006400);
inline constexpr color color::green = color::rgb(0x008000);
inline constexpr color color::forestgreen = color::rgb(0x228b22);
inline constexpr color color::seagreen = color::rgb(0x2e8b57);
inline constexpr color color::mediumseagreen = color::rgb(0x3cb371);
inline constexpr color color::mediumaquamarine = color::rgb(0x66cdaa);
inline constexpr color color::darkseagreen = color::rgb(0x8fbc8f);
inline constexpr color color::aquamarine = color::rgb(0x7fffd4);
inline constexpr color color::palegreen = color::rgb(0x98fb98);
inline constexpr color color::lightgreen = color::rgb(0x90ee90);
inline constexpr color color::springgreen = color::rgb(0x00ff7f);
inline constexpr color color::mediumspringgreen = color::rgb(0x00fa9a);
inline constexpr color color::lawngreen = color::rgb(0x7cfc00);
inline constexpr color color::chartreuse = color::rgb(0x7fff00);
inline constexpr color color::greenyellow = color::rgb(0xadff2f);
inline constexpr color color::lime = color::rgb(0x00ff00);
inline constexpr color color::limegreen = color::rgb(0x32cd32);
inline constexpr color color::yellowgreen = color::rgb(0x9acd32);
inline constexpr color color::darkolivegreen = color::rgb(0x556b2f);
inline constexpr color color::olivedrab = color::rgb(0x6b8e23);
inline constexpr color color::olive = color::rgb(0x808000);
inline constexpr color color::darkkhaki = color::rgb(0xbdb76b);
inline constexpr color color::palegoldenrod = color::rgb(0xeee8aa);
inline constexpr color color::cornsilk = color::rgb(0xfff8dc);
inline constexpr color color::beige = color::rgb(0xf5f5dc);
inline constexpr color color::lightyellow = color::rgb(0xffffe0);
inline constexpr color color::lightgoldenrodyellow = color::rgb(0xfafad2);
inline constexpr color color::lemonchiffon = color::rgb(0xfffacd);
inline constexpr color color::wheat = color::rgb(0xf5deb3);
inline constexpr color color::burlywood = color::rgb(0xdeb887);
inline constexpr color color::tan = color::rgb(0xd2b48c);
inline constexpr color color::khaki = color::rgb(0xf0e68c);
inline constexpr color color::yellow = color::rgb(0xffff00);
inline constexpr color color::gold = color::rgb(0xffd700);
inline constexpr color color::orange = color::rgb(0xffa500);
inline constexpr color color::sandybrown = color::rgb(0xf4a460);
inline constexpr color color::darkorange = color::rgb(0xff8c00);
inline constexpr color color::goldenrod = color::rgb(0xdaa520);
inline constexpr color color::peru = color::rgb(0xcd853f);
inline constexpr color color::darkgoldenrod = color::rgb(0xb8860b);
inline constexpr color color::chocolate = color::rgb(0xd2691e);
inline constexpr color color::sienna = color::rgb(0xa0522d);
inline constexpr color color::saddlebrown = color::rgb(0x8b4513);
inline constexpr color color::maroon = color::rgb(0x800000);
inline constexpr color color::darkred = color::rgb(0x8b0000);
inline constexpr color color::brown = color::rgb(0xa52a2a);
inline constexpr color color::firebrick = color::rgb(0xb22222);
inline constexpr color color::indianred = color::rgb(0xcd5c5c);
inline constexpr color color::rosybrown = color::rgb(0xbc8f8f);
inline constexpr color color::darksalmon = color::rgb(0xe9967a);
inline constexpr color color::lightcoral = color::rgb(0xf08080);
inline constexpr color color::salmon = color::rgb(0xfa8072);
inline constexpr color color::lightsalmon = color::rgb(0xffa07a);
inline constexpr color color::coral = color::rgb(0xff7f50);
inline constexpr color color::tomato = color::rgb(0xff6347);
inline constexpr color color::orangered = color::rgb(0xff4500);
inline constexpr color color::red = color::rgb(0xff0000);
inline constexpr color color::crimson = color::rgb(0xdc143c);
inline constexpr color color::mediumvioletred = color::rgb(0xc71585);
inline constexpr color color::deeppink = color::rgb(0xff1493);
inline constexpr color color::hotpink = color::rgb(0xff69b4);
inline constexpr color color::palevioletred = color::rgb(0xdb7093);
inline constexpr color color::pink = color::rgb(0xffc0cb);
inline constexpr color color::lightpink = color::rgb(0xffb6c1);
inline constexpr color color::thistle = color::rgb(0xd8bfd8);
inline constexpr color color::magenta = color::rgb(0xff00ff);
inline constexpr color color::fuchsia = color::rgb(0xff00ff);
inline constexpr color color::violet = color::rgb(0xee82ee);
inline constexpr color color::plum = color::rgb(0xdda0dd);
inline constexpr color color::orchid = color::rgb(0xda70d6);
inline constexpr color color::mediumorchid = color::rgb(0xba55d3);
inline constexpr color color::darkorchid = color::rgb(0x9932cc);
inline constexpr color color::darkviolet = color::rgb(0x9400d3);
inline constexpr color color::darkmagenta = color::rgb(0x8b008b);
inline constexpr color color::purple = color::rgb(0x800080);
inline constexpr color color::indigo = color::rgb(0x4b0082);
inline constexpr color color::darkslateblue = color::rgb(0x483d8b);
inline constexpr color color::blueviolet = color::rgb(0x8a2be2);
inline constexpr color color::mediumpurple = color::rgb(0x9370db);
inline constexpr color color::slateblue = color::rgb(0x6a5acd);
inline constexpr color color::mediumslateblue = color::rgb(0x7b68ee);
inline constexpr color color::transparent = color::rgb(0x00000000);
inline constexpr color color::undefined = color(0, 0, 0, -1);
inline constexpr color color::yw = color::rgb(0x081020);
}

namespace std {
template<> struct tuple_size<yw::color> : integral_constant<size_t, 4> {};
template<size_t I> requires (I < 4) struct tuple_element<I, yw::color> : type_identity<float> {};
template<typename Ct> struct formatter<yw::color, Ct> : formatter<basic_string<Ct>, Ct> {
  using base = formatter<basic_string<Ct>, Ct>;
  auto format(const yw::color& a, auto& c) const {
    if constexpr (same_as<Ct, char>) return base::format(std::format("RGBA({}, {}, {}, {})", a.r, a.g, a.b, a.a), c);
    else return base::format(std::format(L"RGBA({}, {}, {}, {})", a.r, a.g, a.b, a.a), c); } };
template<> struct tuple_size<yw::color::rgb> : integral_constant<size_t, 4> {};
template<size_t I> requires (I < 4) struct tuple_element<I, yw::color::rgb> : type_identity<float> {};
template<typename Ct> struct formatter<yw::color::rgb, Ct> : formatter<basic_string<Ct>, Ct> {
  using base = formatter<basic_string<Ct>, Ct>;
  auto format(const yw::color::rgb& a, auto& c) const {
    if constexpr (same_as<Ct, char>) return base::format(std::format("RGBA({}, {}, {}, {})", a.r, a.g, a.b, a.a), c);
    else return base::format(std::format(L"RGBA({}, {}, {}, {})", a.r, a.g, a.b, a.a), c); } };
template<> struct tuple_size<yw::color::hsv> : integral_constant<size_t, 4> {};
template<size_t I> requires (I < 4) struct tuple_element<I, yw::color::hsv> : type_identity<float> {};
template<typename Ct> struct formatter<yw::color::hsv, Ct> : formatter<basic_string<Ct>, Ct> {
  using base = formatter<basic_string<Ct>, Ct>;
  auto format(const yw::color::hsv& a, auto& c) const {
    if constexpr (same_as<Ct, char>) return base::format(std::format("HSVA({}, {}, {}, {})", a.h, a.s, a.v, a.a), c);
    else return base::format(std::format(L"HSVA({}, {}, {}, {})", a.h, a.s, a.v, a.a), c); } };
}


#include <commdlg.h>
#include <d2d1_3.h>
#include <d3d11_3.h>
#include <d3dcompiler.h>
#include <dwrite_3.h>
#include <dxgi1_6.h>
#include <shellapi.h>
#include <wincodec.h>
#pragma comment(lib, "comdlg32.lib")
#pragma comment(lib, "d2d1.lib")
#pragma comment(lib, "d3d11.lib")
#pragma comment(lib, "d3dcompiler.lib")
#pragma comment(lib, "dwrite.lib")
#pragma comment(lib, "dxgi.lib")
#pragma comment(lib, "Shlwapi.lib")
#pragma comment(lib, "windowscodecs.lib")

#undef max
#undef min

namespace yw {

class stopwatch {
  inline static fat8 freq = [](LARGE_INTEGER _) { return ::QueryPerformanceFrequency(&_), fat8(_.QuadPart); }({});
  mutable LARGE_INTEGER li;
  int8 last;
public:
  stopwatch() noexcept : li{}, last{(::QueryPerformanceCounter(&li), li.QuadPart)} {}
  fat8 operator()() const noexcept { return *this; }
  operator fat8() const noexcept { return ::QueryPerformanceCounter(&li), (li.QuadPart - last) / freq; }
  explicit operator fat4() const noexcept { return float(operator fat8()); }
  void reset() noexcept { ::QueryPerformanceCounter(&li), last = li.QuadPart; }
  fat8 split() noexcept { return ::QueryPerformanceCounter(&li), (li.QuadPart - exchange(last, li.QuadPart)) / freq; }
};

inline constexpr overload ok{
  [](const str1& Text, const str1& Caption = "OK?") -> bool { return ::MessageBoxA(nullptr, Text.c_str(), Caption.c_str(), MB_ICONEXCLAMATION | MB_OK) == IDOK; },
  [](const str2& Text, const str2& Caption = L"OK?") -> bool { return ::MessageBoxW(nullptr, Text.c_str(), Caption.c_str(), MB_ICONEXCLAMATION | MB_OK) == IDOK; },
  [](const HWND Window, const str1& Text, const str1& Caption = "OK?") -> bool { return ::MessageBoxA(Window, Text.c_str(), Caption.c_str(), MB_ICONEXCLAMATION | MB_OK) == IDOK; },
  [](const HWND Window, const str2& Text, const str2& Caption = L"OK?") -> bool { return ::MessageBoxW(Window, Text.c_str(), Caption.c_str(), MB_ICONEXCLAMATION | MB_OK) == IDOK; }};

inline constexpr overload yes{
  [](const str1& Text, const str1& Caption = "Yes?") -> bool { return ::MessageBoxA(nullptr, Text.c_str(), Caption.c_str(), MB_ICONQUESTION | MB_YESNO) == IDYES; },
  [](const str2& Text, const str2& Caption = L"Yes?") -> bool { return ::MessageBoxW(nullptr, Text.c_str(), Caption.c_str(), MB_ICONQUESTION | MB_YESNO) == IDYES; },
  [](const HWND Window, const str1& Text, const str1& Caption = "Yes?") -> bool { return ::MessageBoxA(Window, Text.c_str(), Caption.c_str(), MB_ICONQUESTION | MB_YESNO) == IDYES; },
  [](const HWND Window, const str2& Text, const str2& Caption = L"Yes?") -> bool { return ::MessageBoxW(Window, Text.c_str(), Caption.c_str(), MB_ICONQUESTION | MB_YESNO) == IDYES; }};


/// class to handle a status needing to be checked the change.
template<typename T, typename Setter = none> class status {
protected:
  T _value;
  mutable bool _changed;
  inline static auto setter = Setter{};
public:
  const T& value = _value;
  const bool& changed = _changed;
  status() noexcept : _value{}, _changed{false} {}
  status(const T& Init) noexcept : _value{Init}, _changed{false} {}
  status(T&& Init) noexcept : _value{mv(Init)}, _changed{false} {}
  /// checks if the status has changed.
  explicit operator bool() const noexcept { return _changed; }
  /// returns the status.
  operator const T&() const noexcept { return _changed = false, _value; }
  /// returns the status.
  const T& operator()() const noexcept { return _changed = false, _value; }
  /// assigns a new value to the status.
  status& operator=(const T& New) noexcept(nt_assignable<T&, const T&> && nt_invocable<Setter, const T&>)
  { return _changed = true, _value = New, setter(_value), *this; }
  /// assigns a new value to the status.
  status& operator=(T&& New) noexcept(nt_assignable<T&, const T&> && nt_invocable<Setter, const T&>)
  { return _changed = true, _value = mv(New), setter(_value), *this; }
};

/// class to handle a status needing to be checked the change.
template<typename Setter> class status<bool, Setter> {
protected:
  bool _value;
  mutable bool _changed;
public:
  const bool& value = _value;
  const bool& changed = _changed;
  status() noexcept : _value{}, _changed{false} {}
  status(bool Init) noexcept : _value{Init}, _changed{false} {}
  /// returns the status.
  bool operator()() const noexcept { return _changed = false, _value; }
  /// assigns a new value to the status.
  bool operator=(bool New) noexcept(nt_invocable<Setter, bool>)
  { return _changed = true, _value = New, Setter(New), _value; }
};

inline void tiff(HRESULT hr, const source& _ = {}) {
  if (SUCCEEDED(hr)) return;
  // health.set(false);
  str1 buffer(256, '\0');
  ::FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr,
                   hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), buffer.data(), 256, nullptr);
  auto text = std::format("runtime error: {}\n at {}\n", buffer, _);
  log.error(text);
  throw std::runtime_error(text.data());
}

inline void tiff(const convertible_to<bool> auto& Result, const std::string_view Message, const source& _ = {}) {
  if (Result) return;
  // health.set(false);
  auto text = std::format("runtime error: {}\n at {}\n", Message, _);
  log.error(text);
  throw std::runtime_error(text.data());
}

namespace key {
inline yw::status<bool> keys[256]{};
inline auto& lbutton = keys[VK_LBUTTON], &rbutton = keys[VK_RBUTTON], &mbutton = keys[VK_MBUTTON];
inline auto& xbutton1 = keys[VK_XBUTTON1], &xbutton2 = keys[VK_XBUTTON2];
inline auto& win = keys[VK_LWIN], &app = keys[VK_APPS], &back = keys[VK_BACK], &tab = keys[VK_TAB], &enter = keys[VK_RETURN];
inline auto& escape = keys[VK_ESCAPE], &shift = keys[VK_SHIFT], &control = keys[VK_CONTROL], &alt = keys[VK_MENU], &space = keys[VK_SPACE];
inline auto& pageup = keys[VK_PRIOR], &pagedown = keys[VK_NEXT], &end = keys[VK_END], &home = keys[VK_HOME];
inline auto& left = keys[VK_LEFT], &up = keys[VK_UP], &right = keys[VK_RIGHT], &down = keys[VK_DOWN];
inline auto& screenshot = keys[VK_SNAPSHOT], &insert = keys[VK_INSERT], &delete_ = keys[VK_DELETE];
inline auto& n0 = keys['0'], &n1 = keys['1'], &n2 = keys['2'], &n3 = keys['3'], &n4 = keys['4'], &n5 = keys['5'], &n6 = keys['6'], &n7 = keys['7'], &n8 = keys['8'], &n9 = keys['9'];
inline auto& a = keys['A'], &b = keys['B'], &c = keys['C'], &d = keys['D'], &e = keys['E'], &f = keys['F'], &g = keys['G'], &h = keys['H'], &i = keys['I'];
inline auto& j = keys['J'], &k = keys['K'], &l = keys['L'], &m = keys['M'], &n = keys['N'], &o = keys['O'], &p = keys['P'], &q = keys['Q'], &r = keys['R'];
inline auto& s = keys['S'], &t = keys['T'], &u = keys['U'], &v = keys['V'], &w = keys['W'], &x = keys['X'], &y = keys['Y'], &z = keys['Z'];
inline auto& np_0 = keys[VK_NUMPAD0], &np_1 = keys[VK_NUMPAD1], &np_2 = keys[VK_NUMPAD2], &np_3 = keys[VK_NUMPAD3], &np_4 = keys[VK_NUMPAD4];
inline auto& np_5 = keys[VK_NUMPAD5], &np_6 = keys[VK_NUMPAD6], &np_7 = keys[VK_NUMPAD7], &np_8 = keys[VK_NUMPAD8], &np_9 = keys[VK_NUMPAD9];
inline auto& np_mul = keys[VK_MULTIPLY], &np_add = keys[VK_ADD], &np_sub = keys[VK_SUBTRACT], &np_div = keys[VK_DIVIDE], &np_decimal = keys[VK_DECIMAL];
inline auto& f1 = keys[VK_F1], &f2 = keys[VK_F2], &f3 = keys[VK_F3], &f4 = keys[VK_F4], &f5 = keys[VK_F5], &f6 = keys[VK_F6];
inline auto& f7 = keys[VK_F7], &f8 = keys[VK_F8], &f9 = keys[VK_F9], &f10 = keys[VK_F10], &f11 = keys[VK_F11], &f12 = keys[VK_F12];
inline auto& minus = keys[VK_OEM_MINUS], &plus = keys[VK_OEM_PLUS], &comma = keys[VK_OEM_COMMA], &period = keys[VK_OEM_PERIOD];
inline auto& oem00 = keys[VK_OEM_7], &oem01 = keys[VK_OEM_5], &oem10 = keys[VK_OEM_3], &oem11 = keys[VK_OEM_4];
inline auto& oem20 = keys[VK_OEM_1], &oem21 = keys[VK_OEM_6], &oem30 = keys[VK_OEM_2], &oem31 = keys[VK_OEM_102];
}

namespace main {
inline bool (*userproc)(HWND hw, nat4 msg, nat8 wp, int8 lp) = nullptr;
inline status<array<path>> dropped_files;
inline void terminate();
}

namespace main::system {
inline stopwatch timer;
inline str2 username;
inline array<str2> args;
inline int width = 200, height = 200;
inline int pad_left, pad_top, pad_width, pad_height;
inline HINSTANCE hinstance;
inline HWND hwnd;
inline bool leave;
LRESULT CALLBACK wndproc(HWND hw, UINT msg, WPARAM wp, LPARAM lp);
}

namespace mouse {
inline status<list<int, int>, decltype([](const list<int, int>& New) { ::SetCursorPos(New.first, New.second); })> position;
inline status<int> wheel;
inline const bool& outside = main::system::leave;
}

LRESULT CALLBACK main::system::wndproc(HWND hw, UINT msg, WPARAM wp, LPARAM lp) {
  static TRACKMOUSEEVENT tme{.cbSize = sizeof(TRACKMOUSEEVENT), .dwFlags = TME_LEAVE};
  static auto keydown = [](WPARAM wp, LPARAM lp) {
    if (key::keys[wp].changed || !key::keys[wp]() || !(lp & 0x40000000)) key::keys[wp] = true; };
  if (userproc && userproc(hw, msg, wp, lp)) return 0;
  switch (msg) {
  case WM_MOUSEMOVE:
    if (leave) ::TrackMouseEvent(&tme), leave = false;
    reinterpret_cast<list<int, int>&>(mouse::position) = {LOWORD(lp), HIWORD(lp)};
    return 0;
  case WM_MOUSEWHEEL:
    if (!mouse::wheel.changed) mouse::wheel = GET_WHEEL_DELTA_WPARAM(wp) / WHEEL_DELTA;
    else mouse::wheel = mouse::wheel() + GET_WHEEL_DELTA_WPARAM(wp) / WHEEL_DELTA;
    return 0;
  case WM_MOUSELEAVE:
    return leave = true, 0;
  case WM_KEYDOWN:
    return keydown(wp, lp), 0;
  case WM_KEYUP:
    return key::keys[wp] = false, 0;
  case WM_LBUTTONDOWN:
    return ::SetFocus(hwnd), keydown(VK_LBUTTON, lp), 0;
  case WM_LBUTTONUP:
    return key::keys[VK_LBUTTON] = false, 0;
  case WM_RBUTTONDOWN:
    return ::SetFocus(hwnd), keydown(VK_RBUTTON, lp), 0;
  case WM_RBUTTONUP:
    return key::keys[VK_RBUTTON] = false, 0;
  case WM_MBUTTONDOWN:
    return ::SetFocus(hwnd), keydown(VK_MBUTTON, lp), 0;
  case WM_MBUTTONUP:
    return key::keys[VK_MBUTTON] = false, 0;
  case WM_XBUTTONDOWN:
    return ::SetFocus(hwnd), keydown(GET_XBUTTON_WPARAM(wp) == XBUTTON1 ? VK_XBUTTON1 : VK_XBUTTON2, lp), 0;
  case WM_XBUTTONUP:
    return key::keys[GET_XBUTTON_WPARAM(wp) == XBUTTON1 ? VK_XBUTTON1 : VK_XBUTTON2] = false , 0;
  case WM_DROPFILES: {
    HDROP hdrop = (HDROP)wp;
    nat count = ::DragQueryFileW(hdrop, 0xFFFFFFFF, nullptr, 0);
    array<path> temp(count);
    for (UINT i = 0; i < count; ++i) {
      UINT size = ::DragQueryFileW(hdrop, i, nullptr, 0);
      str2 file(size, L'\0');
      ::DragQueryFileW(hdrop, i, file.data(), size + 1);
      temp[i] = mv(file); }
    return ::DragFinish(hdrop), dropped_files = mv(temp), 0;
  }
  case WM_CLOSE:
    return ::DestroyWindow(hw), 0;
  case WM_DESTROY:
    return ::PostQuitMessage(0), terminate(), 0;
  case WM_CREATE:
    tme.hwndTrack = hw, ::TrackMouseEvent(&tme);
  }
  return DefWindowProcW(hw, msg, wp, lp);
}

namespace main::system {
inline bool com_initialized = false;
#ifdef ywlib_disable_base_system
inline const bool base_system_initialized = false;
#else
inline const bool base_system_initialized = [] {
  try {
    stopwatch sw;
    std::cout << "Start initializing base system" << std::flush;
    timer.reset();
    std::cout << "." << std::flush;
    std::wcout.imbue(std::locale("Japanese"));
    std::cout << "." << std::flush;
    [](DWORD d) { ::GetUserNameW(nullptr, &d), username.resize(d - 1), ::GetUserNameW(username.data(), &d); }({});
    std::cout << "." << std::flush;
    [](int c) { auto a = CommandLineToArgvW(GetCommandLineW(), &c); for (args.resize(c); 0 <= --c;) args[c] = a[c]; }(0);
    std::cout << "." << std::flush;
    if (!(hinstance = GetModuleHandleW(nullptr))) throw std::runtime_error("runtime error: GetModuleHandle failed");
    std::cout << "." << std::flush;
    tiff(::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED));
    std::cout << "." << std::flush;
    com_initialized = true;
    std::cout << "." << std::flush;
    std::cout << "initialized (" << sw() << " seconds)\n";
    return true;
  } catch (const std::exception& e) {
    std::cerr << e.what() << '\n';
    return false;
  } }();
#endif
#ifdef ywlib_disable_main_window
inline const bool main_window_initialized = false;
#else
inline const bool main_window_initialized = base_system_initialized && [] {
  try {
    stopwatch sw;
    std::cout << "Start initializing main window" << std::flush;
    static constexpr const wchar_t* name = L"ywlib";
    std::cout << "." << std::flush;
    WNDCLASSEXW wc{sizeof(WNDCLASSEXW), CS_OWNDC, wndproc, 0, 0, hinstance};
    std::cout << "." << std::flush;
    wc.hCursor = ::LoadCursorW(nullptr, IDC_ARROW), wc.lpszClassName = name;
    std::cout << "." << std::flush;
    if (!::RegisterClassExW(&wc))  throw std::runtime_error("runtime error: RegisterClassEx failed");
    std::cout << "." << std::flush;
    hwnd = ::CreateWindowExW(WS_EX_ACCEPTFILES, name, name, WS_OVERLAPPED | WS_SYSMENU | WS_CLIPCHILDREN,
                             0, 0, width, height, nullptr, nullptr, hinstance, nullptr);
    std::cout << "." << std::flush;
    if(!hwnd) throw std::runtime_error("runtime error: CreateWindowEx failed");
    std::cout << "." << std::flush;
    [&](RECT r) { ::GetClientRect(hwnd, &r), pad_width = width - r.right, pad_height = height - r.bottom; }({});
    std::cout << "." << std::flush;
    pad_left = pad_width / 2, pad_top = pad_height - pad_left;
    std::cout << "." << std::flush;
    ::SetWindowPos(hwnd, HWND_TOP, -pad_left, 0, width + pad_width, height + pad_height, SWP_SHOWWINDOW);
    std::cout << "." << std::flush;
    ::ShowWindow(hwnd, SW_SHOW);
    std::cout << "." << std::flush;
    ::SetForegroundWindow(hwnd);
    std::cout << "." << std::flush;
    ::SetFocus(hwnd);
    std::cout << "initialized (" << sw() << " seconds)\n";
    return true;
  } catch (const std::exception& e) {
    std::cerr << e.what() << '\n';
    return false;
  } }();
#endif
}

template<typename Com> struct com_deleter {
  constexpr com_deleter() noexcept = default;
  template<typename U> constexpr com_deleter(const com_deleter<U>&) noexcept {}
  constexpr void operator()(Com* p) const noexcept { if (p) p->Release(); }
};

template<typename Com> class comptr : public std::unique_ptr<Com, com_deleter<Com>> {
public:
  using base = std::unique_ptr<Com, com_deleter<Com>>;
  using base::unique_ptr::unique_ptr;
  using base::operator->;
  using base::operator bool;
  constexpr operator Com*() const noexcept { return base::get(); }
  constexpr Com** init(const source& _ = {}) & {
    if (bool(*this)) {
      auto t = std::format("Error: This COM pointer is already initialized\n at {}", _);
      throw std::exception(t.data());
    } else return reinterpret_cast<Com**>(this);
  }
  template<typename U> HRESULT as(comptr<U>& u) const noexcept {
    return base::get()->QueryInterface(IID_PPV_ARGS(u.init()));
  }
};

namespace main {
inline const auto& timer = system::timer;                 // system timer
inline const auto& width = system::width;                 // main window width
inline const auto& height = system::height;               // main window height
inline const auto& hwnd = system::hwnd;                   // main window handle
inline const auto& hinstance = system::hinstance;         // instance handle
inline const auto& args = system::args;                   // arguments
inline const auto& username = system::username;           // username
}

namespace main::system {
inline comptr<ID3D11Device> d3d_device{};
inline comptr<ID3D11DeviceContext> d3d_context{};
inline comptr<IDXGIFactory2> dxgi_factory{};
inline comptr<IDXGIDevice2> dxgi_device{};
inline comptr<IDXGISwapChain1> swapchain{};
inline comptr<ID2D1Factory1> d2d_factory{};
inline comptr<ID2D1Device> d2d_device{};
inline comptr<ID2D1DeviceContext> d2d_context{};
inline comptr<ID2D1Bitmap1> rendertarget{};
inline comptr<IDWriteFactory> dw_factory{};
inline comptr<IWICImagingFactory2> wic_factory{};
#ifdef ywlib_disable_directx
inline const bool directx_initialized = false;
#else
inline const bool directx_initialized = main_window_initialized && [] {
  try {
    stopwatch sw;
    std::cout << "Start initializing DirectX" << std::flush;
    static constexpr D3D_FEATURE_LEVEL d3d_feature_levels[] = {D3D_FEATURE_LEVEL_11_1, D3D_FEATURE_LEVEL_11_0};
    tiff(::D3D11CreateDevice(nullptr, D3D_DRIVER_TYPE_HARDWARE, nullptr, D3D11_CREATE_DEVICE_BGRA_SUPPORT, d3d_feature_levels, arraysize(d3d_feature_levels),
                             D3D11_SDK_VERSION, (ID3D11Device**)d3d_device.init(), nullptr, (ID3D11DeviceContext**)d3d_context.init()));
    std::cout << "." << std::flush;
    tiff(::CreateDXGIFactory2(0, IID_PPV_ARGS(dxgi_factory.init()))), tiff(dxgi_factory->MakeWindowAssociation(hwnd, DXGI_MWA_NO_ALT_ENTER));
    std::cout << "." << std::flush;
    [&](comptr<ID3D11BlendState> state, D3D11_BLEND_DESC desc) {
      desc.RenderTarget[0] = {true, D3D11_BLEND_SRC_ALPHA, D3D11_BLEND_INV_SRC_ALPHA, D3D11_BLEND_OP_ADD,
                              D3D11_BLEND_SRC_ALPHA, D3D11_BLEND_INV_SRC_ALPHA, D3D11_BLEND_OP_ADD, 0x0f};
      tiff(d3d_device->CreateBlendState(&desc, state.init())), d3d_context->OMSetBlendState(state, 0, 0xffffffff); }({}, {});
    std::cout << "." << std::flush;
    [&](comptr<ID3D11SamplerState> state, D3D11_SAMPLER_DESC desc) {
      desc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP, desc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP; desc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP,
      desc.MaxAnisotropy = 1; desc.ComparisonFunc = D3D11_COMPARISON_ALWAYS, desc.MaxLOD = D3D11_FLOAT32_MAX;
      tiff(d3d_device->CreateSamplerState(&desc, state.init()));
      [&](auto p) { d3d_context->PSSetSamplers(0, 1, &p); }(state.get()); }({}, {D3D11_FILTER_MIN_MAG_MIP_LINEAR});
    std::cout << "." << std::flush;
    [&](comptr<ID3D11RasterizerState> state, D3D11_RASTERIZER_DESC desc) {
      tiff(d3d_device->CreateRasterizerState(&desc, state.init()));
      d3d_context->RSSetState(state); }({}, {D3D11_FILL_SOLID, D3D11_CULL_NONE, 1, 0, 0, 0, 1, 0, 1, 1});
    std::cout << "." << std::flush;
    tiff(::CoCreateInstance(CLSID_WICImagingFactory2, nullptr, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(wic_factory.init())));
    std::cout << "." << std::flush;
    DXGI_SWAP_CHAIN_DESC1 desc{UINT(width), UINT(height), DXGI_FORMAT_R8G8B8A8_UNORM};
    desc.SampleDesc.Count = 1, desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT, desc.BufferCount = 2;
    desc.Scaling = DXGI_SCALING_STRETCH, desc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
    std::cout << "." << std::flush;
    tiff(dxgi_factory->CreateSwapChainForHwnd(d3d_device, hwnd, &desc, nullptr, nullptr, swapchain.init()));
    std::cout << "." << std::flush;
    tiff(::D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, d2d_factory.init()));
    std::cout << "." << std::flush;
    tiff(d3d_device.as(dxgi_device)), tiff(d2d_factory->CreateDevice(dxgi_device, d2d_device.init()));
    std::cout << "." << std::flush;
    tiff(d2d_device->CreateDeviceContext(D2D1_DEVICE_CONTEXT_OPTIONS_NONE, d2d_context.init()));
    std::cout << "." << std::flush;
    comptr<ID3D11Texture2D> tex; tiff(swapchain->GetBuffer(0, IID_PPV_ARGS(tex.init())));
    std::cout << "." << std::flush;
    comptr<IDXGISurface> surface; tiff(tex->QueryInterface(IID_PPV_ARGS(surface.init())));
    std::cout << "." << std::flush;
    auto p = D2D1::BitmapProperties1(D2D1_BITMAP_OPTIONS_TARGET | D2D1_BITMAP_OPTIONS_CANNOT_DRAW,
                                     D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, D2D1_ALPHA_MODE_PREMULTIPLIED));
    std::cout << "." << std::flush;
    tiff(d2d_context->CreateBitmapFromDxgiSurface(surface, &p, rendertarget.init()));
    std::cout << "." << std::flush;
    tiff(::DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory), (IUnknown**)dw_factory.init()));
    std::cout << "initialized (" << sw() << " seconds)\n";
    return true;
  } catch (const std::exception& e) {
    std::cerr << e.what() << '\n';
    return false;
  } }();
#endif
struct terminator {
  ~terminator() {
    dw_factory.reset();
    rendertarget.reset();
    d2d_context.reset();
    d2d_device.reset();
    d2d_factory.reset();
    swapchain.reset();
    wic_factory.reset();
    dxgi_device.reset();
    dxgi_factory.reset();
    d3d_context.reset();
    d3d_device.reset();
    if (com_initialized) ::CoUninitialize(), com_initialized = false;
    if (hwnd) ::DestroyWindow(exchange(hwnd, nullptr)), ::UnregisterClassW(L"ywlib", hinstance); }
};
inline void bitmap_to_png(convertible_to<ID2D1Bitmap*> auto&& b, const std::filesystem::path& p) {
  if (!wic_factory) throw std::runtime_error("runtime error: WIC is not initialized");
  if (!b) throw std::runtime_error("runtime error: the bitmap is not initialized");
  comptr<IWICStream> stream{};
  tiff(wic_factory->CreateStream(stream.init()));
  tiff(stream->InitializeFromFilename(p.c_str(), GENERIC_WRITE));
  comptr<IWICBitmapEncoder> encoder{};
  tiff(wic_factory->CreateEncoder(GUID_ContainerFormatPng, nullptr, encoder.init()));
  tiff(encoder->Initialize(stream, WICBitmapEncoderNoCache));
  comptr<IWICBitmapFrameEncode> frame{};
  tiff(encoder->CreateNewFrame(frame.init(), nullptr));
  tiff(frame->Initialize(nullptr));
  comptr<IWICImageEncoder> image_encoder{};
  tiff(wic_factory->CreateImageEncoder(d2d_device, image_encoder.init()));
  tiff(image_encoder->WriteFrame(b, frame, nullptr));
  tiff(frame->Commit()), tiff(encoder->Commit()), tiff(stream->Commit(STGC_DEFAULT));
}
inline terminator termination{};
inline fat8 spf{}, fps{};
inline MSG message{};
}

namespace main {
inline const auto& d3d_device = system::d3d_device;
inline const auto& d3d_context = system::d3d_context;
inline const auto& d2d_device = system::d2d_device;
inline const auto& d2d_context = system::d2d_context;
inline const auto& d2d_factory = system::d2d_factory;
inline const auto& dw_factory = system::dw_factory;
inline const auto& wic_factory = system::wic_factory;
inline const double& spf = system::spf;
inline const double& fps = system::fps;

inline void rename(const wchar_t* Name) {
  if (!hwnd) throw std::runtime_error("runtime error: Main window is not initialized");
  if (!::SetWindowTextW(hwnd, Name)) throw std::runtime_error("runtime error: SetWindowText failed");
}

inline void relocate(const numerical auto Left, const numerical auto Top) {
  if (!hwnd) throw std::runtime_error("runtime error: Main window is not initialized");
  if (!::SetWindowPos(hwnd, 0, int(Left) - system::pad_left, int(Top), 0, 0, SWP_NOSIZE | SWP_NOZORDER))
    throw std::runtime_error("runtime error: SetWindowPos failed");
}

inline void topmost(bool TopMost = true) {
  if (!hwnd) throw std::runtime_error("runtime error: Main window is not initialized");
  if (auto style = ::GetWindowLongW(hwnd, GWL_EXSTYLE); TopMost) {
    if (!::SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE))
      throw std::runtime_error("runtime error: SetWindowPos failed");
    ::SetWindowLongW(hwnd, GWL_EXSTYLE, style | WS_EX_TOPMOST);
  } else {
    if (!::SetWindowPos(hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE))
      throw std::runtime_error("runtime error: SetWindowPos failed");   if (style & WS_EX_TOPMOST) ::SetWindowLongW(hwnd, GWL_EXSTYLE, style & ~WS_EX_TOPMOST);
  }
}

inline void resize(const numerical auto Width, const numerical auto Height) {
  system::width = int(Width), system::height = int(Height);
  if (width <= 0 || height <= 0) throw std::runtime_error("runtime error: Invalid window size");
  if (!hwnd) throw std::runtime_error("runtime error: Main window is not initialized");
#ifndef ywlib_disable_directx
  if (!system::swapchain && !d2d_context) throw std::runtime_error("runtime error: DirectX is not initialized");
  system::rendertarget.reset(), system::d2d_context->SetTarget(0);
  tiff(system::swapchain->ResizeBuffers(2, UINT(width), UINT(height), DXGI_FORMAT_UNKNOWN, 0));
  comptr<ID3D11Texture2D> tex;
  tiff(system::swapchain->GetBuffer(0, IID_PPV_ARGS(tex.init())));
  comptr<IDXGISurface> surface;
  tiff(tex->QueryInterface(IID_PPV_ARGS(surface.init())));
  auto props = D2D1::BitmapProperties1(D2D1_BITMAP_OPTIONS_TARGET | D2D1_BITMAP_OPTIONS_CANNOT_DRAW,
                                       D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, D2D1_ALPHA_MODE_PREMULTIPLIED));
  tiff(system::d2d_context->CreateBitmapFromDxgiSurface(surface, props, system::rendertarget.init()));
#endif
  if (!::SetWindowPos(hwnd, 0, 0, 0, width + system::pad_width, height + system::pad_height, SWP_NOMOVE | SWP_NOZORDER))
    throw std::runtime_error("runtime error: SetWindowPos failed");
}

/// capture the main window and save it as a PNG file
inline void screenshot(const std::filesystem::path& p) {
  system::bitmap_to_png(system::rendertarget, p);
}

/// terminate the main window
inline void terminate() {
  system::termination = system::terminator{};
}

/// updates the main window.
inline constexpr caster update{[]() {
  static stopwatch sw{};
  if (system::swapchain) system::swapchain->Present(1, 0);
  while (system::hwnd) {
    if (::PeekMessageW(&system::message, nullptr, 0, 0, PM_REMOVE)) {
      ::TranslateMessage(&system::message), ::DispatchMessageW(&system::message);
      if (system::message.message == WM_QUIT) return false;
    } else {
      if (mouse::outside) [](POINT p) { ::GetCursorPos(&p), ::ScreenToClient(hwnd, &p), reinterpret_cast<POINT&>(mouse::position) = p; }({});
      system::spf = sw.split(), system::fps = 1.0f / system::spf;
      return true;
    }
  } return false; }};

/// begin drawing to the main window
inline void begin_draw() {
  d2d_context->SetTarget(system::rendertarget);
  d2d_context->BeginDraw();
}

/// begins drawing to the main window after filling with the specified color
inline void begin_draw(const color& Color) {
  d2d_context->SetTarget(system::rendertarget);
  d2d_context->BeginDraw();
  d2d_context->Clear(reinterpret_cast<const D2D1_COLOR_F&>(Color));
}

/// end drawing to the main window
inline void end_draw() {
  tiff(d2d_context->EndDraw());
}
}

/// show a file-open dialog
inline constexpr auto open_file = [](const path& Dir = {}) -> path {
  str2 buffer(256, '\0');
  OPENFILENAMEW ofn{DWORD(sizeof(OPENFILENAMEW)), main::hwnd, 0, L"All Files (*.*)\0", 0, 0, 1, buffer.data(), 256};
  ofn.lpstrInitialDir = Dir.c_str();
  ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
  return ::GetOpenFileNameW(&ofn) == TRUE ? path(ofn.lpstrFile) : path{};
};

/// show a file-save dialog
inline constexpr auto save_file = [](const path& Dir = {}, const path& Default = {}) noexcept -> path {
    str2 buffer(256, '\0');
    if (!Default.empty()) std::ranges::copy(Default.filename().wstring(), buffer.begin());
    OPENFILENAMEW ofn{DWORD(sizeof(OPENFILENAMEW)), main::hwnd, 0, L"All Files (*.*)\0", 0, 0, 1, buffer.data(), 256};
    ofn.lpstrInitialDir = Dir.c_str();
    ofn.Flags = OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;
    return ::GetSaveFileNameW(&ofn) == TRUE ? path(ofn.lpstrFile) : path{};
};

/// alignment
enum class alignment {
  lefttop     = 0b0101,
  top         = 0b0001,
  righttop    = 0b1101,
  left        = 0b0100,
  center      = 0b0000,
  right       = 0b1100,
  leftbottom  = 0b0111,
  bottom      = 0b0011,
  rightbottom = 0b1111, };

/// class to create a solid color brush object.
template<color Color = color::undefined> class brush;

/// class to create a solid color brush object.
template<> class brush<yw::color::undefined> {
protected:
  comptr<ID2D1SolidColorBrush> d2d_brush{};
  void init(const yw::color& Color) {
    if (!main::d2d_context) throw std::runtime_error("runtime error : yw::brush<>::init : Direct2D is not initialized");
    d2d_brush.reset();
    tiff(main::d2d_context->CreateSolidColorBrush(reinterpret_cast<const D2D1_COLOR_F&>(Color), d2d_brush.init()));
  }
public:
  brush() noexcept = default;
  explicit brush(const yw::color& Color) { init(Color); }
  explicit operator bool() const noexcept { return bool(d2d_brush); }
  operator ID2D1SolidColorBrush*() const noexcept { return d2d_brush; }
  /// resets the color of the brush.
  void color(const yw::color& Color) { init(Color); }
  /// returns the color of the brush.
  yw::color color() const { const auto c = d2d_brush->GetColor(); return reinterpret_cast<const yw::color&>(c); }
};

/// class to create a solid color brush object with a specified color.
template<yw::color Color> class brush {
protected:
  inline static comptr<ID2D1SolidColorBrush> d2d_brush{};
  static void init() {
    if (!d2d_brush) {
      tiff(main::d2d_context->CreateSolidColorBrush(reinterpret_cast<const D2D1_COLOR_F&>(Color), d2d_brush.init()));
      tiff(bool(d2d_brush), "Failed to initialize brush"); } }
public:
  static constexpr yw::color color = Color;
  constexpr brush() noexcept = default;
  explicit operator bool() const noexcept { return true; }
  operator ID2D1SolidColorBrush*() const noexcept { return init(), d2d_brush; }

};

template<convertible_to<color> Color> brush(const Color&) -> brush<color::undefined>;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// class to create text-format object.
class text_format {
protected:
  comptr<IDWriteTextFormat> dw_format{};
public:
  text_format() noexcept = default;
  text_format(const string<cat2>& Font, const value Size, bool Bold = false) {
    tiff(main::dw_factory->CreateTextFormat(Font.data(), nullptr, Bold ? DWRITE_FONT_WEIGHT_BOLD : DWRITE_FONT_WEIGHT_NORMAL,
                                            DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL, fat4(Size), L"", dw_format.init()));
    tiff(bool(dw_format), "Failed to initialize text format");
    tiff(dw_format->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING));
  }
  explicit operator bool() const noexcept { return bool(dw_format); }
  operator IDWriteTextFormat*() const noexcept { return dw_format; }
  /// return the geometry of the text; {width, height}
  list<fat4, fat4> geometry(const string_view<cat2>& Text) const {
    comptr<IDWriteTextLayout> layout;
    tiff(main::dw_factory->CreateTextLayout(Text.data(), unsigned(Text.size()), dw_format, fat4(inf), fat4(inf), layout.init()));
    DWRITE_TEXT_METRICS metrics;
    layout->GetMetrics(&metrics);
    return {metrics.width, metrics.height};
  }
  /// return the geometry of the text which is located at the specified position; {left, top, right, bottom}
  vector geometry(const string_view<cat2>& Text, list<value, value> Point, alignment Align) const {
    const auto [w, h] = geometry(Text);
    const auto a = nat(Align);
    vector r = {fat4(Point.first), fat4(Point.second)};
    r.x = a & 0b1100 ? (a & 0b1000 ? r.x - w : r.x) : r.x - w / 2;
    r.y = a & 0b0011 ? (a & 0b0010 ? r.y - h : r.y) : r.y - h / 2;
    r.z = r.x + w, r.w = r.y + h;
    return r;
  }
  /// draws the text.
  void draw(const string_view<cat2>& Text, const vector& Rect, ID2D1SolidColorBrush* Brush = brush<color::black>{}) const {
    if (!dw_format) throw std::runtime_error("runtime error : yw::text_format::draw : Text format is not initialized");
    if (!Brush) throw std::runtime_error("runtime error : yw::text_format::draw : Brush is not initialized");
    main::d2d_context->DrawTextW(Text.data(), unsigned(Text.size()), dw_format, reinterpret_cast<const D2D1_RECT_F&>(Rect), Brush);
  }
  /// draws the text.
  void draw(const string_view<cat2>& Text, list<value, value> Point, alignment Align, ID2D1SolidColorBrush* Brush = brush<color::black>{}) const {
    if (!dw_format) throw std::runtime_error("runtime error : yw::text_format::draw : Text format is not initialized");
    if (!Brush) throw std::runtime_error("runtime error : yw::text_format::draw : Brush is not initialized");
    this->draw(Text, geometry(Text, Point, Align), Brush);
  }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// class to create a path geometry object.
class geometry {
protected:
  comptr<ID2D1PathGeometry> path{};
public:
  geometry() noexcept = default;
  /// sets SVG path code.
  geometry(string_view<cat1> SvgPath) {
    tiff(main::d2d_factory->CreatePathGeometry(path.init()));
    comptr<ID2D1GeometrySink> sink;
    tiff(path->Open(sink.init()));
    sink->SetFillMode(D2D1_FILL_MODE_WINDING);
    auto first_m = SvgPath.find_first_of("Mm");
    if (first_m == npos) { tiff(sink->Close()); return; }
    SvgPath.remove_prefix(first_m);
    // {current-x, current-y, previous-control-point-x, previous-control-point-y}
    vector current{stov<fat4>(SvgPath, SvgPath), stov<fat4>(SvgPath, SvgPath)};
    vector start{current.x, current.y};
    cat1 before = 'M';
    sink->BeginFigure(D2D1::Point2F(fat4(current.x), fat4(current.y)), D2D1_FIGURE_BEGIN_FILLED);
    D2D1_ARC_SEGMENT as{};
    D2D1_BEZIER_SEGMENT bs{};
    D2D1_QUADRATIC_BEZIER_SEGMENT qs{};
    bool end_figure = false;
    while (!SvgPath.empty()) {
      switch (SvgPath.front()) {
      case ' ':
      case '\t':
      case '\n':
      case '\r':
        SvgPath.remove_prefix(1);
        break;
      case 'm':
        if (!end_figure) sink->EndFigure(D2D1_FIGURE_END_OPEN);
        end_figure = false;
        SvgPath.remove_prefix(1);
        current.x += stov<fat4>(SvgPath, SvgPath);
        current.y += stov<fat4>(SvgPath, SvgPath);
        start = current;
        sink->BeginFigure(D2D1::Point2F(current.x, current.y), D2D1_FIGURE_BEGIN_FILLED);
        before = 'M';
        break;
      case 'M':
        if (!end_figure) sink->EndFigure(D2D1_FIGURE_END_OPEN);
        end_figure = false;
        SvgPath.remove_prefix(1);
        current.x = stov<fat4>(SvgPath, SvgPath);
        current.y = stov<fat4>(SvgPath, SvgPath);
        start = current;
        sink->BeginFigure(D2D1::Point2F(current.x, current.y), D2D1_FIGURE_BEGIN_FILLED);
        before = 'M';
        break;
      case 'l':
        SvgPath.remove_prefix(1);
        current.x += stov<fat4>(SvgPath, SvgPath);
        current.y += stov<fat4>(SvgPath, SvgPath);
        sink->AddLine(D2D1::Point2F(current.x, current.y));
        before = 'L';
        break;
      case 'L':
        SvgPath.remove_prefix(1);
        current.x = stov<fat4>(SvgPath, SvgPath);
        current.y = stov<fat4>(SvgPath, SvgPath);
        sink->AddLine(D2D1::Point2F(current.x, current.y));
        before = 'L';
        break;
      case 'h':
        SvgPath.remove_prefix(1);
        current.x += stov<fat4>(SvgPath, SvgPath);
        sink->AddLine(D2D1::Point2F(current.x, current.y));
        before = 'H';
        break;
      case 'H':
        SvgPath.remove_prefix(1);
        current.x = stov<fat4>(SvgPath, SvgPath);
        sink->AddLine(D2D1::Point2F(current.x, current.y));
        before = 'H';
        break;
      case 'v':
        SvgPath.remove_prefix(1);
        current.y += stov<fat4>(SvgPath, SvgPath);
        sink->AddLine(D2D1::Point2F(current.x, current.y));
        before = 'V';
        break;
      case 'V':
        SvgPath.remove_prefix(1);
        current.y = stov<fat4>(SvgPath, SvgPath);
        sink->AddLine(D2D1::Point2F(current.x, current.y));
        before = 'V';
        break;
      case 'c':
        SvgPath.remove_prefix(1);
        bs.point1.x = current.x + stov<fat4>(SvgPath, SvgPath), bs.point1.y = current.y + stov<fat4>(SvgPath, SvgPath);
        bs.point2.x = current.x + stov<fat4>(SvgPath, SvgPath), bs.point2.y = current.y + stov<fat4>(SvgPath, SvgPath);
        bs.point3.x = current.x + stov<fat4>(SvgPath, SvgPath), bs.point3.y = current.y + stov<fat4>(SvgPath, SvgPath);
        current.x = bs.point3.x, current.y = bs.point3.y, current.z = bs.point2.x, current.w = bs.point2.y;
        sink->AddBezier(bs);
        before = 'C';
        break;
      case 'C':
        SvgPath.remove_prefix(1);
        bs.point1.x = stov<fat4>(SvgPath, SvgPath), bs.point1.y = stov<fat4>(SvgPath, SvgPath);
        bs.point2.x = stov<fat4>(SvgPath, SvgPath), bs.point2.y = stov<fat4>(SvgPath, SvgPath);
        bs.point3.x = stov<fat4>(SvgPath, SvgPath), bs.point3.y = stov<fat4>(SvgPath, SvgPath);
        current.x = bs.point3.x, current.y = bs.point3.y, current.z = bs.point2.x, current.w = bs.point2.y;
        sink->AddBezier(bs);
        before = 'C';
        break;
      case 's':
        SvgPath.remove_prefix(1);
        bs.point2.x = current.x + stov<fat4>(SvgPath, SvgPath), bs.point2.y = current.y + stov<fat4>(SvgPath, SvgPath);
        bs.point3.x = current.x + stov<fat4>(SvgPath, SvgPath), bs.point3.y = current.y + stov<fat4>(SvgPath, SvgPath);
        if (before != 'C') bs.point1 = bs.point2;
        else bs.point1.x = current.x + current.x - current.z, bs.point1.y = current.y + current.y - current.w;
        current.x = bs.point3.x, current.y = bs.point3.y, current.z = bs.point2.x, current.w = bs.point2.y;
        sink->AddBezier(bs);
        before = 'C';
        break;
      case 'S':
        SvgPath.remove_prefix(1);
        bs.point2.x = stov<fat4>(SvgPath, SvgPath), bs.point2.y = stov<fat4>(SvgPath, SvgPath);
        bs.point3.x = stov<fat4>(SvgPath, SvgPath), bs.point3.y = stov<fat4>(SvgPath, SvgPath);
        if (before != 'C') bs.point1 = bs.point2;
        else bs.point1.x = current.x + current.x - current.z, bs.point1.y = current.y + current.y - current.w;
        current.x = bs.point3.x, current.y = bs.point3.y, current.z = bs.point2.x, current.w = bs.point2.y;
        sink->AddBezier(bs);
        before = 'C';
        break;
      case 'q':
        SvgPath.remove_prefix(1);
        current.z = current.x + stov<fat4>(SvgPath, SvgPath), current.w = current.y + stov<fat4>(SvgPath, SvgPath);
        current.x += stov<fat4>(SvgPath, SvgPath), current.y += stov<fat4>(SvgPath, SvgPath);
        qs.point1 = D2D1::Point2F(current.z, current.w), qs.point2 = D2D1::Point2F(current.x, current.y);
        sink->AddQuadraticBezier(qs);
        before = 'Q';
        break;
      case 'Q':
        SvgPath.remove_prefix(1);
        current.z = stov<fat4>(SvgPath, SvgPath), current.w = stov<fat4>(SvgPath, SvgPath);
        current.x = stov<fat4>(SvgPath, SvgPath), current.y = stov<fat4>(SvgPath, SvgPath);
        qs.point1 = D2D1::Point2F(current.z, current.w), qs.point2 = D2D1::Point2F(current.x, current.y);
        sink->AddQuadraticBezier(qs);
        before = 'Q';
        break;
      case 't':
        SvgPath.remove_prefix(1);
        qs.point2 = D2D1::Point2F(current.x + stov<fat4>(SvgPath, SvgPath), current.y + stov<fat4>(SvgPath, SvgPath));
        if (before != 'Q') qs.point1 = qs.point2;
        else qs.point1.x = current.x + current.x - current.z, qs.point1.y = current.y + current.y - current.w;
        current.x = qs.point2.x, current.y = qs.point2.y, current.z = qs.point1.x, current.w = qs.point1.y;
        sink->AddQuadraticBezier(qs);
        before = 'Q';
        break;
      case 'T':
        SvgPath.remove_prefix(1);
        qs.point2.x = stov<fat4>(SvgPath, SvgPath), qs.point2.y = stov<fat4>(SvgPath, SvgPath);
        if (before != 'Q') qs.point1 = qs.point2;
        else qs.point1.x = current.x + current.x - current.z, qs.point1.y = current.y + current.y - current.w;
        current.x = qs.point2.x, current.y = qs.point2.y, current.z = qs.point1.x, current.w = qs.point1.y;
        sink->AddQuadraticBezier(qs);
        before = 'Q';
        break;
      case 'a':
        SvgPath.remove_prefix(1);
        as.size.width = stov<fat4>(SvgPath, SvgPath), as.size.height = stov<fat4>(SvgPath, SvgPath);
        as.rotationAngle = stov<fat4>(SvgPath, SvgPath);
        as.arcSize = SvgPath.front() != '0' ? D2D1_ARC_SIZE_LARGE : D2D1_ARC_SIZE_SMALL;
        as.sweepDirection = SvgPath.front() != '0' ? D2D1_SWEEP_DIRECTION_CLOCKWISE : D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE;
        as.point.x = current.x + stov<fat4>(SvgPath, SvgPath), as.point.y = current.y + stov<fat4>(SvgPath, SvgPath);
        current.x = as.point.x, current.y = as.point.y;
        sink->AddArc(as);
        before = 'A';
        break;
      case 'A':
        SvgPath.remove_prefix(1);
        as.size.width = stov<fat4>(SvgPath, SvgPath), as.size.height = stov<fat4>(SvgPath, SvgPath);
        as.rotationAngle = stov<fat4>(SvgPath, SvgPath);
        as.arcSize = stov<int>(SvgPath, SvgPath) != 0 ? D2D1_ARC_SIZE_LARGE : D2D1_ARC_SIZE_SMALL;
        as.sweepDirection = stov<int>(SvgPath, SvgPath) != 0 ? D2D1_SWEEP_DIRECTION_CLOCKWISE : D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE;
        as.point.x = stov<fat4>(SvgPath, SvgPath), as.point.y = stov<fat4>(SvgPath, SvgPath);
        current.x = as.point.x, current.y = as.point.y;
        sink->AddArc(as);
        before = 'A';
        break;
      case 'z':
      case 'Z':
        SvgPath.remove_prefix(1);
        sink->EndFigure(D2D1_FIGURE_END_CLOSED);
        end_figure = true;
        current = start;
        while (!SvgPath.empty()) {
          if (SvgPath.front() == ' ') SvgPath.remove_prefix(1);
          else if (SvgPath.front() == 'M' || SvgPath.front() == 'm') {
            break;
          } else {
            log.warning(SvgPath);
            SvgPath = {};
            break;
          }
        }
        break;
      default:
        log.warning(SvgPath);
        SvgPath = {};
        break;
      }
    }
    if (!end_figure) sink->EndFigure(D2D1_FIGURE_END_OPEN);
    tiff(sink->Close());
  }

  /// draws the geometry
  void draw(convertible_to<ID2D1SolidColorBrush*> auto&& Brush, const value Thickness = 1.0) const {
    if (!path) throw std::runtime_error("runtime error : yw::geometry::draw : Path geometry is not initialized");
    main::d2d_context->DrawGeometry(path, Brush, fat4(Thickness));
  }

  /// fills the geometry
  void fill(convertible_to<ID2D1SolidColorBrush*> auto&& Brush) const {
    if (!path) throw std::runtime_error("runtime error : yw::geometry::fill : Path geometry is not initialized");
    main::d2d_context->FillGeometry(path, Brush);
  }
};
}

namespace yw { // GPU buffer classes

template<typename T> class staging_buffer;

/// base class to create GPU buffers.
template<typename T> class buffer {
  buffer(const buffer&) = delete;
protected:
  comptr<ID3D11Buffer> d3d_buffer{};
  buffer(const numerical auto Count) noexcept : count(unsigned(Count)) {}
public:
  using value_type = T;
  const unsigned count{};
  buffer() noexcept = default;
  buffer(buffer&& b) noexcept : d3d_buffer(mv(b.d3d_buffer)), count(b.count) {}
  buffer& operator=(buffer&& b) noexcept
  { return d3d_buffer = mv(b.d3d_buffer), const_cast<unsigned&>(count) = b.count, *this; }
  explicit operator bool() const noexcept { return bool(d3d_buffer); }
  operator ID3D11Buffer*() const noexcept { return d3d_buffer; }

  /// copies the data from another buffer `Src`.
  /// \note `Src.count` must be the same as `this->count`.
  void from(const buffer& Src) {
    if (!d3d_buffer) throw std::runtime_error("runtime error : yw::buffer::from : Buffer is not initialized");
    if (count != Src.count) throw std::runtime_error("runtime error : yw::buffer::from : The count of the source buffer is different");
    main::d3d_context->CopyResource(d3d_buffer, Src);
  }

  /// copies the data to CPU memory.
  virtual array<T> to_cpu() const;

  /// copies the data to CPU memory using a staging buffer.
  virtual array<T> to_cpu(staging_buffer<T>&) const;
};

/// class to create a staging buffer.
template<typename T> class staging_buffer : public buffer<T> {
public:
  using buffer<T>::count;
  using buffer<T>::d3d_buffer;
  using buffer<T>::from;
  using buffer<T>::operator bool;
  using buffer<T>::operator ID3D11Buffer*;
  staging_buffer() noexcept = default;

  /// creates a staging buffer and copies the data from `Src`.
  explicit staging_buffer(const buffer<T>& Src) : staging_buffer(Src.count) { from(Src); }

  /// creates a staging buffer with the specified count.
  explicit staging_buffer(const numerical auto Count) : buffer<T>(Count) {
    D3D11_BUFFER_DESC desc{unsigned(sizeof(T)) * count, D3D11_USAGE_STAGING, 0, D3D11_CPU_ACCESS_READ};
    tiff(main::d3d_device->CreateBuffer(&desc, nullptr, buffer<T>::d3d_buffer.init()));
  }
  /// copies the data to CPU memory.
  virtual array<T> to_cpu() const {
    if (!buffer<T>::d3d_buffer) throw std::runtime_error("runtime error : yw::staging_buffer::to_cpu : Buffer is not initialized");
    D3D11_MAPPED_SUBRESOURCE mapped{};
    array<T> a(count);
    tiff(main::d3d_context->Map(d3d_buffer, 0, D3D11_MAP_READ, 0, &mapped));
    std::ranges::copy_n(reinterpret_cast<T*>(mapped.pData), count, a.begin());
    main::d3d_context->Unmap(d3d_buffer, 0);
    return a;
  }
};

template<typename T> staging_buffer(const buffer<T>&) -> staging_buffer<T>;

template<typename T> array<T> buffer<T>::to_cpu() const {
  if (!d3d_buffer) throw std::runtime_error("runtime error : yw::buffer::to_cpu : Buffer is not initialized");
  staging_buffer<T> sb(*this);
  return sb.to_cpu();
}

template<typename T> array<T> buffer<T>::to_cpu(staging_buffer<T>& sb) const {
  if (!d3d_buffer) throw std::runtime_error("runtime error : yw::buffer::to_cpu : Buffer is not initialized");
  if (count != sb.count) throw std::runtime_error("runtime error : yw::buffer::to_cpu : The count of the staging buffer is different");
  sb.from(*this);
  return sb.to_cpu();
}

/// class to create a constant buffer.
template<typename T> requires ((sizeof(T) & 0xf) == 0)
class constant_buffer : public buffer<T> {
  static constexpr D3D11_BUFFER_DESC desc{sizeof(T), D3D11_USAGE_DYNAMIC, D3D11_BIND_CONSTANT_BUFFER, D3D11_CPU_ACCESS_WRITE};
public:
  using buffer<T>::count;
  using buffer<T>::d3d_buffer;
  using buffer<T>::from;
  using buffer<T>::operator bool;
  using buffer<T>::operator ID3D11Buffer*;
  constant_buffer() noexcept = default;
  constant_buffer(const constant_buffer&) = delete;

  /// creates a constant buffer with the specified value.
  constant_buffer(const T& Value) : buffer<T>(1) {
    D3D11_SUBRESOURCE_DATA d{&Value};
    tiff(main::d3d_device->CreateBuffer(&desc, &d, d3d_buffer.init()));
  }
  /// creates a constant buffer with the specified object.
  template<typename U> requires vassignable<T&, U> constant_buffer(U&& Object) : buffer<T>(1) {
    tiff(main::d3d_device->CreateBuffer(&desc, nullptr, d3d_buffer.init()));
    this->from(fwd<U>(Object));
  }
  /// copies the data from the specified object.
  template<typename U> requires vassignable<T&, U> void from(U&& Object) {
    if (!operator bool()) {
      tiff(main::d3d_device->CreateBuffer(&desc, nullptr, d3d_buffer.init()));
      const_cast<unsigned&>(count) = 1;
    }
    D3D11_MAPPED_SUBRESOURCE mapped{};
    tiff(main::d3d_context->Map(d3d_buffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &mapped));
    vassign(*reinterpret_cast<T*>(mapped.pData), fwd<U>(Object));
    main::d3d_context->Unmap(d3d_buffer, 0);
  }
  /// copies the data through the specified function.
  template<invocable<T&> F> void from(F&& Func) {
    if (!operator bool()) {
      tiff(main::d3d_device->CreateBuffer(&desc, nullptr, d3d_buffer.init()));
      const_cast<unsigned&>(count) = 1;
    }
    D3D11_MAPPED_SUBRESOURCE mapped{};
    tiff(main::d3d_context->Map(d3d_buffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &mapped));
    Func(*reinterpret_cast<T*>(mapped.pData));
    main::d3d_context->Unmap(d3d_buffer, 0);
  }
  /// sets the data to vertex shader.
  void to_vs(nat Slot = 0) const {
    if (!d3d_buffer) throw std::runtime_error("runtime error : yw::constant_buffer::to_vs : Buffer is not initialized");
    [&](ID3D11Buffer* b) { main::d3d_context->VSSetConstantBuffers(Slot, 1, &b); }(d3d_buffer);
  }
  /// sets the data to pixel shader.
  void to_ps(nat Slot = 0) const {
    if (!d3d_buffer) throw std::runtime_error("runtime error : yw::constant_buffer::to_ps : Buffer is not initialized");
    [&](ID3D11Buffer* b) { main::d3d_context->PSSetConstantBuffers(Slot, 1, &b); }(d3d_buffer);
  }
  /// sets the data to geometry shader.
  void to_gs(nat Slot = 0) const {
    if (!d3d_buffer) throw std::runtime_error("runtime error : yw::constant_buffer::to_gs : Buffer is not initialized");
    [&](ID3D11Buffer* b) { main::d3d_context->GSSetConstantBuffers(Slot, 1, &b); }(d3d_buffer);
  }
  /// sets the data to compute shader.
  void to_cs(nat Slot = 0) const {
    if (!d3d_buffer) throw std::runtime_error("runtime error : yw::constant_buffer::to_cs : Buffer is not initialized");
    [&](ID3D11Buffer* b) { main::d3d_context->CSSetConstantBuffers(Slot, 1, &b); }(d3d_buffer);
  }
};

template<typename T> constant_buffer(const T&) -> constant_buffer<T>;

/// class to create a structured buffer.
template<typename T> class structured_buffer : public buffer<T> {
protected:
  comptr<ID3D11ShaderResourceView> d3d_srv{}; // shader resource view
public:
  using buffer<T>::count;
  using buffer<T>::d3d_buffer;
  using buffer<T>::from;
  using buffer<T>::operator ID3D11Buffer*;
  structured_buffer() noexcept = default;
  explicit operator bool() const noexcept { return bool(d3d_buffer) && bool(d3d_srv); }
  operator ID3D11ShaderResourceView*() const noexcept { return d3d_srv; }

  /// copies the data from another buffer `Src`.
  explicit structured_buffer(const buffer<T>& Src) : structured_buffer<T>(Src.count) { from(Src); }

  /// creates a structured buffer with the specified count.
  explicit structured_buffer(numerical auto Count) : buffer<T>(Count) {
    D3D11_BUFFER_DESC desc{unsigned(sizeof(T)) * count, D3D11_USAGE_DEFAULT, D3D11_BIND_SHADER_RESOURCE};
    desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED, desc.StructureByteStride = sizeof(T);
    tiff(main::d3d_device->CreateBuffer(&desc, nullptr, d3d_buffer.init()));
    D3D11_SHADER_RESOURCE_VIEW_DESC srv_desc{DXGI_FORMAT_UNKNOWN, D3D11_SRV_DIMENSION_BUFFER, D3D11_BUFFER_SRV{0, count}};
    tiff(main::d3d_device->CreateShaderResourceView(d3d_buffer, &srv_desc, d3d_srv.init()));
  }

  /// copies the data from CPU memory.
  structured_buffer(const T* Data, const numerical auto Count) : buffer<T>(Count) {
    D3D11_BUFFER_DESC desc{unsigned(sizeof(T)) * count, D3D11_USAGE_DEFAULT, D3D11_BIND_SHADER_RESOURCE};
    desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED, desc.StructureByteStride = sizeof(T);
    if (Data) {
      D3D11_SUBRESOURCE_DATA data{.pSysMem = Data, .SysMemPitch = sizeof(T)};
      tiff(main::d3d_device->CreateBuffer(&desc, &data, buffer<T>::d3d_buffer.init()));
    } else tiff(main::d3d_device->CreateBuffer(&desc, nullptr, buffer<T>::d3d_buffer.init()));
    D3D11_SHADER_RESOURCE_VIEW_DESC srv_desc{DXGI_FORMAT_UNKNOWN, D3D11_SRV_DIMENSION_BUFFER, D3D11_BUFFER_SRV{0, count}};
    tiff(main::d3d_device->CreateShaderResourceView(*this, &srv_desc, d3d_srv.init()));
  }

  /// copies the data from CPU memory.
  template<cnt_range_of<T> Rg> explicit structured_buffer(Rg&& Range)
    : structured_buffer(yw::data(Range), yw::size(Range)) {}

  /// copies the data from CPU memory.
  /// \param Data : pointer to the data; the size of the data must be the same as `count`.
  void from(const T* Data) {
    if (!d3d_buffer) throw std::runtime_error("runtime error : yw::structured_buffer::from : Buffer is not initialized");
    main::d3d_context->UpdateSubresource(d3d_buffer, 0, 0, Data, sizeof(T), unsigned(sizeof(T) * count));
  }

  /// sets the data to the vertex shader.
  void to_vs(nat Slot = 0) const {
    if (!d3d_buffer) throw std::runtime_error("runtime error : yw::structured_buffer::to_vs : Buffer is not initialized");
    [&](ID3D11ShaderResourceView* s) { main::d3d_context->VSSetShaderResources(Slot, 1, &s); }(d3d_srv);
  }

  /// sets the data to the pixel shader.
  void to_ps(nat Slot = 0) const {
    if (!d3d_buffer) throw std::runtime_error("runtime error : yw::structured_buffer::to_ps : Buffer is not initialized");
    [&](ID3D11ShaderResourceView* s) { main::d3d_context->PSSetShaderResources(Slot, 1, &s); }(d3d_srv);
  }

  /// sets the data to the geometry shader.
  void to_gs(nat Slot = 0) const {
    if (!d3d_buffer) throw std::runtime_error("runtime error : yw::structured_buffer::to_gs : Buffer is not initialized");
    [&](ID3D11ShaderResourceView* s) { main::d3d_context->GSSetShaderResources(Slot, 1, &s); }(d3d_srv);
  }

  /// sets the data to the compute shader.
  void to_cs(nat Slot = 0) const {
    if (!d3d_buffer) throw std::runtime_error("runtime error : yw::structured_buffer::to_cs : Buffer is not initialized");
    [&](ID3D11ShaderResourceView* s) { main::d3d_context->CSSetShaderResources(Slot, 1, &s); }(d3d_srv);
  }
};

template<typename T> structured_buffer(const T*, numerical auto) -> structured_buffer<T>;
template<typename T> structured_buffer(const buffer<T>&) -> structured_buffer<T>;
template<cnt_range Rg> structured_buffer(Rg&&) -> structured_buffer<iter_value<Rg>>;

/// class to create a unordered access view.
template<typename T> class unordered_buffer : public buffer<T> {
protected:
  comptr<ID3D11UnorderedAccessView> uav{}; // unordered access view
public:
  using buffer<T>::count;
  using buffer<T>::d3d_buffer;
  using buffer<T>::from;
  using buffer<T>::operator ID3D11Buffer*;
  unordered_buffer() noexcept = default;
  explicit operator bool() const noexcept { return bool(d3d_buffer) && bool(uav); }
  operator ID3D11UnorderedAccessView*() const noexcept { return uav; }

  /// copies the data from another GPU buffer.
  explicit unordered_buffer(const buffer<T>& Src) : unordered_buffer(Src.count) { from(Src); }

  /// creates a unordered access view with the specified count.
  explicit unordered_buffer(numerical auto Count) : buffer<T>(Count) {
    D3D11_BUFFER_DESC desc{unsigned(sizeof(T)) * count, D3D11_USAGE_DEFAULT, D3D11_BIND_UNORDERED_ACCESS};
    desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED, desc.StructureByteStride = sizeof(T);
    tiff(main::d3d_device->CreateBuffer(&desc, nullptr, d3d_buffer.init()));
    tiff(main::d3d_device->CreateUnorderedAccessView(*this, nullptr, uav.init()));
  }

  /// copies the data from CPU memory.
  unordered_buffer(const T* Data, const numerical auto Count) : buffer<T>(Count) {
    D3D11_BUFFER_DESC desc{unsigned(sizeof(T)) * count, D3D11_USAGE_DEFAULT, D3D11_BIND_UNORDERED_ACCESS};
    desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED, desc.StructureByteStride = sizeof(T);
    if (Data) {
      D3D11_SUBRESOURCE_DATA data{.pSysMem = Data, .SysMemPitch = sizeof(T)};
      tiff(main::d3d_device->CreateBuffer(&desc, &data, d3d_buffer.init()));
    } else tiff(main::d3d_device->CreateBuffer(&desc, nullptr, d3d_buffer.init()));
    tiff(main::d3d_device->CreateUnorderedAccessView(*this, nullptr, uav.init()));
  }

  /// copies the data from CPU memory.
  template<cnt_range_of<T> Rg> explicit unordered_buffer(Rg&& Range)
    : unordered_buffer(yw::data(Range), yw::size(Range)) {}

  /// sets the data to the compute shader.
  void to_cs(nat Slot = 0) const {
    if (!d3d_buffer) throw std::runtime_error("runtime error : yw::unordered_buffer::to_cs : Buffer is not initialized");
    [&](ID3D11UnorderedAccessView* u) { main::d3d_context->CSSetUnorderedAccessViews(Slot, 1, &u, nullptr); }(uav);
  }
};

template<typename T> unordered_buffer(const T*, numerical auto) -> unordered_buffer<T>;
template<typename T> unordered_buffer(const buffer<T>&) -> unordered_buffer<T>;
}

namespace yw { // renderer and gpgpu

/// class to render 3D graphics.
template<specialization_of<typepack> VSResources, specialization_of<typepack> VSCBuffers,
         specialization_of<typepack> GSResources = typepack<>, specialization_of<typepack> GSCBuffers = typepack<>,
        specialization_of<typepack> PSResources = typepack<>, specialization_of<typepack> PSCBuffers = typepack<>>
class renderer {
protected:
  static_assert([]<nat... Is>(sequence<Is...>) { return (convertible_to<typename VSResources::template at<Is>, ID3D11ShaderResourceView*> && ...); }(make_indices_for<VSResources>{}));
  static_assert([]<nat... Is>(sequence<Is...>) { return (convertible_to<typename GSResources::template at<Is>, ID3D11ShaderResourceView*> && ...); }(make_indices_for<GSResources>{}));
  static_assert([]<nat... Is>(sequence<Is...>) { return (convertible_to<typename PSResources::template at<Is>, ID3D11ShaderResourceView*> && ...); }(make_indices_for<PSResources>{}));
  static_assert([]<nat... Is>(sequence<Is...>) { return (convertible_to<typename VSCBuffers::template at<Is>, ID3D11Buffer*> && ...); }(make_indices_for<VSCBuffers>{}));
  static_assert([]<nat... Is>(sequence<Is...>) { return (convertible_to<typename GSCBuffers::template at<Is>, ID3D11Buffer*> && ...); }(make_indices_for<GSCBuffers>{}));
  static_assert([]<nat... Is>(sequence<Is...>) { return (convertible_to<typename PSCBuffers::template at<Is>, ID3D11Buffer*> && ...); }(make_indices_for<PSCBuffers>{}));
  comptr<ID3D11VertexShader> d3d_vs{};
  comptr<ID3D11GeometryShader> d3d_gs{};
  comptr<ID3D11PixelShader> d3d_ps{};
public:
  using vs_resource_list = select_type<VSResources::count == 0, none, array<ID3D11ShaderResourceView*, VSResources::count>>;
  using gs_resource_list = select_type<GSResources::count == 0, none, array<ID3D11ShaderResourceView*, GSResources::count>>;
  using ps_resource_list = select_type<PSResources::count == 0, none, array<ID3D11ShaderResourceView*, PSResources::count>>;
  using vs_cbuffer_list = select_type<VSCBuffers::count == 0, none, array<ID3D11Buffer*, VSCBuffers::count>>;
  using gs_cbuffer_list = select_type<GSCBuffers::count == 0, none, array<ID3D11Buffer*, GSCBuffers::count>>;
  using ps_cbuffer_list = select_type<PSCBuffers::count == 0, none, array<ID3D11Buffer*, PSCBuffers::count>>;
  renderer() noexcept = default;
  explicit operator bool() const noexcept { return bool(d3d_vs) && bool(d3d_ps); }

  /// creates a renderer with the merged HLSL code.
  /// \param HLSL : HLSL code that contains the vertex(`vsmain`), geometry(`gsmain`), and pixel(`psmain`) shader.
  renderer(const stv1 HLSL) {
    comptr<ID3DBlob> b, e;
    auto hr = ::D3DCompile(HLSL.data(), HLSL.size(), 0, 0, 0, "vsmain", "vs_5_0", D3D10_SHADER_ENABLE_STRICTNESS, 0, b.init(), e.init());
    if (FAILED(hr)) throw std::runtime_error(std::format("runtime error : yw::renderer : Failed to compile the vertex shader\n{}", static_cast<const char*>(e->GetBufferPointer())));
    tiff(main::d3d_device->CreateVertexShader(b->GetBufferPointer(), b->GetBufferSize(), nullptr, d3d_vs.init()));
    b.reset(), e.reset();
    hr = ::D3DCompile(HLSL.data(), HLSL.size(), 0, 0, 0, "psmain", "ps_5_0", D3D10_SHADER_ENABLE_STRICTNESS, 0, b.init(), e.init());
    if (FAILED(hr)) throw std::runtime_error(std::format("runtime error : yw::renderer : Failed to compile the pixel shader\n{}", static_cast<const char*>(e->GetBufferPointer())));
    tiff(main::d3d_device->CreatePixelShader(b->GetBufferPointer(), b->GetBufferSize(), nullptr, d3d_ps.init()));
    if (HLSL.find("gsmain") == npos) return;
    b.reset(), e.reset();
    hr = ::D3DCompile(HLSL.data(), HLSL.size(), 0, 0, 0, "gsmain", "gs_5_0", D3D10_SHADER_ENABLE_STRICTNESS, 0, b.init(), e.init());
    if (FAILED(hr)) throw std::runtime_error(std::format("runtime error : yw::renderer : Failed to compile the geometry shader\n{}", static_cast<const char*>(e->GetBufferPointer())));
    tiff(main::d3d_device->CreateGeometryShader(b->GetBufferPointer(), b->GetBufferSize(), nullptr, d3d_gs.init()));
  }

  /// renders the 3D graphics.
  void operator()(const numerical auto VertexCounts, vs_resource_list vr, vs_cbuffer_list vcb,
                  gs_resource_list gr = {}, gs_cbuffer_list gcb = {}, ps_resource_list pr = {}, ps_cbuffer_list pcb = {}) const {
    if constexpr (!is_none<vs_resource_list>) main::d3d_context->VSSetShaderResources(0, vs_resource_list::count, vr.data());
    if constexpr (!is_none<vs_cbuffer_list>) main::d3d_context->VSSetConstantBuffers(0, vs_cbuffer_list::count, vcb.data());
    if constexpr (!is_none<gs_resource_list>) main::d3d_context->GSSetShaderResources(0, gs_resource_list::count, gr.data());
    if constexpr (!is_none<gs_cbuffer_list>) main::d3d_context->GSSetConstantBuffers(0, gs_cbuffer_list::count, gcb.data());
    if constexpr (!is_none<ps_resource_list>) main::d3d_context->PSSetShaderResources(0, ps_resource_list::count, pr.data());
    if constexpr (!is_none<ps_cbuffer_list>) main::d3d_context->PSSetConstantBuffers(0, ps_cbuffer_list::count, pcb.data());
    main::d3d_context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    main::d3d_context->IASetInputLayout(nullptr);
    main::d3d_context->IASetVertexBuffers(0, 0, nullptr, nullptr, nullptr);
    main::d3d_context->IASetIndexBuffer(nullptr, DXGI_FORMAT_R32_UINT, 0);
    main::d3d_context->VSSetShader(d3d_vs, nullptr, 0);
    main::d3d_context->GSSetShader(d3d_gs, nullptr, 0);
    main::d3d_context->PSSetShader(d3d_ps, nullptr, 0);
    main::d3d_context->Draw(unsigned(VertexCounts), 0);
  }
};

/// class to perform general-purpose computing on the GPU.
template<specialization_of<typepack> Unordered,
         specialization_of<typepack> Structured = typepack<>,
         specialization_of<typepack> Constant = typepack<>>
class computer {
protected:
  static_assert(Unordered::count > 0);
  comptr<ID3D11ComputeShader> d3d_cs{};
public:
  using ub_list = array<ID3D11UnorderedAccessView*, Unordered::count>;
  using sb_list = array<ID3D11ShaderResourceView*, Structured::count>;
  using cb_list = array<ID3D11Buffer*, Constant::count>;
  computer() noexcept = default;

  /// creates a GPU computer with the HLSL code.
  computer(const stv1 HLSL, const str1& Entry = "csmain", const str1& Target = "cs_5_0") {
    comptr<ID3DBlob> b, e;
    auto hr = ::D3DCompile(HLSL.data(), HLSL.size(), 0, 0, 0, Entry.data(), Target.data(), D3D10_SHADER_ENABLE_STRICTNESS, 0, b.init(), e.init());
    if (FAILED(hr)) throw std::runtime_error(std::format("runtime error : yw::computer::computer : Failed to compile the compute shader\n{}", static_cast<const char*>(e->GetBufferPointer())));
    tiff(main::d3d_device->CreateComputeShader(b->GetBufferPointer(), b->GetBufferSize(), nullptr, d3d_cs.init()));
  }

  /// performs general-purpose computing on the GPU.
  void operator()(ub_list ub, sb_list sb, cb_list cb, const nat4 ThreadGroupX,
                  const nat4 ThreadGroupY = 1, const nat4 ThreadGroupZ = 1) const {
    if (!d3d_cs) throw std::runtime_error("runtime error : yw::computer::operator() : Compute shader is not initialized");
    for (nat i = 0; i < Unordered::count; ++i) if (!ub[i]) throw std::runtime_error(std::format("runtime error : yw::computer::operator() : {}-th unordered access view is not initialized", i));
    for (nat i = 0; i < Structured::count; ++i) if (!sb[i]) throw std::runtime_error(std::format("runtime error : yw::computer::operator() : {}-th shader resource view is not initialized", i));
    for (nat i = 0; i < Constant::count; ++i) if (!cb[i]) throw std::runtime_error(std::format("runtime error : yw::computer::operator() : {}-th constant buffer is not initialized", i));
    main::d3d_context->CSSetShader(d3d_cs, nullptr, 0);
    main::d3d_context->CSSetUnorderedAccessViews(0, Unordered::count, ub.data(), nullptr);
    main::d3d_context->CSSetShaderResources(0, Structured::count, sb.data());
    main::d3d_context->CSSetConstantBuffers(0, Constant::count, cb.data());
    main::d3d_context->Dispatch(unsigned(ThreadGroupX), unsigned(ThreadGroupY), unsigned(ThreadGroupZ));
    std::ranges::fill(ub, nullptr), std::ranges::fill(sb, nullptr), std::ranges::fill(cb, nullptr);
    main::d3d_context->CSSetUnorderedAccessViews(0, Unordered::count, ub.data(), nullptr);
    main::d3d_context->CSSetShaderResources(0, Structured::count, sb.data());
    main::d3d_context->CSSetConstantBuffers(0, Constant::count, cb.data());
  }

  /// performs general-purpose computing on the GPU.
  /// \note numthreads of the compute shader must be `(1024, 1, 1)`.
  void operator()(const numerical auto Parallels, ub_list ub, sb_list sb, cb_list cb) const {
    this->operator()(mv(ub), mv(sb), mv(cb), unsigned(Parallels - 1) / 1024 + 1);
  }
};
}

namespace yw { // bitmap classes

/// class to create a Direct2D bitmap.
class bitmap {
protected:
  comptr<ID2D1Bitmap1> d2d_bitmap{};
public:
  const unsigned width{};  // width of the bitmap
  const unsigned height{}; // height of the bitmap
  bitmap() noexcept = default;
  explicit operator bool() const noexcept { return bool(d2d_bitmap); }
  operator ID2D1Bitmap1*() const noexcept { return d2d_bitmap; }

  bitmap(bitmap&& b) noexcept : d2d_bitmap(mv(b.d2d_bitmap)), width(b.width), height(b.height) {}
  bitmap& operator=(bitmap&& b) noexcept {
    d2d_bitmap = mv(b.d2d_bitmap);
    const_cast<unsigned&>(width) = b.width;
    const_cast<unsigned&>(height) = b.height;
    return *this;
  }

  /// creates a bitmap with the specified width and height.
  bitmap(const numerical auto Width, const numerical auto Height) : width(unsigned(Width)), height(unsigned(Height)) {
    auto p = D2D1::BitmapProperties1(D2D1_BITMAP_OPTIONS_TARGET, D2D1::PixelFormat(DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_PREMULTIPLIED));
    tiff(main::d2d_context->CreateBitmap(D2D1::SizeU(width, height), nullptr, 0, p, d2d_bitmap.init()));
  }
  /// creates a bitmap from the specified file.
  bitmap(const path& File) {
    comptr<IWICBitmapDecoder> decoder;
    tiff(main::wic_factory->CreateDecoderFromFilename(File.c_str(), nullptr, GENERIC_READ, WICDecodeMetadataCacheOnDemand, decoder.init()));
    comptr<IWICBitmapFrameDecode> frame;
    tiff(decoder->GetFrame(0, frame.init()));
    tiff(frame->GetSize(const_cast<unsigned*>(&width), const_cast<unsigned*>(&height)));
    WICPixelFormatGUID image_format, convert_format = GUID_WICPixelFormat32bppPRGBA;
    tiff(frame->GetPixelFormat(&image_format));
    comptr<IWICFormatConverter> converter;
    tiff(main::wic_factory->CreateFormatConverter(converter.init()));
    BOOL can_convert = FALSE;
    tiff(converter->CanConvert(image_format, convert_format, &can_convert));
    if (!can_convert) throw std::runtime_error("runtime error : yw::bitmap : Cannot convert the image format");
    tiff(converter->Initialize(frame, convert_format, WICBitmapDitherTypeErrorDiffusion, nullptr, 0.0, WICBitmapPaletteTypeMedianCut));
    tiff(main::d2d_context->CreateBitmapFromWicBitmap(converter, d2d_bitmap.init()));
  }

  /// begins drawing on the bitmap.
  void begin_draw() const {
    if (!d2d_bitmap) throw std::runtime_error("runtime error : yw::bitmap::begin_draw : Bitmap is not initialized");
    main::d2d_context->SetTarget(d2d_bitmap);
    main::d2d_context->BeginDraw();
  }
  /// begins drawing on the bitmap after clearing it with the specified color.
  void begin_draw(const color& Color) const {
    if (!d2d_bitmap) throw std::runtime_error("runtime error : yw::bitmap::begin_draw : Bitmap is not initialized");
    main::d2d_context->SetTarget(d2d_bitmap);
    main::d2d_context->BeginDraw();
    main::d2d_context->Clear(reinterpret_cast<const D2D1_COLOR_F*>(&Color));
  }
  /// ends drawing on the bitmap.
  void end_draw() const {
    if (!d2d_bitmap) throw std::runtime_error("runtime error : yw::bitmap::end_draw : Bitmap is not initialized");
    tiff(main::d2d_context->EndDraw());
  }
  /// draws the bitmap on the specified render target.
  void draw(const vector& Rect, const numerical auto Opacity) const {
    if (!d2d_bitmap) throw std::runtime_error("runtime error : yw::bitmap::draw : Bitmap is not initialized");
    main::d2d_context->DrawBitmap(d2d_bitmap, reinterpret_cast<const D2D1_RECT_F*>(&Rect), fat4(Opacity), D2D1_BITMAP_INTERPOLATION_MODE_LINEAR);
  }
  /// draws the bitmap on the specified render target.
  void draw(const vector& Rect) const { draw(Rect, 1.f); }

  /// returns a new bitmap which is a rotated copy of the bitmap.
  bitmap rotate(const numerical auto Angle) const {
    auto m = D2D1::Matrix3x2F::Rotation(Angle);
    auto p = array{D2D1_POINT_2F{0, 0}, D2D1::Point2F(fat4(width), 0) * m,
                    D2D1::Point2F(0, fat4(height)) * m, D2D1::Point2F(fat4(width), fat4(height)) * m};
    auto w = array{std::floor(apply(min, projector(p, &D2D1_POINT_2F::x))), ceil(apply(max, projector(p, &D2D1_POINT_2F::x)))};
    auto h = array{std::floor(apply(min, projector(p, &D2D1_POINT_2F::y))), ceil(apply(max, projector(p, &D2D1_POINT_2F::y)))};
    bitmap b(nat(w[1] - w[0]), nat(h[1] - h[0]));
    main::d2d_context->SetTarget(b);
    main::d2d_context->BeginDraw();
    main::d2d_context->SetTransform(m * D2D1::Matrix3x2F::Translation(-w[0], -h[0]));
    main::d2d_context->Clear(bitcast<D2D1_COLOR_F>(color::transparent));
    main::d2d_context->DrawBitmap(d2d_bitmap);
    main::d2d_context->SetTransform(D2D1::Matrix3x2F::Identity());
    main::d2d_context->EndDraw();
    return b;
  }
  /// saves the bitmap as a PNG file.
  void to_png(const path& FileName) const {
    comptr<IWICStream> stream;
    tiff(main::wic_factory->CreateStream(stream.init()));
    tiff(stream->InitializeFromFilename(FileName.c_str(), GENERIC_WRITE));
    comptr<IWICBitmapEncoder> encoder;
    tiff(main::wic_factory->CreateEncoder(GUID_ContainerFormatPng, nullptr, encoder.init()));
    tiff(encoder->Initialize(stream, WICBitmapEncoderNoCache));
    comptr<IWICBitmapFrameEncode> frame;
    tiff(encoder->CreateNewFrame(frame.init(), nullptr));
    tiff(frame->Initialize(nullptr));
    comptr<IWICImageEncoder> image_encoder;
    tiff(main::wic_factory->CreateImageEncoder(main::d2d_device, image_encoder.init()));
    tiff(image_encoder->WriteFrame(d2d_bitmap, frame, nullptr));
    tiff(frame->Commit());
    tiff(encoder->Commit());
    tiff(stream->Commit(STGC_DEFAULT));
  }
};

/// class to create a texture.
class texture : public bitmap {
  void initialize() {
    comptr<IDXGISurface> surface;
    tiff(bitmap::d2d_bitmap->GetSurface(surface.init()));
    tiff(surface->QueryInterface(d3d_texture.init()));
    D3D11_SHADER_RESOURCE_VIEW_DESC srv_desc{DXGI_FORMAT_R8G8B8A8_UNORM, D3D11_SRV_DIMENSION_TEXTURE2D};
    srv_desc.Texture2D = {0, 1};
    tiff(main::d3d_device->CreateShaderResourceView(d3d_texture, &srv_desc, d3d_srv.init()));
  }
protected:
  comptr<ID3D11Texture2D> d3d_texture{};
  comptr<ID3D11ShaderResourceView> d3d_srv{};
public:
  using bitmap::width;
  using bitmap::height;
  using bitmap::operator ID2D1Bitmap1*;

  texture() noexcept = default;
  explicit operator bool() const noexcept { return bool(d3d_texture) && bool(d3d_srv); }
  operator ID3D11Texture2D*() const noexcept { return d3d_texture; }
  operator ID3D11ShaderResourceView*() const noexcept { return d3d_srv; }

  /// creates a texture with the specified width and height.
  texture(const numerical auto Width, const numerical auto Height) : bitmap(Width, Height) { initialize(); }

  /// creates a texture from the specified file.
  texture(const path& File) : bitmap(File) { initialize(); }

  /// creates a texture from the specified bitmap.
  texture(bitmap&& b) : bitmap(mv(b)) { initialize(); }

  /// sets the texture to the vertex shader.
  void to_vs(nat Slot = 0) const {
    if (!d3d_srv) throw std::runtime_error("runtime error : yw::texture::to_vs : Texture is not initialized");
    [&](ID3D11ShaderResourceView* s) { main::d3d_context->VSSetShaderResources(unsigned(Slot), 1, &s); }(d3d_srv);
  }
  /// sets the texture to the pixel shader.
  void to_ps(nat Slot = 0) const {
    if (!d3d_srv) throw std::runtime_error("runtime error : yw::texture::to_ps : Texture is not initialized");
    [&](ID3D11ShaderResourceView* s) { main::d3d_context->PSSetShaderResources(unsigned(Slot), 1, &s); }(d3d_srv);
  }
  /// sets the texture to the geometry shader.
  void to_gs(nat Slot = 0) const {
    if (!d3d_srv) throw std::runtime_error("runtime error : yw::texture::to_gs : Texture is not initialized");
    [&](ID3D11ShaderResourceView* s) { main::d3d_context->GSSetShaderResources(unsigned(Slot), 1, &s); }(d3d_srv);
  }
  /// sets the texture to the compute shader.
  void to_cs(nat Slot = 0) const {
    if (!d3d_srv) throw std::runtime_error("runtime error : yw::texture::to_cs : Texture is not initialized");
    [&](ID3D11ShaderResourceView* s) { main::d3d_context->CSSetShaderResources(unsigned(Slot), 1, &s); }(d3d_srv);
  }
};

/// class to create a 3D render target.
class canvas : public texture {
  void initialize() {
    comptr<ID3D11Texture2D> temp;
    if (const_cast<unsigned&>(msaa) = msaa < 2 ? 0 : (msaa < 4 ? 2 : (msaa < 8 ? 4 : 8)); msaa) {
      D3D11_TEXTURE2D_DESC desc{width, height, 1, 1, DXGI_FORMAT_D24_UNORM_S8_UINT, {msaa, 0}, D3D11_USAGE_DEFAULT, D3D11_BIND_DEPTH_STENCIL};
      tiff(main::d3d_device->CreateTexture2D(&desc, nullptr, temp.init()));
      tiff(main::d3d_device->CreateDepthStencilView(temp, nullptr, d3d_dsv.init()));
      temp.reset(), desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM, desc.BindFlags = D3D11_BIND_RENDER_TARGET;
      tiff(main::d3d_device->CreateTexture2D(&desc, nullptr, temp.init()));
      D3D11_RENDER_TARGET_VIEW_DESC rtv_desc{DXGI_FORMAT_R8G8B8A8_UNORM, D3D11_RTV_DIMENSION_TEXTURE2DMS};
      tiff(main::d3d_device->CreateRenderTargetView(temp, &rtv_desc, d3d_rtv.init()));
    } else {
      D3D11_TEXTURE2D_DESC desc{width, height, 1, 1, DXGI_FORMAT_D24_UNORM_S8_UINT, {1, 0}, D3D11_USAGE_DEFAULT, D3D11_BIND_DEPTH_STENCIL};
      tiff(main::d3d_device->CreateTexture2D(&desc, nullptr, temp.init()));
      tiff(main::d3d_device->CreateDepthStencilView(temp, nullptr, d3d_dsv.init()));
      D3D11_RENDER_TARGET_VIEW_DESC rtv_desc{DXGI_FORMAT_R8G8B8A8_UNORM, D3D11_RTV_DIMENSION_TEXTURE2D};
      tiff(main::d3d_device->CreateRenderTargetView(d3d_texture, &rtv_desc, d3d_rtv.init()));
    }
  }
protected:
  comptr<ID3D11RenderTargetView> d3d_rtv{};
  comptr<ID3D11DepthStencilView> d3d_dsv{};
public:
  using bitmap::width;
  using bitmap::height;

  const unsigned msaa{}; // multi-sample anti-aliasing

  canvas() noexcept = default;
  explicit operator bool() const noexcept { return bool(d3d_texture) && bool(d3d_srv) && bool(d3d_rtv) && bool(d3d_dsv); }
  operator ID3D11Texture2D*() const noexcept { return d3d_texture; }
  operator ID3D11ShaderResourceView*() const noexcept { return d3d_srv; }
  operator ID3D11RenderTargetView*() const noexcept { return d3d_rtv; }

  canvas(canvas&& c) noexcept : texture(mv(c)), msaa(c.msaa), d3d_rtv(mv(c.d3d_rtv)), d3d_dsv(mv(c.d3d_dsv)) {}

  canvas& operator=(canvas&& c) noexcept {
    texture::operator=(mv(c));
    const_cast<unsigned&>(msaa) = c.msaa;
    d3d_rtv = mv(c.d3d_rtv);
    d3d_dsv = mv(c.d3d_dsv);
    return *this;
  }

  /// creates a 3D render target with the specified width and height.
  canvas(const numerical auto Width, const numerical auto Height, const numerical auto MSAA = 8)
    : texture(Width, Height), msaa(unsigned(MSAA)) { initialize(); }

  /// creates a 3D render target from the specified texture.
  explicit canvas(texture&& t, const numerical auto MSAA = 8) : texture(mv(t)), msaa(unsigned(MSAA)) { initialize(); }

  /// begins rendering on this render target.
  template<typename... RTV_OR_UAV> void begin_render(RTV_OR_UAV&&... Views) const
    requires(bool(convertible_to<RTV_OR_UAV, ID3D11RenderTargetView*> ^ convertible_to<RTV_OR_UAV, ID3D11UnorderedAccessView*>) && ...) {
    if (!d3d_rtv) throw std::runtime_error("runtime error : yw::canvas::begin_render : Render target is not initialized");
    main::d3d_context->ClearDepthStencilView(d3d_dsv, D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);
    [](D3D11_VIEWPORT vp) { main::d3d_context->RSSetViewports(1, &vp); }({0, 0, (float)width, (float)height, 0, 1});
    static constexpr unsigned m = unsigned(counts<convertible_to<RTV_OR_UAV, ID3D11RenderTargetView*>...>), n = unsigned(sizeof...(RTV_OR_UAV) - m);
    if constexpr (n == 0) [&]<nat... Is>(array<ID3D11RenderTargetView*, m + 1> RTVs) { main::d3d_context->OMSetRenderTargets(m + 1, RTVs.data(), d3d_dsv); }({d3d_rtv, Views...});
    else [&](auto&& RTVs, auto&& UAVs) { main::d3d_context->OMSetRenderTargetsAndUnorderedAccessViews(m + 1, RTVs.data(), d3d_dsv, m + 1, n, UAVs.data(), nullptr); }(
      [&]<nat... Is>(sequence<Is...>) { return array<ID3D11RenderTargetView*, m + 1>{d3d_rtv, select_parameter<Is>(Views...)...}; }(
        extracting_indices<sequence<convertible_to<RTV_OR_UAV, ID3D11RenderTargetView*>...>>{}),
      [&]<nat... Is>(sequence<Is...>) { return array<ID3D11UnorderedAccessView*, n>{select_parameter<Is>(Views...)...}; }(
        extracting_indices<sequence<convertible_to<RTV_OR_UAV, ID3D11UnorderedAccessView*>...>>{}));
  };
  /// begins rendering on this render target after clearing it with the specified color.
  template<typename... RTV_OR_UAV> void begin_render(const color& Color, RTV_OR_UAV&&... Views) const
    requires(bool(convertible_to<RTV_OR_UAV, ID3D11RenderTargetView*> ^ convertible_to<RTV_OR_UAV, ID3D11UnorderedAccessView*>) && ...) {
    if (!d3d_rtv) throw std::runtime_error("runtime error : yw::canvas::begin_render : Render target is not initialized");
    main::d3d_context->ClearRenderTargetView(d3d_rtv, &Color.r);
    begin_render(fwd<RTV_OR_UAV>(Views)...);
  }
  /// ends rendering on this render target.
  void end_render() const {
    if (!d3d_rtv) throw std::runtime_error("runtime error : yw::canvas::end_render : Render target is not initialized");
    if (msaa) [&](comptr<ID3D11Resource> a) { d3d_rtv->GetResource(a.init()), main::d3d_context->ResolveSubresource(*this, 0, a, 0, DXGI_FORMAT_R8G8B8A8_UNORM); }({});
    main::d3d_context->OMSetRenderTargets(0, nullptr, nullptr);
  }
};

/// class to create a perspective camera.
class perspective_camera : public canvas {
public:
  using canvas::operator bool;
  using canvas::operator ID3D11Texture2D*;
  using canvas::operator ID3D11ShaderResourceView*;
  using canvas::operator ID3D11RenderTargetView*;

  xmatrix view{};      // view matrix
  xmatrix view_proj{}; // view-projection matrix
  vector offset{};     // offsets of the camera lens from the center point
  vector rotation{};   // rotation angles of the camera lens by degrees
  vector position{};   // position of the camera
  fat4 fov{};          // field of view

  perspective_camera() noexcept = default;
  perspective_camera(canvas&& c) : canvas(mv(c)) {}

  perspective_camera(const numerical auto Width, const numerical auto Height, const numerical auto MSAA = 8)
    : canvas(Width, Height, MSAA) {}

  /// updates the matrices.
  void update() {
    constexpr fat4 f = 1048576.0f, n = 0.25f;
    xvview(position, rotation, offset, view);
    auto t = 1.f / std::tan(fov * 0.5f);
    auto a = xvload((-t * height) / width, t, cev(f / (f - n)), cev(-f * n / (f - n)));
    view_proj[0] = xvmul(view[0], xvpermute<0, 0, 0, 0>(a));
    view_proj[1] = xvmul(view[1], xvpermute<1, 1, 1, 1>(a));
    view_proj[2] = xvadd(xvmul(view[2], xvpermute<2, 2, 2, 2>(a)), xvsetzero<1, 1, 1, 0>(a));
    view_proj[3] = view[2];
  }
};

/// class to create a orthographic camera.
class orthographic_camera : public canvas {
public:
  using canvas::operator bool;
  using canvas::operator ID3D11Texture2D*;
  using canvas::operator ID3D11ShaderResourceView*;
  using canvas::operator ID3D11RenderTargetView*;

  xmatrix view{};      // view matrix
  xmatrix view_proj{}; // view-projection matrix
  vector offset{};     // offsets of the camera lens from the center point
  vector rotation{};   // rotation angles of the camera lens by degrees
  vector position{};   // position of the camera
  fat4 factor{};       // magnification factor

  orthographic_camera() noexcept = default;
  orthographic_camera(canvas&& c) : canvas(mv(c)) {}

  orthographic_camera(const numerical auto Width, const numerical auto Height, const numerical auto MSAA = 8)
    : canvas(Width, Height, MSAA) {}

  /// updates the matrices.
  void update() {
    constexpr fat4 f = 1048576.0f, n = 0.25f;
    xvview(position, rotation, offset, view);
    auto a = xvload(-2.f * factor / width, -2.f * factor / height, cev(1.f / (f - n)), cev(n / (f - n)));
    view_proj[0] = xvmul(view[0], xvpermute<0, 0, 0, 0>(a));
    view_proj[1] = xvmul(view[1], xvpermute<1, 1, 1, 1>(a));
    view_proj[2] = xvsub(xvmul(view[2], xvpermute<2, 2, 2, 2>(a)), xvsetzero<1, 1, 1, 0>(a));
    view_proj[3] = view[3];
  }
};
}

#include <CommCtrl.h>
#pragma comment(lib, "Comctl32.lib")

namespace yw { // control classes

/// base class to create a control.
class control {
public:
  inline static constexpr nat max_groups = 16; // maximum number of control groups
  const HWND hwnd{};     // handle of this control
  const HFONT hfont{};   // handle of the font
  const nat gourp{npos}; // group id of this control

  /// shows this contorl.
  virtual void show() const { ::ShowWindow(hwnd, SW_SHOW); }
  /// hides this contorl.
  virtual void hide() const { ::ShowWindow(hwnd, SW_HIDE); }
  /// sets the focus to this contorl.
  virtual void setfocus() const { ::SetFocus(hwnd); }
  /// sets the text of this control.
  virtual void text(const string<cat2>& Text) const { ::SetWindowText(hwnd, Text.c_str()); }
  /// gets the text of this control.
  virtual string<cat2> text() const {
    if (!hwnd) return {};
    str2 s(::GetWindowTextLengthW(hwnd), L'\0');
    ::GetWindowTextW(hwnd, s.data(), UINT(s.size() + 1));
    return s;
  }
};
}

/*

namespace yw { // GPGPU Functions

/// struct to represent a triangle facet.
struct facet {
  vector3 a; // position of the first vertex A
  vector3 b; // position of the second vertex B
  vector3 c; // position of the third vertex C
  vector3 ab; // vector from A to B
  vector3 bc; // vector from B to C
  vector3 ca; // vector from C to A
  vector3 sq; // squares of the lengths of the sides; `(AB^2, BC^2, CA^2)`
  vector3 nisq; // negative inverse squares of the sides; `(-1/AB^2, -1/BC^2, -1/CA^2)`
  vector plane; // plane equation; `(a, b, c, d)`; `ax + by + cz + d = 0`
  constexpr facet() noexcept = default;
  /// constructs a facet from three vertices.
  constexpr facet(const vector3& A, const vector3& B, const vector3& C) noexcept
    : a(A), b(B), c(C), ab(B - A), bc(C - B), ca(A - C),
      sq{ab.power(), bc.power(), ca.power()}, nisq(-1 / sq), plane{} {
    auto t = cross(a, b);
    plane = vector(t + cross(b, c) + cross(c, a), -dot(t, c));
    plane = plane / std::hypot(plane.x, plane.y, plane.z);
  }
};

// the size of `facet` must be 28 * 4 bytes.
static_assert(sizeof(facet) == 28 * 4);

/// calculates the distance from each point to the nearest point in the point cloud.
/// \param Points points
/// \param PointCloud point cloud
/// \param [out] Distances distances
/// \param [out] Nearests nearest points
/// \param World world matrix
void calc_distance_point_to_points(
  unordered_buffer<fat4>& Distances,
  unordered_buffer<nat4>& Nearests,
  const structured_buffer<vector>& Points,
  const structured_buffer<vector>& PointCloud,
  const constant_buffer<xmatrix>& World) {
  try {
    if (Points.count == 0) throw std::runtime_error("runtime error : yw::calc_distance_point_to_point : `Points` is empty");
    if (PointCloud.count == 0) throw std::runtime_error("runtime error : yw::calc_distance_point_to_point : `PointCloud` is empty");
    if (Distances.count != Points.count) throw std::runtime_error("runtime error : yw::calc_distance_point_to_point : `Distances` is invalid");
    if (Nearests.count != Points.count) throw std::runtime_error("runtime error : yw::calc_distance_point_to_point : `Nearests` is invalid");
    static constexpr string_view<cat1> hlsl = R"(
#pragma pack_matrix(row_major)
struct Point { float4 p; };
struct Distance { float d; };
struct Index { uint i; };
StructuredBuffer<Point> Points : register(t0);
StructuredBuffer<Point> PointCloud : register(t1);
RWStructuredBuffer<Distance> Distances : register(u0);
RWStructuredBuffer<Index> Nearests : register(u1);
cbuffer Matrix : register(b0) { matrix w; };
cbuffer Info : register(b1) { uint m; uint n; uint dummy[2]; };
[numthreads(1024, 1, 1)] void csmain(uint i : SV_DispatchThreadID) {
  if (i >= m) return;
  const float4 p = mul(w, Points[i].p);
  Distances[i].d = 1e+38;
  for (uint j = 0; j < n; ++j) {
    float4 d = p - PointCloud[j].p;
    d.w = dot(d.xyz, d.xyz);
    if (d.w < Distances[i].d) Distances[i].d = d.w, Nearests[i].i = j;
  }
  Distances[i].d = sqrt(Distances[i].d);
})";
    constant_buffer<list<nat4, nat4, nat8>> cb({Points.count, PointCloud.count, 0});
    computer<
      typepack<unordered_buffer<fat4>, unordered_buffer<int4>>,
      typepack<structured_buffer<vector>, structured_buffer<vector>>,
      typepack<constant_buffer<xmatrix>, constant_buffer<list<nat4, nat4, nat8>>>> c(hlsl);
    c(Points.count, {Distances, Nearests}, {Points, PointCloud}, {World, cb});
  } catch (const std::exception& e) { log.error(e.what()); }
}

/// calculates the distance from each point to the nearest facet in the mesh.
/// \param Points points
/// \param Facets facets
/// \param [out] Distances distances
/// \param [out] Nearests nearest facets
/// \param World world matrix
void calc_distance_point_to_facets(
  unordered_buffer<fat4>& Distances,
  unordered_buffer<int4>& Nearests,
  const structured_buffer<vector>& Points,
  const structured_buffer<array<fat4, 28>>& Facets,
  const constant_buffer<xmatrix>& World) {
  try {
    if (Points.count == 0) throw std::runtime_error("runtime error : yw::calc_distance_point_to_facets : `Points` is empty");
    if (Facets.count == 0) throw std::runtime_error("runtime error : yw::calc_distance_point_to_facets : `Facets` is empty");
    if (Distances.count != Points.count) throw std::runtime_error("runtime error : yw::calc_distance_point_to_facets : `Distances` is invalid");
    if (Nearests.count != Points.count) throw std::runtime_error("runtime error : yw::calc_distance_point_to_facets : `Nearests` is invalid");
    static constexpr string_view<cat1> hlsl = R"(
#pragma pack_matrix(row_major)
struct Point { float4 p; };
struct Facet {  float3 a, b, c; float3 ab, bc, ca; float3 sq, nisq; float4 plane; };
struct Distance { float d; };
struct Index { uint i; };
StructuredBuffer<Point> Points : register(t0);
StructuredBuffer<Facet> Facets : register(t1);
RWStructuredBuffer<Distance> Distances : register(u0);
RWStructuredBuffer<Index> Nearests : register(u1);
cbuffer Matrix : register(b0) { matrix w; };
cbuffer Info : register(b1) { uint m; uint n; uint dummy[2]; };
[numthreads(1024, 1, 1)] void csmain(uint i : SV_DispatchThreadID) {
  if (i >= m) return;
  const float3 p = mul(w, Points[i].p).xyz;
  Distances[i].d = 1e+38;
  float3 a, b, c;
  float d, e;
  for (uint j = 0; j < n; ++j) {
    a = p - Facets[j].a.xyz, b = p - Facets[j].b.xyz, c = p - Facets[j].c.xyz;
    d = dot(p, Facets[j].plane.xyz) - Facets[j].plane.w;
    if (Distances[i].d < d * d) continue;
    if (dot(cross(a, b), Facets[j].plane.xyz) < 0) {
      e = dot(a, Facets[j].ab);
      if (e < 0) e = dot(a, a);
      else if (Facets[j].sq.x < e) e = dot(b, b);
      else e = dot(a, a) + e * e * Facets[j].nisq.x;
      if (e < Distances[i].d) Distances[i].d = e, Nearests[i].i = j;
    } else if (dot(cross(b, c), Facets[j].plane.xyz) < 0) {
      e = dot(b, Facets[j].bc);
      if (e < 0) e = dot(b, b);
      else if (Facets[j].sq.y < e) e = dot(c, c);
      else e = dot(b, b) + e * e * Facets[j].nisq.y;
      if (e < Distances[i].d) Distances[i].d = e, Nearests[i].i = j;
    } else if (dot(cross(c, a), Facets[j].plane.xyz) < 0) {
      e = dot(c, Facets[j].ca);
      if (e < 0) e = dot(c, c);
      else if (Facets[j].sq.z < e) e = dot(a, a);
      else e = dot(c, c) + e * e * Facets[j].nisq.z;
      if (e < Distances[i].d) Distances[i].d = e, Nearests[i].i = j;
    } else Distances[i].d = d * d, Nearests[i].i = j;
  }
  Distances[i].d = sqrt(Distances[i].d);
})";
    constant_buffer<list<nat4, nat4, nat8>> cb({Points.count, Facets.count, 0});
    computer<
      typepack<unordered_buffer<fat4>, unordered_buffer<int4>>,
      typepack<structured_buffer<vector>, structured_buffer<array<fat4, 28>>>,
      typepack<constant_buffer<xmatrix>, constant_buffer<list<nat4, nat4, nat8>>>> c(hlsl);
    c(Points.count, {Distances, Nearests}, {Points, Facets}, {World, cb});
  } catch (const std::exception& e) { log.error(e.what()); }
}

/// calculates the nearest intersection of the ray (half line) and the mesh.
/// \param [out] Intersections nearest intersections
/// \param [out] Distances distances to the nearest intersections
/// \param Rays rays; each ray consists of a point and a normalized vector
/// \param Facets facets of the mesh
/// \param World world matrix
void calc_intersection_line_to_facets(
  unordered_buffer<vector>& Intersections,
  unordered_buffer<fat4>& Distances,
  const structured_buffer<list<vector, vector>>& Rays,
  const structured_buffer<array<fat4, 28>>& Facets,
  const xmatrix& World) {
  try {
    if (Rays.count == 0) throw std::runtime_error("runtime error : yw::calc_intersection_line_to_facets : `Rays` is empty");
    if (Facets.count == 0) throw std::runtime_error("runtime error : yw::calc_intersection_line_to_facets : `Facets` is empty");
    if (Intersections.count != Rays.count) throw std::runtime_error("runtime error : yw::calc_intersection_line_to_facets : `Intersections` is invalid");
    static constexpr string_view<cat1> hlsl = R"(
#pragma pack_matrix(row_major)
struct Ray { float4 p, v; };
struct Facet { float3 a, b, c; float3 ab, bc, ca; float3 sq, nisq; float4 plane; };
struct Intersection { float4 p; };
struct Distance { float w; };
cbuffer Matrix : register(b0) { matrix invw; };
cbuffer Info : register(b1) { uint m; uint n; uint dummy[2]; };
StructuredBuffer<Ray> Rays : register(t0);
StructuredBuffer<Facet> Facets : register(t1);
RWStructuredBuffer<Intersection> Intersections : register(u0);
RWStructuredBuffer<Distance> Distances : register(u1);
[numthreads(1024, 1, 1)] void csmain(uint i : SV_DispatchThreadID) {
  if (i >= m) return;
  const float3 p = mul(invw, Rays[i].p).xyz, v = mul(invw, Rays[i].v).xyz;
  Distances[i].w = 1e+38;
  float d;
  for (uint j = 0; j < n; ++j) {
    d = (Facets[j].plane.w - dot(p, Facets[j].plane.xyz)) / dot(v, Facets[j].plane.xyz);
    if (d < 0 || Distances[i].w < d) continue;
    float3 q = p + d * v, a = Facets[j].a.xyz - q, b = Facets[j].b.xyz - q, c = Facets[j].c.xyz - q;
    if (dot(cross(a, b), Facets[j].plane.xyz) >= 0 && dot(cross(b, c), Facets[j].plane.xyz) >= 0 &&
        dot(cross(c, a), Facets[j].plane.xyz) >= 0) Distances[i].w = d, Intersections[i].p = float4(q, 1);
  }
})";
    constant_buffer<xmatrix> cb;
    cb.from([&](xmatrix& m) { xvinverse_transformation(World, m); });
    constant_buffer<list<nat4, nat4, nat8>> ci({Rays.count, Facets.count, 0});
    computer<
      typepack<unordered_buffer<vector>, unordered_buffer<fat4>>,
      typepack<structured_buffer<list<vector, vector>>, structured_buffer<array<fat4, 28>>>,
      typepack<constant_buffer<xmatrix>, constant_buffer<list<nat4, nat4, nat8>>>> c(hlsl);
    c(Rays.count, {Intersections, Distances}, {Rays, Facets}, {cb, ci});
  } catch (const std::exception& e) { log.error(e.what()); }
}

/// calculates the points that constitutes the cross section of the mesh by a plane.
/// \param World world matrix to transform the mesh
/// \param Plane plane to cut the mesh; `(x,y,z).X = w`; length of `(x,y,z)` must be 1
/// \param Facets facets of the mesh
/// \return points that constitutes the cross section
array<vector> calc_section_facets_by_plane(
  const xmatrix& World,
  const vector& Plane,
  const structured_buffer<array<fat4, 28>>& Facets) {
  try {
    if (Facets.count == 0) throw std::runtime_error("runtime error : yw::calc_section_facets_by_plane : `Facets` is empty");
    if (SectionPoints.count == 0) throw std::runtime_error("runtime error : yw::calc_section_facets_by_plane : `SectionPoints` is empty");
    if (!Plane) throw std::runtime_error("runtime error : yw::calc_section_facets_by_plane : `Plane` is not initialized");
    static constexpr string_view<cat1> hlsl = R"(
#pragma pack_matrix(row_major)
struct Facet { float3 a, b, c; float3 ab, bc, ca; float3 sq, nisq; float4 plane; };
struct Point { float4 p; };
cbuffer Plane : register(b0) { float4 plane; };
cbuffer Matrix : register(b1) { matrix w; };
cbuffer Info : register(b2) { uint m; uint dummy[3]; };
StructuredBuffer<Facet> Facets : register(t0);
RWStructuredBuffer<Point> SectionPoints : register(u0);
[numthreads(1024, 1, 1)] void csmain(uint i : SV_DispatchThreadID) {
  if (i >= m) return;
  const float4 p = mul(w, Facets[i].a);
  float3 a = p.xyz - plane.xyz;
  float3 b = mul(w, Facets[i].b).xyz - plane.xyz;
  float3 c = mul(w, Facets[i].c).xyz - plane.xyz;
  float3 n = cross(b - a, c - a);
  float d = dot(n, a);
  if (dot(n, plane.xyz) - d < 0.0001) return;
  float3 q = a + (d - dot(n, a)) / dot(n, n) * n;
  SectionPoints[i].p = float4(q, 1);
})";
  } catch (const std::exception& e) { log.error(e.what()); }
}


}

*/
